
#include "souffle/CompiledSouffle.h"
#include <mutex>
#include "souffle/Explain.h"

extern "C" {
}

namespace souffle {
using namespace ram;
struct t_btree_4__0_1_3_2__1_0_2_3__1__2__3__15 {
using t_tuple = Tuple<RamDomain, 4>;
struct updater_t_btree_4__0_1_3_2__1_0_2_3__1__2__3__15 {
void update(t_tuple& old_t, const t_tuple& new_t) {
old_t[2] = new_t[2];
old_t[3] = new_t[3];
}
};
using t_ind_0 = btree_set<t_tuple, index_utils::comparator<0,1,3,2>, std::allocator<t_tuple>, 256, typename souffle::detail::default_strategy<t_tuple>::type, index_utils::comparator<0,1>, updater_t_btree_4__0_1_3_2__1_0_2_3__1__2__3__15>;
t_ind_0 ind_0;
using t_ind_1 = btree_set<t_tuple, index_utils::comparator<1,0,2,3>, std::allocator<t_tuple>, 256, typename souffle::detail::default_strategy<t_tuple>::type, index_utils::comparator<1,0>, updater_t_btree_4__0_1_3_2__1_0_2_3__1__2__3__15>;
t_ind_1 ind_1;
using iterator = t_ind_0::iterator;
struct context {
t_ind_0::operation_hints hints_0;
t_ind_1::operation_hints hints_1;
};
context createContext() { return context(); }
bool insert(const t_tuple& t) {
context h;
return insert(t, h);
}
bool insert(const t_tuple& t, context& h) {
if (ind_0.insert(t, h.hints_0)) {
ind_1.insert(t, h.hints_1);
return true;
} else return false;
}
bool insert(const RamDomain* ramDomain) {
RamDomain data[4];
std::copy(ramDomain, ramDomain + 4, data);
const t_tuple& tuple = reinterpret_cast<const t_tuple&>(data);
context h;
return insert(tuple, h);
}
bool insert(RamDomain a0,RamDomain a1,RamDomain a2,RamDomain a3) {
RamDomain data[4] = {a0,a1,a2,a3};
return insert(data);
}
template <typename T>
void insertAll(T& other) {
for (auto const& cur : other) {
insert(cur);
}
}
void insertAll(t_btree_4__0_1_3_2__1_0_2_3__1__2__3__15& other) {
ind_0.insertAll(other.ind_0);
ind_1.insertAll(other.ind_1);
}
bool contains(const t_tuple& t, context& h) const {
return ind_0.contains(t, h.hints_0);
}
bool contains(const t_tuple& t) const {
context h;
return contains(t, h);
}
std::size_t size() const {
return ind_0.size();
}
iterator find(const t_tuple& t, context& h) const {
return ind_0.find(t, h.hints_0);
}
iterator find(const t_tuple& t) const {
context h;
return find(t, h);
}
range<iterator> equalRange_0(const t_tuple& t, context& h) const {
return range<iterator>(ind_0.begin(),ind_0.end());
}
range<iterator> equalRange_0(const t_tuple& t) const {
return range<iterator>(ind_0.begin(),ind_0.end());
}
range<t_ind_0::iterator> equalRange_1(const t_tuple& t, context& h) const {
t_tuple low(t); t_tuple high(t);
low[1] = MIN_RAM_DOMAIN;
high[1] = MAX_RAM_DOMAIN;
low[2] = MIN_RAM_DOMAIN;
high[2] = MAX_RAM_DOMAIN;
low[3] = MIN_RAM_DOMAIN;
high[3] = MAX_RAM_DOMAIN;
return make_range(ind_0.lower_bound(low, h.hints_0), ind_0.upper_bound(high, h.hints_0));
}
range<t_ind_0::iterator> equalRange_1(const t_tuple& t) const {
context h;
return equalRange_1(t, h);
}
range<t_ind_1::iterator> equalRange_2(const t_tuple& t, context& h) const {
t_tuple low(t); t_tuple high(t);
low[0] = MIN_RAM_DOMAIN;
high[0] = MAX_RAM_DOMAIN;
low[2] = MIN_RAM_DOMAIN;
high[2] = MAX_RAM_DOMAIN;
low[3] = MIN_RAM_DOMAIN;
high[3] = MAX_RAM_DOMAIN;
return make_range(ind_1.lower_bound(low, h.hints_1), ind_1.upper_bound(high, h.hints_1));
}
range<t_ind_1::iterator> equalRange_2(const t_tuple& t) const {
context h;
return equalRange_2(t, h);
}
range<t_ind_0::iterator> equalRange_3(const t_tuple& t, context& h) const {
t_tuple low(t); t_tuple high(t);
low[2] = MIN_RAM_DOMAIN;
high[2] = MAX_RAM_DOMAIN;
low[3] = MIN_RAM_DOMAIN;
high[3] = MAX_RAM_DOMAIN;
return make_range(ind_0.lower_bound(low, h.hints_0), ind_0.upper_bound(high, h.hints_0));
}
range<t_ind_0::iterator> equalRange_3(const t_tuple& t) const {
context h;
return equalRange_3(t, h);
}
range<t_ind_1::iterator> equalRange_15(const t_tuple& t, context& h) const {
auto pos = ind_1.find(t, h.hints_1);
auto fin = ind_1.end();
if (pos != fin) {fin = pos; ++fin;}
return make_range(pos, fin);
}
range<t_ind_1::iterator> equalRange_15(const t_tuple& t) const {
context h;
return equalRange_15(t, h);
}
bool empty() const {
return ind_0.empty();
}
std::vector<range<iterator>> partition() const {
return ind_0.getChunks(400);
}
void purge() {
ind_0.clear();
ind_1.clear();
}
iterator begin() const {
return ind_0.begin();
}
iterator end() const {
return ind_0.end();
}
void printHintStatistics(std::ostream& o, const std::string prefix) const {
const auto& stats_0 = ind_0.getHintStatistics();
o << prefix << "arity 4 direct b-tree index [0,1,3,2]: (hits/misses/total)\n";
o << prefix << "Insert: " << stats_0.inserts.getHits() << "/" << stats_0.inserts.getMisses() << "/" << stats_0.inserts.getAccesses() << "\n";
o << prefix << "Contains: " << stats_0.contains.getHits() << "/" << stats_0.contains.getMisses() << "/" << stats_0.contains.getAccesses() << "\n";
o << prefix << "Lower-bound: " << stats_0.lower_bound.getHits() << "/" << stats_0.lower_bound.getMisses() << "/" << stats_0.lower_bound.getAccesses() << "\n";
o << prefix << "Upper-bound: " << stats_0.upper_bound.getHits() << "/" << stats_0.upper_bound.getMisses() << "/" << stats_0.upper_bound.getAccesses() << "\n";
const auto& stats_1 = ind_1.getHintStatistics();
o << prefix << "arity 4 direct b-tree index [1,0,2,3]: (hits/misses/total)\n";
o << prefix << "Insert: " << stats_1.inserts.getHits() << "/" << stats_1.inserts.getMisses() << "/" << stats_1.inserts.getAccesses() << "\n";
o << prefix << "Contains: " << stats_1.contains.getHits() << "/" << stats_1.contains.getMisses() << "/" << stats_1.contains.getAccesses() << "\n";
o << prefix << "Lower-bound: " << stats_1.lower_bound.getHits() << "/" << stats_1.lower_bound.getMisses() << "/" << stats_1.lower_bound.getAccesses() << "\n";
o << prefix << "Upper-bound: " << stats_1.upper_bound.getHits() << "/" << stats_1.upper_bound.getMisses() << "/" << stats_1.upper_bound.getAccesses() << "\n";
}
};
struct t_btree_3__0_1_2__1__7 {
using t_tuple = Tuple<RamDomain, 3>;
struct updater_t_btree_3__0_1_2__1__7 {
void update(t_tuple& old_t, const t_tuple& new_t) {
old_t[1] = new_t[1];
old_t[2] = new_t[2];
}
};
using t_ind_0 = btree_set<t_tuple, index_utils::comparator<0,1,2>, std::allocator<t_tuple>, 256, typename souffle::detail::default_strategy<t_tuple>::type, index_utils::comparator<0>, updater_t_btree_3__0_1_2__1__7>;
t_ind_0 ind_0;
using iterator = t_ind_0::iterator;
struct context {
t_ind_0::operation_hints hints_0;
};
context createContext() { return context(); }
bool insert(const t_tuple& t) {
context h;
return insert(t, h);
}
bool insert(const t_tuple& t, context& h) {
if (ind_0.insert(t, h.hints_0)) {
return true;
} else return false;
}
bool insert(const RamDomain* ramDomain) {
RamDomain data[3];
std::copy(ramDomain, ramDomain + 3, data);
const t_tuple& tuple = reinterpret_cast<const t_tuple&>(data);
context h;
return insert(tuple, h);
}
bool insert(RamDomain a0,RamDomain a1,RamDomain a2) {
RamDomain data[3] = {a0,a1,a2};
return insert(data);
}
template <typename T>
void insertAll(T& other) {
for (auto const& cur : other) {
insert(cur);
}
}
void insertAll(t_btree_3__0_1_2__1__7& other) {
ind_0.insertAll(other.ind_0);
}
bool contains(const t_tuple& t, context& h) const {
return ind_0.contains(t, h.hints_0);
}
bool contains(const t_tuple& t) const {
context h;
return contains(t, h);
}
std::size_t size() const {
return ind_0.size();
}
iterator find(const t_tuple& t, context& h) const {
return ind_0.find(t, h.hints_0);
}
iterator find(const t_tuple& t) const {
context h;
return find(t, h);
}
range<iterator> equalRange_0(const t_tuple& t, context& h) const {
return range<iterator>(ind_0.begin(),ind_0.end());
}
range<iterator> equalRange_0(const t_tuple& t) const {
return range<iterator>(ind_0.begin(),ind_0.end());
}
range<t_ind_0::iterator> equalRange_1(const t_tuple& t, context& h) const {
t_tuple low(t); t_tuple high(t);
low[1] = MIN_RAM_DOMAIN;
high[1] = MAX_RAM_DOMAIN;
low[2] = MIN_RAM_DOMAIN;
high[2] = MAX_RAM_DOMAIN;
return make_range(ind_0.lower_bound(low, h.hints_0), ind_0.upper_bound(high, h.hints_0));
}
range<t_ind_0::iterator> equalRange_1(const t_tuple& t) const {
context h;
return equalRange_1(t, h);
}
range<t_ind_0::iterator> equalRange_7(const t_tuple& t, context& h) const {
auto pos = ind_0.find(t, h.hints_0);
auto fin = ind_0.end();
if (pos != fin) {fin = pos; ++fin;}
return make_range(pos, fin);
}
range<t_ind_0::iterator> equalRange_7(const t_tuple& t) const {
context h;
return equalRange_7(t, h);
}
bool empty() const {
return ind_0.empty();
}
std::vector<range<iterator>> partition() const {
return ind_0.getChunks(400);
}
void purge() {
ind_0.clear();
}
iterator begin() const {
return ind_0.begin();
}
iterator end() const {
return ind_0.end();
}
void printHintStatistics(std::ostream& o, const std::string prefix) const {
const auto& stats_0 = ind_0.getHintStatistics();
o << prefix << "arity 3 direct b-tree index [0,1,2]: (hits/misses/total)\n";
o << prefix << "Insert: " << stats_0.inserts.getHits() << "/" << stats_0.inserts.getMisses() << "/" << stats_0.inserts.getAccesses() << "\n";
o << prefix << "Contains: " << stats_0.contains.getHits() << "/" << stats_0.contains.getMisses() << "/" << stats_0.contains.getAccesses() << "\n";
o << prefix << "Lower-bound: " << stats_0.lower_bound.getHits() << "/" << stats_0.lower_bound.getMisses() << "/" << stats_0.lower_bound.getAccesses() << "\n";
o << prefix << "Upper-bound: " << stats_0.upper_bound.getHits() << "/" << stats_0.upper_bound.getMisses() << "/" << stats_0.upper_bound.getAccesses() << "\n";
}
};
struct t_btree_5__0_1_2_3_4__31 {
using t_tuple = Tuple<RamDomain, 5>;
using t_ind_0 = btree_set<t_tuple, index_utils::comparator<0,1,2,3,4>>;
t_ind_0 ind_0;
using iterator = t_ind_0::iterator;
struct context {
t_ind_0::operation_hints hints_0;
};
context createContext() { return context(); }
bool insert(const t_tuple& t) {
context h;
return insert(t, h);
}
bool insert(const t_tuple& t, context& h) {
if (ind_0.insert(t, h.hints_0)) {
return true;
} else return false;
}
bool insert(const RamDomain* ramDomain) {
RamDomain data[5];
std::copy(ramDomain, ramDomain + 5, data);
const t_tuple& tuple = reinterpret_cast<const t_tuple&>(data);
context h;
return insert(tuple, h);
}
bool insert(RamDomain a0,RamDomain a1,RamDomain a2,RamDomain a3,RamDomain a4) {
RamDomain data[5] = {a0,a1,a2,a3,a4};
return insert(data);
}
template <typename T>
void insertAll(T& other) {
for (auto const& cur : other) {
insert(cur);
}
}
void insertAll(t_btree_5__0_1_2_3_4__31& other) {
ind_0.insertAll(other.ind_0);
}
bool contains(const t_tuple& t, context& h) const {
return ind_0.contains(t, h.hints_0);
}
bool contains(const t_tuple& t) const {
context h;
return contains(t, h);
}
std::size_t size() const {
return ind_0.size();
}
iterator find(const t_tuple& t, context& h) const {
return ind_0.find(t, h.hints_0);
}
iterator find(const t_tuple& t) const {
context h;
return find(t, h);
}
range<iterator> equalRange_0(const t_tuple& t, context& h) const {
return range<iterator>(ind_0.begin(),ind_0.end());
}
range<iterator> equalRange_0(const t_tuple& t) const {
return range<iterator>(ind_0.begin(),ind_0.end());
}
range<t_ind_0::iterator> equalRange_31(const t_tuple& t, context& h) const {
auto pos = ind_0.find(t, h.hints_0);
auto fin = ind_0.end();
if (pos != fin) {fin = pos; ++fin;}
return make_range(pos, fin);
}
range<t_ind_0::iterator> equalRange_31(const t_tuple& t) const {
context h;
return equalRange_31(t, h);
}
bool empty() const {
return ind_0.empty();
}
std::vector<range<iterator>> partition() const {
return ind_0.getChunks(400);
}
void purge() {
ind_0.clear();
}
iterator begin() const {
return ind_0.begin();
}
iterator end() const {
return ind_0.end();
}
void printHintStatistics(std::ostream& o, const std::string prefix) const {
const auto& stats_0 = ind_0.getHintStatistics();
o << prefix << "arity 5 direct b-tree index [0,1,2,3,4]: (hits/misses/total)\n";
o << prefix << "Insert: " << stats_0.inserts.getHits() << "/" << stats_0.inserts.getMisses() << "/" << stats_0.inserts.getAccesses() << "\n";
o << prefix << "Contains: " << stats_0.contains.getHits() << "/" << stats_0.contains.getMisses() << "/" << stats_0.contains.getAccesses() << "\n";
o << prefix << "Lower-bound: " << stats_0.lower_bound.getHits() << "/" << stats_0.lower_bound.getMisses() << "/" << stats_0.lower_bound.getAccesses() << "\n";
o << prefix << "Upper-bound: " << stats_0.upper_bound.getHits() << "/" << stats_0.upper_bound.getMisses() << "/" << stats_0.upper_bound.getAccesses() << "\n";
}
};
struct t_btree_6__0_1_2_3_4_5__63 {
using t_tuple = Tuple<RamDomain, 6>;
using t_ind_0 = btree_set<t_tuple, index_utils::comparator<0,1,2,3,4,5>>;
t_ind_0 ind_0;
using iterator = t_ind_0::iterator;
struct context {
t_ind_0::operation_hints hints_0;
};
context createContext() { return context(); }
bool insert(const t_tuple& t) {
context h;
return insert(t, h);
}
bool insert(const t_tuple& t, context& h) {
if (ind_0.insert(t, h.hints_0)) {
return true;
} else return false;
}
bool insert(const RamDomain* ramDomain) {
RamDomain data[6];
std::copy(ramDomain, ramDomain + 6, data);
const t_tuple& tuple = reinterpret_cast<const t_tuple&>(data);
context h;
return insert(tuple, h);
}
bool insert(RamDomain a0,RamDomain a1,RamDomain a2,RamDomain a3,RamDomain a4,RamDomain a5) {
RamDomain data[6] = {a0,a1,a2,a3,a4,a5};
return insert(data);
}
template <typename T>
void insertAll(T& other) {
for (auto const& cur : other) {
insert(cur);
}
}
void insertAll(t_btree_6__0_1_2_3_4_5__63& other) {
ind_0.insertAll(other.ind_0);
}
bool contains(const t_tuple& t, context& h) const {
return ind_0.contains(t, h.hints_0);
}
bool contains(const t_tuple& t) const {
context h;
return contains(t, h);
}
std::size_t size() const {
return ind_0.size();
}
iterator find(const t_tuple& t, context& h) const {
return ind_0.find(t, h.hints_0);
}
iterator find(const t_tuple& t) const {
context h;
return find(t, h);
}
range<iterator> equalRange_0(const t_tuple& t, context& h) const {
return range<iterator>(ind_0.begin(),ind_0.end());
}
range<iterator> equalRange_0(const t_tuple& t) const {
return range<iterator>(ind_0.begin(),ind_0.end());
}
range<t_ind_0::iterator> equalRange_63(const t_tuple& t, context& h) const {
auto pos = ind_0.find(t, h.hints_0);
auto fin = ind_0.end();
if (pos != fin) {fin = pos; ++fin;}
return make_range(pos, fin);
}
range<t_ind_0::iterator> equalRange_63(const t_tuple& t) const {
context h;
return equalRange_63(t, h);
}
bool empty() const {
return ind_0.empty();
}
std::vector<range<iterator>> partition() const {
return ind_0.getChunks(400);
}
void purge() {
ind_0.clear();
}
iterator begin() const {
return ind_0.begin();
}
iterator end() const {
return ind_0.end();
}
void printHintStatistics(std::ostream& o, const std::string prefix) const {
const auto& stats_0 = ind_0.getHintStatistics();
o << prefix << "arity 6 direct b-tree index [0,1,2,3,4,5]: (hits/misses/total)\n";
o << prefix << "Insert: " << stats_0.inserts.getHits() << "/" << stats_0.inserts.getMisses() << "/" << stats_0.inserts.getAccesses() << "\n";
o << prefix << "Contains: " << stats_0.contains.getHits() << "/" << stats_0.contains.getMisses() << "/" << stats_0.contains.getAccesses() << "\n";
o << prefix << "Lower-bound: " << stats_0.lower_bound.getHits() << "/" << stats_0.lower_bound.getMisses() << "/" << stats_0.lower_bound.getAccesses() << "\n";
o << prefix << "Upper-bound: " << stats_0.upper_bound.getHits() << "/" << stats_0.upper_bound.getMisses() << "/" << stats_0.upper_bound.getAccesses() << "\n";
}
};

class Sf_souffle_small : public SouffleProgram {
private:
static inline bool regex_wrapper(const std::string& pattern, const std::string& text) {
   bool result = false; 
   try { result = std::regex_match(text, std::regex(pattern)); } catch(...) { 
     std::cerr << "warning: wrong pattern provided for match(\"" << pattern << "\",\"" << text << "\").\n";
}
   return result;
}
private:
static inline std::string substr_wrapper(const std::string& str, size_t idx, size_t len) {
   std::string result; 
   try { result = str.substr(idx,len); } catch(...) { 
     std::cerr << "warning: wrong index position provided by substr(\"";
     std::cerr << str << "\"," << (int32_t)idx << "," << (int32_t)len << ") functor.\n";
   } return result;
}
private:
static inline RamDomain wrapper_tonumber(const std::string& str) {
   RamDomain result=0; 
   try { result = stord(str); } catch(...) { 
     std::cerr << "error: wrong string provided by to_number(\"";
     std::cerr << str << "\") functor.\n";
     raise(SIGFPE);
   } return result;
}
public:
// -- initialize symbol table --
SymbolTable symTable
{
	R"_(v0,v1)_",
	R"_(Rule)_",
	R"_(precededBy,v0,v1)_",
	R"_(author(v0,v1) :- 
   Rule(128),
   precededBy(v0,v1).)_",
	R"_(precededBy,v1,v0)_",
	R"_(author(v0,v1) :- 
   Rule(129),
   precededBy(v1,v0).)_",
	R"_(genre,v0,v1)_",
	R"_(author(v0,v1) :- 
   Rule(130),
   genre(v0,v1).)_",
	R"_(genre,v1,v0)_",
	R"_(author(v0,v1) :- 
   Rule(131),
   genre(v1,v0).)_",
	R"_(inv_0,v0,v1)_",
	R"_(author(v0,v1) :- 
   Rule(134),
   inv_0(v0,v1).)_",
	R"_(inv_0,v1,v0)_",
	R"_(author(v0,v1) :- 
   Rule(135),
   inv_0(v1,v0).)_",
	R"_(author,v1,v0)_",
	R"_(author(v0,v1) :- 
   Rule(137),
   author(v1,v0).)_",
	R"_(author(v0,v1) :- 
   Rule(138),
   precededBy(v0,v1).)_",
	R"_(author(v0,v1) :- 
   Rule(139),
   precededBy(v0,v1),
   precededBy(v1,v0).)_",
	R"_(author(v0,v1) :- 
   Rule(140),
   precededBy(v1,v0).)_",
	R"_(author(v0,v1) :- 
   Rule(141),
   precededBy(v1,v0),
   precededBy(v0,v1).)_",
	R"_(precededBy,v2,v1)_",
	R"_(precededBy,v0,v2)_",
	R"_(author(v0,v1) :- 
   Rule(142),
   precededBy(v2,v1),
   precededBy(v0,v2).)_",
	R"_(precededBy,v1,v2)_",
	R"_(precededBy,v2,v0)_",
	R"_(author(v0,v1) :- 
   Rule(143),
   precededBy(v1,v2),
   precededBy(v2,v0).)_",
	R"_(author(v0,v1) :- 
   Rule(144),
   precededBy(v2,v0),
   precededBy(v1,v2).)_",
	R"_(author(v0,v1) :- 
   Rule(145),
   precededBy(v2,v0),
   precededBy(v2,v1).)_",
	R"_(author(v0,v1) :- 
   Rule(146),
   precededBy(v0,v2),
   precededBy(v1,v2).)_",
	R"_(author(v0,v1) :- 
   Rule(147),
   precededBy(v0,v2),
   precededBy(v2,v1).)_",
	R"_(author(v0,v1) :- 
   Rule(148),
   precededBy(v2,v1),
   precededBy(v2,v0).)_",
	R"_(author(v0,v1) :- 
   Rule(149),
   precededBy(v1,v2),
   precededBy(v0,v2).)_",
	R"_(author(v0,v1) :- 
   Rule(150),
   precededBy(v0,v1),
   genre(v0,v1).)_",
	R"_(author(v0,v1) :- 
   Rule(151),
   precededBy(v0,v1),
   genre(v1,v0).)_",
	R"_(author(v0,v1) :- 
   Rule(152),
   precededBy(v1,v0),
   genre(v1,v0).)_",
	R"_(author(v0,v1) :- 
   Rule(153),
   precededBy(v1,v0),
   genre(v0,v1).)_",
	R"_(genre,v0,v2)_",
	R"_(author(v0,v1) :- 
   Rule(154),
   precededBy(v2,v1),
   genre(v0,v2).)_",
	R"_(genre,v2,v0)_",
	R"_(author(v0,v1) :- 
   Rule(155),
   precededBy(v1,v2),
   genre(v2,v0).)_",
	R"_(genre,v1,v2)_",
	R"_(author(v0,v1) :- 
   Rule(156),
   precededBy(v2,v0),
   genre(v1,v2).)_",
	R"_(genre,v2,v1)_",
	R"_(author(v0,v1) :- 
   Rule(157),
   precededBy(v2,v0),
   genre(v2,v1).)_",
	R"_(author(v0,v1) :- 
   Rule(158),
   precededBy(v0,v2),
   genre(v1,v2).)_",
	R"_(author(v0,v1) :- 
   Rule(159),
   precededBy(v0,v2),
   genre(v2,v1).)_",
	R"_(author(v0,v1) :- 
   Rule(160),
   precededBy(v2,v1),
   genre(v2,v0).)_",
	R"_(author(v0,v1) :- 
   Rule(161),
   precededBy(v1,v2),
   genre(v0,v2).)_",
	R"_(Iauthor,v0,v2)_",
	R"_(author(v0,v1) :- 
   Rule(166),
   precededBy(v2,v1),
   Iauthor(v0,v2).)_",
	R"_(Iauthor,v2,v0)_",
	R"_(author(v0,v1) :- 
   Rule(167),
   precededBy(v1,v2),
   Iauthor(v2,v0).)_",
	R"_(Iauthor,v1,v2)_",
	R"_(author(v0,v1) :- 
   Rule(168),
   precededBy(v2,v0),
   Iauthor(v1,v2).)_",
	R"_(Iauthor,v2,v1)_",
	R"_(author(v0,v1) :- 
   Rule(169),
   precededBy(v2,v0),
   Iauthor(v2,v1).)_",
	R"_(author(v0,v1) :- 
   Rule(170),
   precededBy(v0,v2),
   Iauthor(v1,v2).)_",
	R"_(author(v0,v1) :- 
   Rule(171),
   precededBy(v0,v2),
   Iauthor(v2,v1).)_",
	R"_(author(v0,v1) :- 
   Rule(172),
   precededBy(v2,v1),
   Iauthor(v2,v0).)_",
	R"_(author(v0,v1) :- 
   Rule(173),
   precededBy(v1,v2),
   Iauthor(v0,v2).)_",
	R"_(author(v0,v1) :- 
   Rule(174),
   precededBy(v0,v1),
   inv_0(v0,v1).)_",
	R"_(author(v0,v1) :- 
   Rule(175),
   precededBy(v0,v1),
   inv_0(v1,v0).)_",
	R"_(author(v0,v1) :- 
   Rule(176),
   precededBy(v1,v0),
   inv_0(v1,v0).)_",
	R"_(author(v0,v1) :- 
   Rule(177),
   precededBy(v1,v0),
   inv_0(v0,v1).)_",
	R"_(inv_0,v0,v2)_",
	R"_(author(v0,v1) :- 
   Rule(178),
   precededBy(v2,v1),
   inv_0(v0,v2).)_",
	R"_(inv_0,v2,v0)_",
	R"_(author(v0,v1) :- 
   Rule(179),
   precededBy(v1,v2),
   inv_0(v2,v0).)_",
	R"_(inv_0,v1,v2)_",
	R"_(author(v0,v1) :- 
   Rule(180),
   precededBy(v2,v0),
   inv_0(v1,v2).)_",
	R"_(inv_0,v2,v1)_",
	R"_(author(v0,v1) :- 
   Rule(181),
   precededBy(v2,v0),
   inv_0(v2,v1).)_",
	R"_(author(v0,v1) :- 
   Rule(182),
   precededBy(v0,v2),
   inv_0(v1,v2).)_",
	R"_(author(v0,v1) :- 
   Rule(183),
   precededBy(v0,v2),
   inv_0(v2,v1).)_",
	R"_(author(v0,v1) :- 
   Rule(184),
   precededBy(v2,v1),
   inv_0(v2,v0).)_",
	R"_(author(v0,v1) :- 
   Rule(185),
   precededBy(v1,v2),
   inv_0(v0,v2).)_",
	R"_(author(v0,v1) :- 
   Rule(187),
   precededBy(v0,v1),
   author(v1,v0).)_",
	R"_(author(v0,v1) :- 
   Rule(188),
   precededBy(v1,v0),
   author(v1,v0).)_",
	R"_(author,v0,v2)_",
	R"_(author(v0,v1) :- 
   Rule(190),
   precededBy(v2,v1),
   author(v0,v2).)_",
	R"_(author,v2,v0)_",
	R"_(author(v0,v1) :- 
   Rule(191),
   precededBy(v1,v2),
   author(v2,v0).)_",
	R"_(author,v1,v2)_",
	R"_(author(v0,v1) :- 
   Rule(192),
   precededBy(v2,v0),
   author(v1,v2).)_",
	R"_(author,v2,v1)_",
	R"_(author(v0,v1) :- 
   Rule(193),
   precededBy(v2,v0),
   author(v2,v1).)_",
	R"_(author(v0,v1) :- 
   Rule(194),
   precededBy(v0,v2),
   author(v1,v2).)_",
	R"_(author(v0,v1) :- 
   Rule(195),
   precededBy(v0,v2),
   author(v2,v1).)_",
	R"_(author(v0,v1) :- 
   Rule(196),
   precededBy(v2,v1),
   author(v2,v0).)_",
	R"_(author(v0,v1) :- 
   Rule(197),
   precededBy(v1,v2),
   author(v0,v2).)_",
	R"_(author(v0,v1) :- 
   Rule(198),
   genre(v0,v1).)_",
	R"_(author(v0,v1) :- 
   Rule(199),
   genre(v0,v1),
   genre(v1,v0).)_",
	R"_(author(v0,v1) :- 
   Rule(200),
   genre(v1,v0).)_",
	R"_(author(v0,v1) :- 
   Rule(201),
   genre(v1,v0),
   genre(v0,v1).)_",
	R"_(author(v0,v1) :- 
   Rule(202),
   genre(v2,v1),
   genre(v0,v2).)_",
	R"_(author(v0,v1) :- 
   Rule(203),
   genre(v1,v2),
   genre(v2,v0).)_",
	R"_(author(v0,v1) :- 
   Rule(204),
   genre(v2,v0),
   genre(v1,v2).)_",
	R"_(author(v0,v1) :- 
   Rule(205),
   genre(v2,v0),
   genre(v2,v1).)_",
	R"_(author(v0,v1) :- 
   Rule(206),
   genre(v0,v2),
   genre(v1,v2).)_",
	R"_(author(v0,v1) :- 
   Rule(207),
   genre(v0,v2),
   genre(v2,v1).)_",
	R"_(author(v0,v1) :- 
   Rule(208),
   genre(v2,v1),
   genre(v2,v0).)_",
	R"_(author(v0,v1) :- 
   Rule(209),
   genre(v1,v2),
   genre(v0,v2).)_",
	R"_(author(v0,v1) :- 
   Rule(214),
   genre(v2,v1),
   Iauthor(v0,v2).)_",
	R"_(author(v0,v1) :- 
   Rule(215),
   genre(v1,v2),
   Iauthor(v2,v0).)_",
	R"_(author(v0,v1) :- 
   Rule(216),
   genre(v2,v0),
   Iauthor(v1,v2).)_",
	R"_(author(v0,v1) :- 
   Rule(217),
   genre(v2,v0),
   Iauthor(v2,v1).)_",
	R"_(author(v0,v1) :- 
   Rule(218),
   genre(v0,v2),
   Iauthor(v1,v2).)_",
	R"_(author(v0,v1) :- 
   Rule(219),
   genre(v0,v2),
   Iauthor(v2,v1).)_",
	R"_(author(v0,v1) :- 
   Rule(220),
   genre(v2,v1),
   Iauthor(v2,v0).)_",
	R"_(author(v0,v1) :- 
   Rule(221),
   genre(v1,v2),
   Iauthor(v0,v2).)_",
	R"_(author(v0,v1) :- 
   Rule(222),
   genre(v0,v1),
   inv_0(v0,v1).)_",
	R"_(author(v0,v1) :- 
   Rule(223),
   genre(v0,v1),
   inv_0(v1,v0).)_",
	R"_(author(v0,v1) :- 
   Rule(224),
   genre(v1,v0),
   inv_0(v1,v0).)_",
	R"_(author(v0,v1) :- 
   Rule(225),
   genre(v1,v0),
   inv_0(v0,v1).)_",
	R"_(author(v0,v1) :- 
   Rule(226),
   genre(v2,v1),
   inv_0(v0,v2).)_",
	R"_(author(v0,v1) :- 
   Rule(227),
   genre(v1,v2),
   inv_0(v2,v0).)_",
	R"_(author(v0,v1) :- 
   Rule(228),
   genre(v2,v0),
   inv_0(v1,v2).)_",
	R"_(author(v0,v1) :- 
   Rule(229),
   genre(v2,v0),
   inv_0(v2,v1).)_",
	R"_(author(v0,v1) :- 
   Rule(230),
   genre(v0,v2),
   inv_0(v1,v2).)_",
	R"_(author(v0,v1) :- 
   Rule(231),
   genre(v0,v2),
   inv_0(v2,v1).)_",
	R"_(author(v0,v1) :- 
   Rule(232),
   genre(v2,v1),
   inv_0(v2,v0).)_",
	R"_(author(v0,v1) :- 
   Rule(233),
   genre(v1,v2),
   inv_0(v0,v2).)_",
	R"_(author(v0,v1) :- 
   Rule(235),
   genre(v0,v1),
   author(v1,v0).)_",
	R"_(author(v0,v1) :- 
   Rule(236),
   genre(v1,v0),
   author(v1,v0).)_",
	R"_(author(v0,v1) :- 
   Rule(238),
   genre(v2,v1),
   author(v0,v2).)_",
	R"_(author(v0,v1) :- 
   Rule(239),
   genre(v1,v2),
   author(v2,v0).)_",
	R"_(author(v0,v1) :- 
   Rule(240),
   genre(v2,v0),
   author(v1,v2).)_",
	R"_(author(v0,v1) :- 
   Rule(241),
   genre(v2,v0),
   author(v2,v1).)_",
	R"_(author(v0,v1) :- 
   Rule(242),
   genre(v0,v2),
   author(v1,v2).)_",
	R"_(author(v0,v1) :- 
   Rule(243),
   genre(v0,v2),
   author(v2,v1).)_",
	R"_(author(v0,v1) :- 
   Rule(244),
   genre(v2,v1),
   author(v2,v0).)_",
	R"_(author(v0,v1) :- 
   Rule(245),
   genre(v1,v2),
   author(v0,v2).)_",
	R"_(author(v0,v1) :- 
   Rule(250),
   Iauthor(v2,v1),
   Iauthor(v0,v2).)_",
	R"_(author(v0,v1) :- 
   Rule(251),
   Iauthor(v1,v2),
   Iauthor(v2,v0).)_",
	R"_(author(v0,v1) :- 
   Rule(252),
   Iauthor(v2,v0),
   Iauthor(v1,v2).)_",
	R"_(author(v0,v1) :- 
   Rule(253),
   Iauthor(v2,v0),
   Iauthor(v2,v1).)_",
	R"_(author(v0,v1) :- 
   Rule(254),
   Iauthor(v0,v2),
   Iauthor(v1,v2).)_",
	R"_(author(v0,v1) :- 
   Rule(255),
   Iauthor(v0,v2),
   Iauthor(v2,v1).)_",
	R"_(author(v0,v1) :- 
   Rule(256),
   Iauthor(v2,v1),
   Iauthor(v2,v0).)_",
	R"_(author(v0,v1) :- 
   Rule(257),
   Iauthor(v1,v2),
   Iauthor(v0,v2).)_",
	R"_(author(v0,v1) :- 
   Rule(274),
   Iauthor(v2,v1),
   author(v0,v2).)_",
	R"_(author(v0,v1) :- 
   Rule(275),
   Iauthor(v1,v2),
   author(v2,v0).)_",
	R"_(author(v0,v1) :- 
   Rule(276),
   Iauthor(v2,v0),
   author(v1,v2).)_",
	R"_(author(v0,v1) :- 
   Rule(277),
   Iauthor(v2,v0),
   author(v2,v1).)_",
	R"_(author(v0,v1) :- 
   Rule(278),
   Iauthor(v0,v2),
   author(v1,v2).)_",
	R"_(author(v0,v1) :- 
   Rule(279),
   Iauthor(v0,v2),
   author(v2,v1).)_",
	R"_(author(v0,v1) :- 
   Rule(280),
   Iauthor(v2,v1),
   author(v2,v0).)_",
	R"_(author(v0,v1) :- 
   Rule(281),
   Iauthor(v1,v2),
   author(v0,v2).)_",
	R"_(author(v0,v1) :- 
   Rule(282),
   inv_0(v0,v1).)_",
	R"_(author(v0,v1) :- 
   Rule(283),
   inv_0(v0,v1),
   inv_0(v1,v0).)_",
	R"_(author(v0,v1) :- 
   Rule(284),
   inv_0(v1,v0).)_",
	R"_(author(v0,v1) :- 
   Rule(285),
   inv_0(v1,v0),
   inv_0(v0,v1).)_",
	R"_(author(v0,v1) :- 
   Rule(286),
   inv_0(v2,v1),
   inv_0(v0,v2).)_",
	R"_(author(v0,v1) :- 
   Rule(287),
   inv_0(v1,v2),
   inv_0(v2,v0).)_",
	R"_(author(v0,v1) :- 
   Rule(288),
   inv_0(v2,v0),
   inv_0(v1,v2).)_",
	R"_(author(v0,v1) :- 
   Rule(289),
   inv_0(v2,v0),
   inv_0(v2,v1).)_",
	R"_(author(v0,v1) :- 
   Rule(290),
   inv_0(v0,v2),
   inv_0(v1,v2).)_",
	R"_(author(v0,v1) :- 
   Rule(291),
   inv_0(v0,v2),
   inv_0(v2,v1).)_",
	R"_(author(v0,v1) :- 
   Rule(292),
   inv_0(v2,v1),
   inv_0(v2,v0).)_",
	R"_(author(v0,v1) :- 
   Rule(293),
   inv_0(v1,v2),
   inv_0(v0,v2).)_",
	R"_(author(v0,v1) :- 
   Rule(295),
   inv_0(v0,v1),
   author(v1,v0).)_",
	R"_(author(v0,v1) :- 
   Rule(296),
   inv_0(v1,v0),
   author(v1,v0).)_",
	R"_(author(v0,v1) :- 
   Rule(298),
   inv_0(v2,v1),
   author(v0,v2).)_",
	R"_(author(v0,v1) :- 
   Rule(299),
   inv_0(v1,v2),
   author(v2,v0).)_",
	R"_(author(v0,v1) :- 
   Rule(300),
   inv_0(v2,v0),
   author(v1,v2).)_",
	R"_(author(v0,v1) :- 
   Rule(301),
   inv_0(v2,v0),
   author(v2,v1).)_",
	R"_(author(v0,v1) :- 
   Rule(302),
   inv_0(v0,v2),
   author(v1,v2).)_",
	R"_(author(v0,v1) :- 
   Rule(303),
   inv_0(v0,v2),
   author(v2,v1).)_",
	R"_(author(v0,v1) :- 
   Rule(304),
   inv_0(v2,v1),
   author(v2,v0).)_",
	R"_(author(v0,v1) :- 
   Rule(305),
   inv_0(v1,v2),
   author(v0,v2).)_",
	R"_(author(v0,v1) :- 
   Rule(308),
   author(v1,v0).)_",
	R"_(author(v0,v1) :- 
   Rule(310),
   author(v2,v1),
   author(v0,v2).)_",
	R"_(author(v0,v1) :- 
   Rule(311),
   author(v1,v2),
   author(v2,v0).)_",
	R"_(author(v0,v1) :- 
   Rule(312),
   author(v2,v0),
   author(v1,v2).)_",
	R"_(author(v0,v1) :- 
   Rule(313),
   author(v2,v0),
   author(v2,v1).)_",
	R"_(author(v0,v1) :- 
   Rule(314),
   author(v0,v2),
   author(v1,v2).)_",
	R"_(author(v0,v1) :- 
   Rule(315),
   author(v0,v2),
   author(v2,v1).)_",
	R"_(author(v0,v1) :- 
   Rule(316),
   author(v2,v1),
   author(v2,v0).)_",
	R"_(author(v0,v1) :- 
   Rule(317),
   author(v1,v2),
   author(v0,v2).)_",
	R"_(inv_0(v0,v1) :- 
   Rule(0),
   precededBy(v0,v1).)_",
	R"_(inv_0(v0,v1) :- 
   Rule(1),
   precededBy(v1,v0).)_",
	R"_(inv_0(v0,v1) :- 
   Rule(2),
   genre(v0,v1).)_",
	R"_(inv_0(v0,v1) :- 
   Rule(3),
   genre(v1,v0).)_",
	R"_(inv_0(v0,v1) :- 
   Rule(7),
   inv_0(v1,v0).)_",
	R"_(inv_0(v0,v1) :- 
   Rule(8),
   precededBy(v0,v1).)_",
	R"_(inv_0(v0,v1) :- 
   Rule(9),
   precededBy(v0,v1),
   precededBy(v1,v0).)_",
	R"_(inv_0(v0,v1) :- 
   Rule(10),
   precededBy(v1,v0).)_",
	R"_(inv_0(v0,v1) :- 
   Rule(11),
   precededBy(v1,v0),
   precededBy(v0,v1).)_",
	R"_(inv_0(v0,v1) :- 
   Rule(12),
   precededBy(v2,v1),
   precededBy(v0,v2).)_",
	R"_(inv_0(v0,v1) :- 
   Rule(13),
   precededBy(v1,v2),
   precededBy(v2,v0).)_",
	R"_(inv_0(v0,v1) :- 
   Rule(14),
   precededBy(v2,v0),
   precededBy(v1,v2).)_",
	R"_(inv_0(v0,v1) :- 
   Rule(15),
   precededBy(v2,v0),
   precededBy(v2,v1).)_",
	R"_(inv_0(v0,v1) :- 
   Rule(16),
   precededBy(v0,v2),
   precededBy(v1,v2).)_",
	R"_(inv_0(v0,v1) :- 
   Rule(17),
   precededBy(v0,v2),
   precededBy(v2,v1).)_",
	R"_(inv_0(v0,v1) :- 
   Rule(18),
   precededBy(v2,v1),
   precededBy(v2,v0).)_",
	R"_(inv_0(v0,v1) :- 
   Rule(19),
   precededBy(v1,v2),
   precededBy(v0,v2).)_",
	R"_(inv_0(v0,v1) :- 
   Rule(20),
   precededBy(v0,v1),
   genre(v0,v1).)_",
	R"_(inv_0(v0,v1) :- 
   Rule(21),
   precededBy(v0,v1),
   genre(v1,v0).)_",
	R"_(inv_0(v0,v1) :- 
   Rule(22),
   precededBy(v1,v0),
   genre(v1,v0).)_",
	R"_(inv_0(v0,v1) :- 
   Rule(23),
   precededBy(v1,v0),
   genre(v0,v1).)_",
	R"_(inv_0(v0,v1) :- 
   Rule(24),
   precededBy(v2,v1),
   genre(v0,v2).)_",
	R"_(inv_0(v0,v1) :- 
   Rule(25),
   precededBy(v1,v2),
   genre(v2,v0).)_",
	R"_(inv_0(v0,v1) :- 
   Rule(26),
   precededBy(v2,v0),
   genre(v1,v2).)_",
	R"_(inv_0(v0,v1) :- 
   Rule(27),
   precededBy(v2,v0),
   genre(v2,v1).)_",
	R"_(inv_0(v0,v1) :- 
   Rule(28),
   precededBy(v0,v2),
   genre(v1,v2).)_",
	R"_(inv_0(v0,v1) :- 
   Rule(29),
   precededBy(v0,v2),
   genre(v2,v1).)_",
	R"_(inv_0(v0,v1) :- 
   Rule(30),
   precededBy(v2,v1),
   genre(v2,v0).)_",
	R"_(inv_0(v0,v1) :- 
   Rule(31),
   precededBy(v1,v2),
   genre(v0,v2).)_",
	R"_(inv_0(v0,v1) :- 
   Rule(45),
   precededBy(v0,v1),
   inv_0(v1,v0).)_",
	R"_(inv_0(v0,v1) :- 
   Rule(46),
   precededBy(v1,v0),
   inv_0(v1,v0).)_",
	R"_(inv_0(v0,v1) :- 
   Rule(48),
   precededBy(v2,v1),
   inv_0(v0,v2).)_",
	R"_(inv_0(v0,v1) :- 
   Rule(49),
   precededBy(v1,v2),
   inv_0(v2,v0).)_",
	R"_(inv_0(v0,v1) :- 
   Rule(50),
   precededBy(v2,v0),
   inv_0(v1,v2).)_",
	R"_(inv_0(v0,v1) :- 
   Rule(51),
   precededBy(v2,v0),
   inv_0(v2,v1).)_",
	R"_(inv_0(v0,v1) :- 
   Rule(52),
   precededBy(v0,v2),
   inv_0(v1,v2).)_",
	R"_(inv_0(v0,v1) :- 
   Rule(53),
   precededBy(v0,v2),
   inv_0(v2,v1).)_",
	R"_(inv_0(v0,v1) :- 
   Rule(54),
   precededBy(v2,v1),
   inv_0(v2,v0).)_",
	R"_(inv_0(v0,v1) :- 
   Rule(55),
   precededBy(v1,v2),
   inv_0(v0,v2).)_",
	R"_(inv_0(v0,v1) :- 
   Rule(56),
   genre(v0,v1).)_",
	R"_(inv_0(v0,v1) :- 
   Rule(57),
   genre(v0,v1),
   genre(v1,v0).)_",
	R"_(inv_0(v0,v1) :- 
   Rule(58),
   genre(v1,v0).)_",
	R"_(inv_0(v0,v1) :- 
   Rule(59),
   genre(v1,v0),
   genre(v0,v1).)_",
	R"_(inv_0(v0,v1) :- 
   Rule(60),
   genre(v2,v1),
   genre(v0,v2).)_",
	R"_(inv_0(v0,v1) :- 
   Rule(61),
   genre(v1,v2),
   genre(v2,v0).)_",
	R"_(inv_0(v0,v1) :- 
   Rule(62),
   genre(v2,v0),
   genre(v1,v2).)_",
	R"_(inv_0(v0,v1) :- 
   Rule(63),
   genre(v2,v0),
   genre(v2,v1).)_",
	R"_(inv_0(v0,v1) :- 
   Rule(64),
   genre(v0,v2),
   genre(v1,v2).)_",
	R"_(inv_0(v0,v1) :- 
   Rule(65),
   genre(v0,v2),
   genre(v2,v1).)_",
	R"_(inv_0(v0,v1) :- 
   Rule(66),
   genre(v2,v1),
   genre(v2,v0).)_",
	R"_(inv_0(v0,v1) :- 
   Rule(67),
   genre(v1,v2),
   genre(v0,v2).)_",
	R"_(inv_0(v0,v1) :- 
   Rule(81),
   genre(v0,v1),
   inv_0(v1,v0).)_",
	R"_(inv_0(v0,v1) :- 
   Rule(82),
   genre(v1,v0),
   inv_0(v1,v0).)_",
	R"_(inv_0(v0,v1) :- 
   Rule(84),
   genre(v2,v1),
   inv_0(v0,v2).)_",
	R"_(inv_0(v0,v1) :- 
   Rule(85),
   genre(v1,v2),
   inv_0(v2,v0).)_",
	R"_(inv_0(v0,v1) :- 
   Rule(86),
   genre(v2,v0),
   inv_0(v1,v2).)_",
	R"_(inv_0(v0,v1) :- 
   Rule(87),
   genre(v2,v0),
   inv_0(v2,v1).)_",
	R"_(inv_0(v0,v1) :- 
   Rule(88),
   genre(v0,v2),
   inv_0(v1,v2).)_",
	R"_(inv_0(v0,v1) :- 
   Rule(89),
   genre(v0,v2),
   inv_0(v2,v1).)_",
	R"_(inv_0(v0,v1) :- 
   Rule(90),
   genre(v2,v1),
   inv_0(v2,v0).)_",
	R"_(inv_0(v0,v1) :- 
   Rule(91),
   genre(v1,v2),
   inv_0(v0,v2).)_",
	R"_(inv_0(v0,v1) :- 
   Rule(118),
   inv_0(v1,v0).)_",
	R"_(inv_0(v0,v1) :- 
   Rule(120),
   inv_0(v2,v1),
   inv_0(v0,v2).)_",
	R"_(inv_0(v0,v1) :- 
   Rule(121),
   inv_0(v1,v2),
   inv_0(v2,v0).)_",
	R"_(inv_0(v0,v1) :- 
   Rule(122),
   inv_0(v2,v0),
   inv_0(v1,v2).)_",
	R"_(inv_0(v0,v1) :- 
   Rule(123),
   inv_0(v2,v0),
   inv_0(v2,v1).)_",
	R"_(inv_0(v0,v1) :- 
   Rule(124),
   inv_0(v0,v2),
   inv_0(v1,v2).)_",
	R"_(inv_0(v0,v1) :- 
   Rule(125),
   inv_0(v0,v2),
   inv_0(v2,v1).)_",
	R"_(inv_0(v0,v1) :- 
   Rule(126),
   inv_0(v2,v1),
   inv_0(v2,v0).)_",
	R"_(inv_0(v0,v1) :- 
   Rule(127),
   inv_0(v1,v2),
   inv_0(v0,v2).)_",
};// -- Table: Iauthor
std::unique_ptr<t_btree_4__0_1_3_2__1_0_2_3__1__2__3__15> rel_1_Iauthor = std::make_unique<t_btree_4__0_1_3_2__1_0_2_3__1__2__3__15>();
souffle::RelationWrapper<0,t_btree_4__0_1_3_2__1_0_2_3__1__2__3__15,Tuple<RamDomain,4>,4> wrapper_rel_1_Iauthor;
// -- Table: Rule
std::unique_ptr<t_btree_3__0_1_2__1__7> rel_2_Rule = std::make_unique<t_btree_3__0_1_2__1__7>();
souffle::RelationWrapper<1,t_btree_3__0_1_2__1__7,Tuple<RamDomain,3>,3> wrapper_rel_2_Rule;
// -- Table: genre
std::unique_ptr<t_btree_4__0_1_3_2__1_0_2_3__1__2__3__15> rel_3_genre = std::make_unique<t_btree_4__0_1_3_2__1_0_2_3__1__2__3__15>();
souffle::RelationWrapper<2,t_btree_4__0_1_3_2__1_0_2_3__1__2__3__15,Tuple<RamDomain,4>,4> wrapper_rel_3_genre;
// -- Table: precededBy
std::unique_ptr<t_btree_4__0_1_3_2__1_0_2_3__1__2__3__15> rel_4_precededBy = std::make_unique<t_btree_4__0_1_3_2__1_0_2_3__1__2__3__15>();
souffle::RelationWrapper<3,t_btree_4__0_1_3_2__1_0_2_3__1__2__3__15,Tuple<RamDomain,4>,4> wrapper_rel_4_precededBy;
// -- Table: inv_0
std::unique_ptr<t_btree_4__0_1_3_2__1_0_2_3__1__2__3__15> rel_5_inv_0 = std::make_unique<t_btree_4__0_1_3_2__1_0_2_3__1__2__3__15>();
souffle::RelationWrapper<4,t_btree_4__0_1_3_2__1_0_2_3__1__2__3__15,Tuple<RamDomain,4>,4> wrapper_rel_5_inv_0;
// -- Table: @delta_inv_0
std::unique_ptr<t_btree_4__0_1_3_2__1_0_2_3__1__2__3__15> rel_6_delta_inv_0 = std::make_unique<t_btree_4__0_1_3_2__1_0_2_3__1__2__3__15>();
// -- Table: @new_inv_0
std::unique_ptr<t_btree_4__0_1_3_2__1_0_2_3__1__2__3__15> rel_7_new_inv_0 = std::make_unique<t_btree_4__0_1_3_2__1_0_2_3__1__2__3__15>();
// -- Table: author
std::unique_ptr<t_btree_4__0_1_3_2__1_0_2_3__1__2__3__15> rel_8_author = std::make_unique<t_btree_4__0_1_3_2__1_0_2_3__1__2__3__15>();
souffle::RelationWrapper<5,t_btree_4__0_1_3_2__1_0_2_3__1__2__3__15,Tuple<RamDomain,4>,4> wrapper_rel_8_author;
// -- Table: @delta_author
std::unique_ptr<t_btree_4__0_1_3_2__1_0_2_3__1__2__3__15> rel_9_delta_author = std::make_unique<t_btree_4__0_1_3_2__1_0_2_3__1__2__3__15>();
// -- Table: @new_author
std::unique_ptr<t_btree_4__0_1_3_2__1_0_2_3__1__2__3__15> rel_10_new_author = std::make_unique<t_btree_4__0_1_3_2__1_0_2_3__1__2__3__15>();
// -- Table: author.@info.1
std::unique_ptr<t_btree_5__0_1_2_3_4__31> rel_11_author_info_1 = std::make_unique<t_btree_5__0_1_2_3_4__31>();
souffle::RelationWrapper<6,t_btree_5__0_1_2_3_4__31,Tuple<RamDomain,5>,5> wrapper_rel_11_author_info_1;
// -- Table: author.@info.10
std::unique_ptr<t_btree_5__0_1_2_3_4__31> rel_12_author_info_10 = std::make_unique<t_btree_5__0_1_2_3_4__31>();
souffle::RelationWrapper<7,t_btree_5__0_1_2_3_4__31,Tuple<RamDomain,5>,5> wrapper_rel_12_author_info_10;
// -- Table: author.@info.100
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_13_author_info_100 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<8,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_13_author_info_100;
// -- Table: author.@info.101
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_14_author_info_101 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<9,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_14_author_info_101;
// -- Table: author.@info.102
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_15_author_info_102 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<10,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_15_author_info_102;
// -- Table: author.@info.103
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_16_author_info_103 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<11,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_16_author_info_103;
// -- Table: author.@info.104
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_17_author_info_104 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<12,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_17_author_info_104;
// -- Table: author.@info.105
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_18_author_info_105 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<13,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_18_author_info_105;
// -- Table: author.@info.106
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_19_author_info_106 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<14,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_19_author_info_106;
// -- Table: author.@info.107
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_20_author_info_107 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<15,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_20_author_info_107;
// -- Table: author.@info.108
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_21_author_info_108 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<16,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_21_author_info_108;
// -- Table: author.@info.109
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_22_author_info_109 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<17,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_22_author_info_109;
// -- Table: author.@info.11
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_23_author_info_11 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<18,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_23_author_info_11;
// -- Table: author.@info.110
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_24_author_info_110 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<19,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_24_author_info_110;
// -- Table: author.@info.111
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_25_author_info_111 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<20,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_25_author_info_111;
// -- Table: author.@info.112
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_26_author_info_112 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<21,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_26_author_info_112;
// -- Table: author.@info.113
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_27_author_info_113 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<22,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_27_author_info_113;
// -- Table: author.@info.114
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_28_author_info_114 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<23,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_28_author_info_114;
// -- Table: author.@info.115
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_29_author_info_115 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<24,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_29_author_info_115;
// -- Table: author.@info.116
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_30_author_info_116 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<25,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_30_author_info_116;
// -- Table: author.@info.117
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_31_author_info_117 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<26,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_31_author_info_117;
// -- Table: author.@info.118
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_32_author_info_118 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<27,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_32_author_info_118;
// -- Table: author.@info.119
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_33_author_info_119 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<28,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_33_author_info_119;
// -- Table: author.@info.12
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_34_author_info_12 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<29,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_34_author_info_12;
// -- Table: author.@info.120
std::unique_ptr<t_btree_5__0_1_2_3_4__31> rel_35_author_info_120 = std::make_unique<t_btree_5__0_1_2_3_4__31>();
souffle::RelationWrapper<30,t_btree_5__0_1_2_3_4__31,Tuple<RamDomain,5>,5> wrapper_rel_35_author_info_120;
// -- Table: author.@info.121
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_36_author_info_121 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<31,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_36_author_info_121;
// -- Table: author.@info.122
std::unique_ptr<t_btree_5__0_1_2_3_4__31> rel_37_author_info_122 = std::make_unique<t_btree_5__0_1_2_3_4__31>();
souffle::RelationWrapper<32,t_btree_5__0_1_2_3_4__31,Tuple<RamDomain,5>,5> wrapper_rel_37_author_info_122;
// -- Table: author.@info.123
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_38_author_info_123 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<33,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_38_author_info_123;
// -- Table: author.@info.124
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_39_author_info_124 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<34,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_39_author_info_124;
// -- Table: author.@info.125
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_40_author_info_125 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<35,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_40_author_info_125;
// -- Table: author.@info.126
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_41_author_info_126 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<36,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_41_author_info_126;
// -- Table: author.@info.127
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_42_author_info_127 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<37,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_42_author_info_127;
// -- Table: author.@info.128
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_43_author_info_128 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<38,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_43_author_info_128;
// -- Table: author.@info.129
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_44_author_info_129 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<39,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_44_author_info_129;
// -- Table: author.@info.13
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_45_author_info_13 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<40,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_45_author_info_13;
// -- Table: author.@info.130
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_46_author_info_130 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<41,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_46_author_info_130;
// -- Table: author.@info.131
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_47_author_info_131 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<42,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_47_author_info_131;
// -- Table: author.@info.132
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_48_author_info_132 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<43,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_48_author_info_132;
// -- Table: author.@info.133
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_49_author_info_133 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<44,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_49_author_info_133;
// -- Table: author.@info.134
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_50_author_info_134 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<45,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_50_author_info_134;
// -- Table: author.@info.135
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_51_author_info_135 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<46,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_51_author_info_135;
// -- Table: author.@info.136
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_52_author_info_136 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<47,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_52_author_info_136;
// -- Table: author.@info.137
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_53_author_info_137 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<48,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_53_author_info_137;
// -- Table: author.@info.138
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_54_author_info_138 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<49,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_54_author_info_138;
// -- Table: author.@info.139
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_55_author_info_139 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<50,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_55_author_info_139;
// -- Table: author.@info.14
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_56_author_info_14 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<51,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_56_author_info_14;
// -- Table: author.@info.140
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_57_author_info_140 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<52,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_57_author_info_140;
// -- Table: author.@info.141
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_58_author_info_141 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<53,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_58_author_info_141;
// -- Table: author.@info.142
std::unique_ptr<t_btree_5__0_1_2_3_4__31> rel_59_author_info_142 = std::make_unique<t_btree_5__0_1_2_3_4__31>();
souffle::RelationWrapper<54,t_btree_5__0_1_2_3_4__31,Tuple<RamDomain,5>,5> wrapper_rel_59_author_info_142;
// -- Table: author.@info.143
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_60_author_info_143 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<55,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_60_author_info_143;
// -- Table: author.@info.144
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_61_author_info_144 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<56,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_61_author_info_144;
// -- Table: author.@info.145
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_62_author_info_145 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<57,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_62_author_info_145;
// -- Table: author.@info.146
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_63_author_info_146 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<58,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_63_author_info_146;
// -- Table: author.@info.147
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_64_author_info_147 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<59,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_64_author_info_147;
// -- Table: author.@info.148
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_65_author_info_148 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<60,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_65_author_info_148;
// -- Table: author.@info.149
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_66_author_info_149 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<61,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_66_author_info_149;
// -- Table: author.@info.15
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_67_author_info_15 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<62,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_67_author_info_15;
// -- Table: author.@info.150
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_68_author_info_150 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<63,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_68_author_info_150;
// -- Table: author.@info.16
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_69_author_info_16 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<64,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_69_author_info_16;
// -- Table: author.@info.17
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_70_author_info_17 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<65,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_70_author_info_17;
// -- Table: author.@info.18
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_71_author_info_18 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<66,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_71_author_info_18;
// -- Table: author.@info.19
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_72_author_info_19 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<67,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_72_author_info_19;
// -- Table: author.@info.2
std::unique_ptr<t_btree_5__0_1_2_3_4__31> rel_73_author_info_2 = std::make_unique<t_btree_5__0_1_2_3_4__31>();
souffle::RelationWrapper<68,t_btree_5__0_1_2_3_4__31,Tuple<RamDomain,5>,5> wrapper_rel_73_author_info_2;
// -- Table: author.@info.20
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_74_author_info_20 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<69,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_74_author_info_20;
// -- Table: author.@info.21
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_75_author_info_21 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<70,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_75_author_info_21;
// -- Table: author.@info.22
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_76_author_info_22 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<71,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_76_author_info_22;
// -- Table: author.@info.23
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_77_author_info_23 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<72,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_77_author_info_23;
// -- Table: author.@info.24
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_78_author_info_24 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<73,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_78_author_info_24;
// -- Table: author.@info.25
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_79_author_info_25 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<74,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_79_author_info_25;
// -- Table: author.@info.26
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_80_author_info_26 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<75,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_80_author_info_26;
// -- Table: author.@info.27
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_81_author_info_27 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<76,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_81_author_info_27;
// -- Table: author.@info.28
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_82_author_info_28 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<77,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_82_author_info_28;
// -- Table: author.@info.29
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_83_author_info_29 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<78,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_83_author_info_29;
// -- Table: author.@info.3
std::unique_ptr<t_btree_5__0_1_2_3_4__31> rel_84_author_info_3 = std::make_unique<t_btree_5__0_1_2_3_4__31>();
souffle::RelationWrapper<79,t_btree_5__0_1_2_3_4__31,Tuple<RamDomain,5>,5> wrapper_rel_84_author_info_3;
// -- Table: author.@info.30
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_85_author_info_30 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<80,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_85_author_info_30;
// -- Table: author.@info.31
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_86_author_info_31 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<81,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_86_author_info_31;
// -- Table: author.@info.32
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_87_author_info_32 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<82,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_87_author_info_32;
// -- Table: author.@info.33
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_88_author_info_33 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<83,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_88_author_info_33;
// -- Table: author.@info.34
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_89_author_info_34 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<84,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_89_author_info_34;
// -- Table: author.@info.35
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_90_author_info_35 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<85,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_90_author_info_35;
// -- Table: author.@info.36
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_91_author_info_36 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<86,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_91_author_info_36;
// -- Table: author.@info.37
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_92_author_info_37 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<87,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_92_author_info_37;
// -- Table: author.@info.38
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_93_author_info_38 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<88,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_93_author_info_38;
// -- Table: author.@info.39
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_94_author_info_39 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<89,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_94_author_info_39;
// -- Table: author.@info.4
std::unique_ptr<t_btree_5__0_1_2_3_4__31> rel_95_author_info_4 = std::make_unique<t_btree_5__0_1_2_3_4__31>();
souffle::RelationWrapper<90,t_btree_5__0_1_2_3_4__31,Tuple<RamDomain,5>,5> wrapper_rel_95_author_info_4;
// -- Table: author.@info.40
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_96_author_info_40 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<91,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_96_author_info_40;
// -- Table: author.@info.41
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_97_author_info_41 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<92,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_97_author_info_41;
// -- Table: author.@info.42
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_98_author_info_42 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<93,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_98_author_info_42;
// -- Table: author.@info.43
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_99_author_info_43 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<94,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_99_author_info_43;
// -- Table: author.@info.44
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_100_author_info_44 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<95,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_100_author_info_44;
// -- Table: author.@info.45
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_101_author_info_45 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<96,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_101_author_info_45;
// -- Table: author.@info.46
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_102_author_info_46 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<97,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_102_author_info_46;
// -- Table: author.@info.47
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_103_author_info_47 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<98,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_103_author_info_47;
// -- Table: author.@info.48
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_104_author_info_48 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<99,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_104_author_info_48;
// -- Table: author.@info.49
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_105_author_info_49 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<100,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_105_author_info_49;
// -- Table: author.@info.5
std::unique_ptr<t_btree_5__0_1_2_3_4__31> rel_106_author_info_5 = std::make_unique<t_btree_5__0_1_2_3_4__31>();
souffle::RelationWrapper<101,t_btree_5__0_1_2_3_4__31,Tuple<RamDomain,5>,5> wrapper_rel_106_author_info_5;
// -- Table: author.@info.50
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_107_author_info_50 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<102,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_107_author_info_50;
// -- Table: author.@info.51
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_108_author_info_51 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<103,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_108_author_info_51;
// -- Table: author.@info.52
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_109_author_info_52 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<104,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_109_author_info_52;
// -- Table: author.@info.53
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_110_author_info_53 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<105,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_110_author_info_53;
// -- Table: author.@info.54
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_111_author_info_54 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<106,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_111_author_info_54;
// -- Table: author.@info.55
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_112_author_info_55 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<107,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_112_author_info_55;
// -- Table: author.@info.56
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_113_author_info_56 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<108,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_113_author_info_56;
// -- Table: author.@info.57
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_114_author_info_57 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<109,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_114_author_info_57;
// -- Table: author.@info.58
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_115_author_info_58 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<110,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_115_author_info_58;
// -- Table: author.@info.59
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_116_author_info_59 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<111,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_116_author_info_59;
// -- Table: author.@info.6
std::unique_ptr<t_btree_5__0_1_2_3_4__31> rel_117_author_info_6 = std::make_unique<t_btree_5__0_1_2_3_4__31>();
souffle::RelationWrapper<112,t_btree_5__0_1_2_3_4__31,Tuple<RamDomain,5>,5> wrapper_rel_117_author_info_6;
// -- Table: author.@info.60
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_118_author_info_60 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<113,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_118_author_info_60;
// -- Table: author.@info.61
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_119_author_info_61 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<114,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_119_author_info_61;
// -- Table: author.@info.62
std::unique_ptr<t_btree_5__0_1_2_3_4__31> rel_120_author_info_62 = std::make_unique<t_btree_5__0_1_2_3_4__31>();
souffle::RelationWrapper<115,t_btree_5__0_1_2_3_4__31,Tuple<RamDomain,5>,5> wrapper_rel_120_author_info_62;
// -- Table: author.@info.63
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_121_author_info_63 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<116,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_121_author_info_63;
// -- Table: author.@info.64
std::unique_ptr<t_btree_5__0_1_2_3_4__31> rel_122_author_info_64 = std::make_unique<t_btree_5__0_1_2_3_4__31>();
souffle::RelationWrapper<117,t_btree_5__0_1_2_3_4__31,Tuple<RamDomain,5>,5> wrapper_rel_122_author_info_64;
// -- Table: author.@info.65
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_123_author_info_65 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<118,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_123_author_info_65;
// -- Table: author.@info.66
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_124_author_info_66 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<119,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_124_author_info_66;
// -- Table: author.@info.67
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_125_author_info_67 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<120,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_125_author_info_67;
// -- Table: author.@info.68
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_126_author_info_68 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<121,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_126_author_info_68;
// -- Table: author.@info.69
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_127_author_info_69 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<122,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_127_author_info_69;
// -- Table: author.@info.7
std::unique_ptr<t_btree_5__0_1_2_3_4__31> rel_128_author_info_7 = std::make_unique<t_btree_5__0_1_2_3_4__31>();
souffle::RelationWrapper<123,t_btree_5__0_1_2_3_4__31,Tuple<RamDomain,5>,5> wrapper_rel_128_author_info_7;
// -- Table: author.@info.70
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_129_author_info_70 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<124,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_129_author_info_70;
// -- Table: author.@info.71
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_130_author_info_71 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<125,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_130_author_info_71;
// -- Table: author.@info.72
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_131_author_info_72 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<126,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_131_author_info_72;
// -- Table: author.@info.73
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_132_author_info_73 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<127,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_132_author_info_73;
// -- Table: author.@info.74
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_133_author_info_74 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<128,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_133_author_info_74;
// -- Table: author.@info.75
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_134_author_info_75 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<129,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_134_author_info_75;
// -- Table: author.@info.76
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_135_author_info_76 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<130,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_135_author_info_76;
// -- Table: author.@info.77
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_136_author_info_77 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<131,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_136_author_info_77;
// -- Table: author.@info.78
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_137_author_info_78 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<132,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_137_author_info_78;
// -- Table: author.@info.79
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_138_author_info_79 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<133,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_138_author_info_79;
// -- Table: author.@info.8
std::unique_ptr<t_btree_5__0_1_2_3_4__31> rel_139_author_info_8 = std::make_unique<t_btree_5__0_1_2_3_4__31>();
souffle::RelationWrapper<134,t_btree_5__0_1_2_3_4__31,Tuple<RamDomain,5>,5> wrapper_rel_139_author_info_8;
// -- Table: author.@info.80
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_140_author_info_80 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<135,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_140_author_info_80;
// -- Table: author.@info.81
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_141_author_info_81 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<136,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_141_author_info_81;
// -- Table: author.@info.82
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_142_author_info_82 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<137,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_142_author_info_82;
// -- Table: author.@info.83
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_143_author_info_83 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<138,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_143_author_info_83;
// -- Table: author.@info.84
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_144_author_info_84 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<139,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_144_author_info_84;
// -- Table: author.@info.85
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_145_author_info_85 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<140,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_145_author_info_85;
// -- Table: author.@info.86
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_146_author_info_86 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<141,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_146_author_info_86;
// -- Table: author.@info.87
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_147_author_info_87 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<142,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_147_author_info_87;
// -- Table: author.@info.88
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_148_author_info_88 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<143,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_148_author_info_88;
// -- Table: author.@info.89
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_149_author_info_89 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<144,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_149_author_info_89;
// -- Table: author.@info.9
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_150_author_info_9 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<145,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_150_author_info_9;
// -- Table: author.@info.90
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_151_author_info_90 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<146,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_151_author_info_90;
// -- Table: author.@info.91
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_152_author_info_91 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<147,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_152_author_info_91;
// -- Table: author.@info.92
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_153_author_info_92 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<148,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_153_author_info_92;
// -- Table: author.@info.93
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_154_author_info_93 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<149,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_154_author_info_93;
// -- Table: author.@info.94
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_155_author_info_94 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<150,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_155_author_info_94;
// -- Table: author.@info.95
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_156_author_info_95 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<151,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_156_author_info_95;
// -- Table: author.@info.96
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_157_author_info_96 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<152,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_157_author_info_96;
// -- Table: author.@info.97
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_158_author_info_97 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<153,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_158_author_info_97;
// -- Table: author.@info.98
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_159_author_info_98 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<154,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_159_author_info_98;
// -- Table: author.@info.99
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_160_author_info_99 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<155,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_160_author_info_99;
// -- Table: inv_0.@info.1
std::unique_ptr<t_btree_5__0_1_2_3_4__31> rel_161_inv_0_info_1 = std::make_unique<t_btree_5__0_1_2_3_4__31>();
souffle::RelationWrapper<156,t_btree_5__0_1_2_3_4__31,Tuple<RamDomain,5>,5> wrapper_rel_161_inv_0_info_1;
// -- Table: inv_0.@info.10
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_162_inv_0_info_10 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<157,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_162_inv_0_info_10;
// -- Table: inv_0.@info.11
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_163_inv_0_info_11 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<158,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_163_inv_0_info_11;
// -- Table: inv_0.@info.12
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_164_inv_0_info_12 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<159,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_164_inv_0_info_12;
// -- Table: inv_0.@info.13
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_165_inv_0_info_13 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<160,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_165_inv_0_info_13;
// -- Table: inv_0.@info.14
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_166_inv_0_info_14 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<161,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_166_inv_0_info_14;
// -- Table: inv_0.@info.15
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_167_inv_0_info_15 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<162,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_167_inv_0_info_15;
// -- Table: inv_0.@info.16
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_168_inv_0_info_16 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<163,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_168_inv_0_info_16;
// -- Table: inv_0.@info.17
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_169_inv_0_info_17 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<164,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_169_inv_0_info_17;
// -- Table: inv_0.@info.18
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_170_inv_0_info_18 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<165,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_170_inv_0_info_18;
// -- Table: inv_0.@info.19
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_171_inv_0_info_19 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<166,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_171_inv_0_info_19;
// -- Table: inv_0.@info.2
std::unique_ptr<t_btree_5__0_1_2_3_4__31> rel_172_inv_0_info_2 = std::make_unique<t_btree_5__0_1_2_3_4__31>();
souffle::RelationWrapper<167,t_btree_5__0_1_2_3_4__31,Tuple<RamDomain,5>,5> wrapper_rel_172_inv_0_info_2;
// -- Table: inv_0.@info.20
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_173_inv_0_info_20 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<168,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_173_inv_0_info_20;
// -- Table: inv_0.@info.21
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_174_inv_0_info_21 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<169,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_174_inv_0_info_21;
// -- Table: inv_0.@info.22
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_175_inv_0_info_22 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<170,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_175_inv_0_info_22;
// -- Table: inv_0.@info.23
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_176_inv_0_info_23 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<171,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_176_inv_0_info_23;
// -- Table: inv_0.@info.24
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_177_inv_0_info_24 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<172,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_177_inv_0_info_24;
// -- Table: inv_0.@info.25
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_178_inv_0_info_25 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<173,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_178_inv_0_info_25;
// -- Table: inv_0.@info.26
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_179_inv_0_info_26 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<174,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_179_inv_0_info_26;
// -- Table: inv_0.@info.27
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_180_inv_0_info_27 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<175,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_180_inv_0_info_27;
// -- Table: inv_0.@info.28
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_181_inv_0_info_28 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<176,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_181_inv_0_info_28;
// -- Table: inv_0.@info.29
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_182_inv_0_info_29 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<177,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_182_inv_0_info_29;
// -- Table: inv_0.@info.3
std::unique_ptr<t_btree_5__0_1_2_3_4__31> rel_183_inv_0_info_3 = std::make_unique<t_btree_5__0_1_2_3_4__31>();
souffle::RelationWrapper<178,t_btree_5__0_1_2_3_4__31,Tuple<RamDomain,5>,5> wrapper_rel_183_inv_0_info_3;
// -- Table: inv_0.@info.30
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_184_inv_0_info_30 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<179,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_184_inv_0_info_30;
// -- Table: inv_0.@info.31
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_185_inv_0_info_31 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<180,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_185_inv_0_info_31;
// -- Table: inv_0.@info.32
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_186_inv_0_info_32 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<181,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_186_inv_0_info_32;
// -- Table: inv_0.@info.33
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_187_inv_0_info_33 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<182,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_187_inv_0_info_33;
// -- Table: inv_0.@info.34
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_188_inv_0_info_34 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<183,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_188_inv_0_info_34;
// -- Table: inv_0.@info.35
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_189_inv_0_info_35 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<184,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_189_inv_0_info_35;
// -- Table: inv_0.@info.36
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_190_inv_0_info_36 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<185,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_190_inv_0_info_36;
// -- Table: inv_0.@info.37
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_191_inv_0_info_37 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<186,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_191_inv_0_info_37;
// -- Table: inv_0.@info.38
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_192_inv_0_info_38 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<187,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_192_inv_0_info_38;
// -- Table: inv_0.@info.39
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_193_inv_0_info_39 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<188,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_193_inv_0_info_39;
// -- Table: inv_0.@info.4
std::unique_ptr<t_btree_5__0_1_2_3_4__31> rel_194_inv_0_info_4 = std::make_unique<t_btree_5__0_1_2_3_4__31>();
souffle::RelationWrapper<189,t_btree_5__0_1_2_3_4__31,Tuple<RamDomain,5>,5> wrapper_rel_194_inv_0_info_4;
// -- Table: inv_0.@info.40
std::unique_ptr<t_btree_5__0_1_2_3_4__31> rel_195_inv_0_info_40 = std::make_unique<t_btree_5__0_1_2_3_4__31>();
souffle::RelationWrapper<190,t_btree_5__0_1_2_3_4__31,Tuple<RamDomain,5>,5> wrapper_rel_195_inv_0_info_40;
// -- Table: inv_0.@info.41
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_196_inv_0_info_41 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<191,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_196_inv_0_info_41;
// -- Table: inv_0.@info.42
std::unique_ptr<t_btree_5__0_1_2_3_4__31> rel_197_inv_0_info_42 = std::make_unique<t_btree_5__0_1_2_3_4__31>();
souffle::RelationWrapper<192,t_btree_5__0_1_2_3_4__31,Tuple<RamDomain,5>,5> wrapper_rel_197_inv_0_info_42;
// -- Table: inv_0.@info.43
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_198_inv_0_info_43 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<193,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_198_inv_0_info_43;
// -- Table: inv_0.@info.44
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_199_inv_0_info_44 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<194,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_199_inv_0_info_44;
// -- Table: inv_0.@info.45
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_200_inv_0_info_45 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<195,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_200_inv_0_info_45;
// -- Table: inv_0.@info.46
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_201_inv_0_info_46 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<196,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_201_inv_0_info_46;
// -- Table: inv_0.@info.47
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_202_inv_0_info_47 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<197,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_202_inv_0_info_47;
// -- Table: inv_0.@info.48
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_203_inv_0_info_48 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<198,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_203_inv_0_info_48;
// -- Table: inv_0.@info.49
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_204_inv_0_info_49 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<199,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_204_inv_0_info_49;
// -- Table: inv_0.@info.5
std::unique_ptr<t_btree_5__0_1_2_3_4__31> rel_205_inv_0_info_5 = std::make_unique<t_btree_5__0_1_2_3_4__31>();
souffle::RelationWrapper<200,t_btree_5__0_1_2_3_4__31,Tuple<RamDomain,5>,5> wrapper_rel_205_inv_0_info_5;
// -- Table: inv_0.@info.50
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_206_inv_0_info_50 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<201,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_206_inv_0_info_50;
// -- Table: inv_0.@info.51
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_207_inv_0_info_51 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<202,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_207_inv_0_info_51;
// -- Table: inv_0.@info.52
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_208_inv_0_info_52 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<203,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_208_inv_0_info_52;
// -- Table: inv_0.@info.53
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_209_inv_0_info_53 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<204,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_209_inv_0_info_53;
// -- Table: inv_0.@info.54
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_210_inv_0_info_54 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<205,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_210_inv_0_info_54;
// -- Table: inv_0.@info.55
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_211_inv_0_info_55 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<206,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_211_inv_0_info_55;
// -- Table: inv_0.@info.56
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_212_inv_0_info_56 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<207,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_212_inv_0_info_56;
// -- Table: inv_0.@info.57
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_213_inv_0_info_57 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<208,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_213_inv_0_info_57;
// -- Table: inv_0.@info.58
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_214_inv_0_info_58 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<209,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_214_inv_0_info_58;
// -- Table: inv_0.@info.59
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_215_inv_0_info_59 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<210,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_215_inv_0_info_59;
// -- Table: inv_0.@info.6
std::unique_ptr<t_btree_5__0_1_2_3_4__31> rel_216_inv_0_info_6 = std::make_unique<t_btree_5__0_1_2_3_4__31>();
souffle::RelationWrapper<211,t_btree_5__0_1_2_3_4__31,Tuple<RamDomain,5>,5> wrapper_rel_216_inv_0_info_6;
// -- Table: inv_0.@info.60
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_217_inv_0_info_60 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<212,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_217_inv_0_info_60;
// -- Table: inv_0.@info.61
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_218_inv_0_info_61 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<213,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_218_inv_0_info_61;
// -- Table: inv_0.@info.62
std::unique_ptr<t_btree_5__0_1_2_3_4__31> rel_219_inv_0_info_62 = std::make_unique<t_btree_5__0_1_2_3_4__31>();
souffle::RelationWrapper<214,t_btree_5__0_1_2_3_4__31,Tuple<RamDomain,5>,5> wrapper_rel_219_inv_0_info_62;
// -- Table: inv_0.@info.63
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_220_inv_0_info_63 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<215,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_220_inv_0_info_63;
// -- Table: inv_0.@info.64
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_221_inv_0_info_64 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<216,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_221_inv_0_info_64;
// -- Table: inv_0.@info.65
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_222_inv_0_info_65 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<217,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_222_inv_0_info_65;
// -- Table: inv_0.@info.66
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_223_inv_0_info_66 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<218,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_223_inv_0_info_66;
// -- Table: inv_0.@info.67
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_224_inv_0_info_67 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<219,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_224_inv_0_info_67;
// -- Table: inv_0.@info.68
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_225_inv_0_info_68 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<220,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_225_inv_0_info_68;
// -- Table: inv_0.@info.69
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_226_inv_0_info_69 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<221,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_226_inv_0_info_69;
// -- Table: inv_0.@info.7
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_227_inv_0_info_7 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<222,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_227_inv_0_info_7;
// -- Table: inv_0.@info.70
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_228_inv_0_info_70 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<223,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_228_inv_0_info_70;
// -- Table: inv_0.@info.8
std::unique_ptr<t_btree_5__0_1_2_3_4__31> rel_229_inv_0_info_8 = std::make_unique<t_btree_5__0_1_2_3_4__31>();
souffle::RelationWrapper<224,t_btree_5__0_1_2_3_4__31,Tuple<RamDomain,5>,5> wrapper_rel_229_inv_0_info_8;
// -- Table: inv_0.@info.9
std::unique_ptr<t_btree_6__0_1_2_3_4_5__63> rel_230_inv_0_info_9 = std::make_unique<t_btree_6__0_1_2_3_4_5__63>();
souffle::RelationWrapper<225,t_btree_6__0_1_2_3_4_5__63,Tuple<RamDomain,6>,6> wrapper_rel_230_inv_0_info_9;
public:
Sf_souffle_small() : 
wrapper_rel_1_Iauthor(*rel_1_Iauthor,symTable,"Iauthor",std::array<const char *,4>{{"s:V","s:V","i:number","i:number"}},std::array<const char *,4>{{"v0","v1","@rule_number","@level_number"}}),

wrapper_rel_2_Rule(*rel_2_Rule,symTable,"Rule",std::array<const char *,3>{{"i:number","i:number","i:number"}},std::array<const char *,3>{{"n","@rule_number","@level_number"}}),

wrapper_rel_3_genre(*rel_3_genre,symTable,"genre",std::array<const char *,4>{{"s:V","s:V","i:number","i:number"}},std::array<const char *,4>{{"v0","v1","@rule_number","@level_number"}}),

wrapper_rel_4_precededBy(*rel_4_precededBy,symTable,"precededBy",std::array<const char *,4>{{"s:V","s:V","i:number","i:number"}},std::array<const char *,4>{{"v0","v1","@rule_number","@level_number"}}),

wrapper_rel_5_inv_0(*rel_5_inv_0,symTable,"inv_0",std::array<const char *,4>{{"s:V","s:V","i:number","i:number"}},std::array<const char *,4>{{"v0","v1","@rule_number","@level_number"}}),

wrapper_rel_8_author(*rel_8_author,symTable,"author",std::array<const char *,4>{{"s:V","s:V","i:number","i:number"}},std::array<const char *,4>{{"v0","v1","@rule_number","@level_number"}}),

wrapper_rel_11_author_info_1(*rel_11_author_info_1,symTable,"author.@info.1",std::array<const char *,5>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,5>{{"clause_num","head_vars","rel_0","rel_1","clause_repr"}}),

wrapper_rel_12_author_info_10(*rel_12_author_info_10,symTable,"author.@info.10",std::array<const char *,5>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,5>{{"clause_num","head_vars","rel_0","rel_1","clause_repr"}}),

wrapper_rel_13_author_info_100(*rel_13_author_info_100,symTable,"author.@info.100",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_14_author_info_101(*rel_14_author_info_101,symTable,"author.@info.101",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_15_author_info_102(*rel_15_author_info_102,symTable,"author.@info.102",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_16_author_info_103(*rel_16_author_info_103,symTable,"author.@info.103",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_17_author_info_104(*rel_17_author_info_104,symTable,"author.@info.104",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_18_author_info_105(*rel_18_author_info_105,symTable,"author.@info.105",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_19_author_info_106(*rel_19_author_info_106,symTable,"author.@info.106",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_20_author_info_107(*rel_20_author_info_107,symTable,"author.@info.107",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_21_author_info_108(*rel_21_author_info_108,symTable,"author.@info.108",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_22_author_info_109(*rel_22_author_info_109,symTable,"author.@info.109",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_23_author_info_11(*rel_23_author_info_11,symTable,"author.@info.11",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_24_author_info_110(*rel_24_author_info_110,symTable,"author.@info.110",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_25_author_info_111(*rel_25_author_info_111,symTable,"author.@info.111",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_26_author_info_112(*rel_26_author_info_112,symTable,"author.@info.112",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_27_author_info_113(*rel_27_author_info_113,symTable,"author.@info.113",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_28_author_info_114(*rel_28_author_info_114,symTable,"author.@info.114",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_29_author_info_115(*rel_29_author_info_115,symTable,"author.@info.115",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_30_author_info_116(*rel_30_author_info_116,symTable,"author.@info.116",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_31_author_info_117(*rel_31_author_info_117,symTable,"author.@info.117",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_32_author_info_118(*rel_32_author_info_118,symTable,"author.@info.118",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_33_author_info_119(*rel_33_author_info_119,symTable,"author.@info.119",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_34_author_info_12(*rel_34_author_info_12,symTable,"author.@info.12",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_35_author_info_120(*rel_35_author_info_120,symTable,"author.@info.120",std::array<const char *,5>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,5>{{"clause_num","head_vars","rel_0","rel_1","clause_repr"}}),

wrapper_rel_36_author_info_121(*rel_36_author_info_121,symTable,"author.@info.121",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_37_author_info_122(*rel_37_author_info_122,symTable,"author.@info.122",std::array<const char *,5>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,5>{{"clause_num","head_vars","rel_0","rel_1","clause_repr"}}),

wrapper_rel_38_author_info_123(*rel_38_author_info_123,symTable,"author.@info.123",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_39_author_info_124(*rel_39_author_info_124,symTable,"author.@info.124",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_40_author_info_125(*rel_40_author_info_125,symTable,"author.@info.125",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_41_author_info_126(*rel_41_author_info_126,symTable,"author.@info.126",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_42_author_info_127(*rel_42_author_info_127,symTable,"author.@info.127",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_43_author_info_128(*rel_43_author_info_128,symTable,"author.@info.128",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_44_author_info_129(*rel_44_author_info_129,symTable,"author.@info.129",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_45_author_info_13(*rel_45_author_info_13,symTable,"author.@info.13",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_46_author_info_130(*rel_46_author_info_130,symTable,"author.@info.130",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_47_author_info_131(*rel_47_author_info_131,symTable,"author.@info.131",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_48_author_info_132(*rel_48_author_info_132,symTable,"author.@info.132",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_49_author_info_133(*rel_49_author_info_133,symTable,"author.@info.133",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_50_author_info_134(*rel_50_author_info_134,symTable,"author.@info.134",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_51_author_info_135(*rel_51_author_info_135,symTable,"author.@info.135",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_52_author_info_136(*rel_52_author_info_136,symTable,"author.@info.136",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_53_author_info_137(*rel_53_author_info_137,symTable,"author.@info.137",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_54_author_info_138(*rel_54_author_info_138,symTable,"author.@info.138",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_55_author_info_139(*rel_55_author_info_139,symTable,"author.@info.139",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_56_author_info_14(*rel_56_author_info_14,symTable,"author.@info.14",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_57_author_info_140(*rel_57_author_info_140,symTable,"author.@info.140",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_58_author_info_141(*rel_58_author_info_141,symTable,"author.@info.141",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_59_author_info_142(*rel_59_author_info_142,symTable,"author.@info.142",std::array<const char *,5>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,5>{{"clause_num","head_vars","rel_0","rel_1","clause_repr"}}),

wrapper_rel_60_author_info_143(*rel_60_author_info_143,symTable,"author.@info.143",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_61_author_info_144(*rel_61_author_info_144,symTable,"author.@info.144",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_62_author_info_145(*rel_62_author_info_145,symTable,"author.@info.145",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_63_author_info_146(*rel_63_author_info_146,symTable,"author.@info.146",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_64_author_info_147(*rel_64_author_info_147,symTable,"author.@info.147",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_65_author_info_148(*rel_65_author_info_148,symTable,"author.@info.148",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_66_author_info_149(*rel_66_author_info_149,symTable,"author.@info.149",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_67_author_info_15(*rel_67_author_info_15,symTable,"author.@info.15",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_68_author_info_150(*rel_68_author_info_150,symTable,"author.@info.150",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_69_author_info_16(*rel_69_author_info_16,symTable,"author.@info.16",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_70_author_info_17(*rel_70_author_info_17,symTable,"author.@info.17",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_71_author_info_18(*rel_71_author_info_18,symTable,"author.@info.18",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_72_author_info_19(*rel_72_author_info_19,symTable,"author.@info.19",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_73_author_info_2(*rel_73_author_info_2,symTable,"author.@info.2",std::array<const char *,5>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,5>{{"clause_num","head_vars","rel_0","rel_1","clause_repr"}}),

wrapper_rel_74_author_info_20(*rel_74_author_info_20,symTable,"author.@info.20",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_75_author_info_21(*rel_75_author_info_21,symTable,"author.@info.21",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_76_author_info_22(*rel_76_author_info_22,symTable,"author.@info.22",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_77_author_info_23(*rel_77_author_info_23,symTable,"author.@info.23",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_78_author_info_24(*rel_78_author_info_24,symTable,"author.@info.24",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_79_author_info_25(*rel_79_author_info_25,symTable,"author.@info.25",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_80_author_info_26(*rel_80_author_info_26,symTable,"author.@info.26",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_81_author_info_27(*rel_81_author_info_27,symTable,"author.@info.27",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_82_author_info_28(*rel_82_author_info_28,symTable,"author.@info.28",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_83_author_info_29(*rel_83_author_info_29,symTable,"author.@info.29",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_84_author_info_3(*rel_84_author_info_3,symTable,"author.@info.3",std::array<const char *,5>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,5>{{"clause_num","head_vars","rel_0","rel_1","clause_repr"}}),

wrapper_rel_85_author_info_30(*rel_85_author_info_30,symTable,"author.@info.30",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_86_author_info_31(*rel_86_author_info_31,symTable,"author.@info.31",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_87_author_info_32(*rel_87_author_info_32,symTable,"author.@info.32",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_88_author_info_33(*rel_88_author_info_33,symTable,"author.@info.33",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_89_author_info_34(*rel_89_author_info_34,symTable,"author.@info.34",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_90_author_info_35(*rel_90_author_info_35,symTable,"author.@info.35",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_91_author_info_36(*rel_91_author_info_36,symTable,"author.@info.36",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_92_author_info_37(*rel_92_author_info_37,symTable,"author.@info.37",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_93_author_info_38(*rel_93_author_info_38,symTable,"author.@info.38",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_94_author_info_39(*rel_94_author_info_39,symTable,"author.@info.39",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_95_author_info_4(*rel_95_author_info_4,symTable,"author.@info.4",std::array<const char *,5>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,5>{{"clause_num","head_vars","rel_0","rel_1","clause_repr"}}),

wrapper_rel_96_author_info_40(*rel_96_author_info_40,symTable,"author.@info.40",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_97_author_info_41(*rel_97_author_info_41,symTable,"author.@info.41",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_98_author_info_42(*rel_98_author_info_42,symTable,"author.@info.42",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_99_author_info_43(*rel_99_author_info_43,symTable,"author.@info.43",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_100_author_info_44(*rel_100_author_info_44,symTable,"author.@info.44",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_101_author_info_45(*rel_101_author_info_45,symTable,"author.@info.45",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_102_author_info_46(*rel_102_author_info_46,symTable,"author.@info.46",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_103_author_info_47(*rel_103_author_info_47,symTable,"author.@info.47",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_104_author_info_48(*rel_104_author_info_48,symTable,"author.@info.48",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_105_author_info_49(*rel_105_author_info_49,symTable,"author.@info.49",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_106_author_info_5(*rel_106_author_info_5,symTable,"author.@info.5",std::array<const char *,5>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,5>{{"clause_num","head_vars","rel_0","rel_1","clause_repr"}}),

wrapper_rel_107_author_info_50(*rel_107_author_info_50,symTable,"author.@info.50",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_108_author_info_51(*rel_108_author_info_51,symTable,"author.@info.51",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_109_author_info_52(*rel_109_author_info_52,symTable,"author.@info.52",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_110_author_info_53(*rel_110_author_info_53,symTable,"author.@info.53",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_111_author_info_54(*rel_111_author_info_54,symTable,"author.@info.54",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_112_author_info_55(*rel_112_author_info_55,symTable,"author.@info.55",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_113_author_info_56(*rel_113_author_info_56,symTable,"author.@info.56",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_114_author_info_57(*rel_114_author_info_57,symTable,"author.@info.57",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_115_author_info_58(*rel_115_author_info_58,symTable,"author.@info.58",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_116_author_info_59(*rel_116_author_info_59,symTable,"author.@info.59",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_117_author_info_6(*rel_117_author_info_6,symTable,"author.@info.6",std::array<const char *,5>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,5>{{"clause_num","head_vars","rel_0","rel_1","clause_repr"}}),

wrapper_rel_118_author_info_60(*rel_118_author_info_60,symTable,"author.@info.60",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_119_author_info_61(*rel_119_author_info_61,symTable,"author.@info.61",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_120_author_info_62(*rel_120_author_info_62,symTable,"author.@info.62",std::array<const char *,5>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,5>{{"clause_num","head_vars","rel_0","rel_1","clause_repr"}}),

wrapper_rel_121_author_info_63(*rel_121_author_info_63,symTable,"author.@info.63",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_122_author_info_64(*rel_122_author_info_64,symTable,"author.@info.64",std::array<const char *,5>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,5>{{"clause_num","head_vars","rel_0","rel_1","clause_repr"}}),

wrapper_rel_123_author_info_65(*rel_123_author_info_65,symTable,"author.@info.65",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_124_author_info_66(*rel_124_author_info_66,symTable,"author.@info.66",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_125_author_info_67(*rel_125_author_info_67,symTable,"author.@info.67",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_126_author_info_68(*rel_126_author_info_68,symTable,"author.@info.68",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_127_author_info_69(*rel_127_author_info_69,symTable,"author.@info.69",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_128_author_info_7(*rel_128_author_info_7,symTable,"author.@info.7",std::array<const char *,5>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,5>{{"clause_num","head_vars","rel_0","rel_1","clause_repr"}}),

wrapper_rel_129_author_info_70(*rel_129_author_info_70,symTable,"author.@info.70",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_130_author_info_71(*rel_130_author_info_71,symTable,"author.@info.71",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_131_author_info_72(*rel_131_author_info_72,symTable,"author.@info.72",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_132_author_info_73(*rel_132_author_info_73,symTable,"author.@info.73",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_133_author_info_74(*rel_133_author_info_74,symTable,"author.@info.74",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_134_author_info_75(*rel_134_author_info_75,symTable,"author.@info.75",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_135_author_info_76(*rel_135_author_info_76,symTable,"author.@info.76",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_136_author_info_77(*rel_136_author_info_77,symTable,"author.@info.77",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_137_author_info_78(*rel_137_author_info_78,symTable,"author.@info.78",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_138_author_info_79(*rel_138_author_info_79,symTable,"author.@info.79",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_139_author_info_8(*rel_139_author_info_8,symTable,"author.@info.8",std::array<const char *,5>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,5>{{"clause_num","head_vars","rel_0","rel_1","clause_repr"}}),

wrapper_rel_140_author_info_80(*rel_140_author_info_80,symTable,"author.@info.80",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_141_author_info_81(*rel_141_author_info_81,symTable,"author.@info.81",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_142_author_info_82(*rel_142_author_info_82,symTable,"author.@info.82",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_143_author_info_83(*rel_143_author_info_83,symTable,"author.@info.83",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_144_author_info_84(*rel_144_author_info_84,symTable,"author.@info.84",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_145_author_info_85(*rel_145_author_info_85,symTable,"author.@info.85",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_146_author_info_86(*rel_146_author_info_86,symTable,"author.@info.86",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_147_author_info_87(*rel_147_author_info_87,symTable,"author.@info.87",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_148_author_info_88(*rel_148_author_info_88,symTable,"author.@info.88",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_149_author_info_89(*rel_149_author_info_89,symTable,"author.@info.89",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_150_author_info_9(*rel_150_author_info_9,symTable,"author.@info.9",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_151_author_info_90(*rel_151_author_info_90,symTable,"author.@info.90",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_152_author_info_91(*rel_152_author_info_91,symTable,"author.@info.91",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_153_author_info_92(*rel_153_author_info_92,symTable,"author.@info.92",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_154_author_info_93(*rel_154_author_info_93,symTable,"author.@info.93",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_155_author_info_94(*rel_155_author_info_94,symTable,"author.@info.94",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_156_author_info_95(*rel_156_author_info_95,symTable,"author.@info.95",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_157_author_info_96(*rel_157_author_info_96,symTable,"author.@info.96",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_158_author_info_97(*rel_158_author_info_97,symTable,"author.@info.97",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_159_author_info_98(*rel_159_author_info_98,symTable,"author.@info.98",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_160_author_info_99(*rel_160_author_info_99,symTable,"author.@info.99",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_161_inv_0_info_1(*rel_161_inv_0_info_1,symTable,"inv_0.@info.1",std::array<const char *,5>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,5>{{"clause_num","head_vars","rel_0","rel_1","clause_repr"}}),

wrapper_rel_162_inv_0_info_10(*rel_162_inv_0_info_10,symTable,"inv_0.@info.10",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_163_inv_0_info_11(*rel_163_inv_0_info_11,symTable,"inv_0.@info.11",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_164_inv_0_info_12(*rel_164_inv_0_info_12,symTable,"inv_0.@info.12",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_165_inv_0_info_13(*rel_165_inv_0_info_13,symTable,"inv_0.@info.13",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_166_inv_0_info_14(*rel_166_inv_0_info_14,symTable,"inv_0.@info.14",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_167_inv_0_info_15(*rel_167_inv_0_info_15,symTable,"inv_0.@info.15",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_168_inv_0_info_16(*rel_168_inv_0_info_16,symTable,"inv_0.@info.16",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_169_inv_0_info_17(*rel_169_inv_0_info_17,symTable,"inv_0.@info.17",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_170_inv_0_info_18(*rel_170_inv_0_info_18,symTable,"inv_0.@info.18",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_171_inv_0_info_19(*rel_171_inv_0_info_19,symTable,"inv_0.@info.19",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_172_inv_0_info_2(*rel_172_inv_0_info_2,symTable,"inv_0.@info.2",std::array<const char *,5>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,5>{{"clause_num","head_vars","rel_0","rel_1","clause_repr"}}),

wrapper_rel_173_inv_0_info_20(*rel_173_inv_0_info_20,symTable,"inv_0.@info.20",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_174_inv_0_info_21(*rel_174_inv_0_info_21,symTable,"inv_0.@info.21",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_175_inv_0_info_22(*rel_175_inv_0_info_22,symTable,"inv_0.@info.22",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_176_inv_0_info_23(*rel_176_inv_0_info_23,symTable,"inv_0.@info.23",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_177_inv_0_info_24(*rel_177_inv_0_info_24,symTable,"inv_0.@info.24",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_178_inv_0_info_25(*rel_178_inv_0_info_25,symTable,"inv_0.@info.25",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_179_inv_0_info_26(*rel_179_inv_0_info_26,symTable,"inv_0.@info.26",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_180_inv_0_info_27(*rel_180_inv_0_info_27,symTable,"inv_0.@info.27",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_181_inv_0_info_28(*rel_181_inv_0_info_28,symTable,"inv_0.@info.28",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_182_inv_0_info_29(*rel_182_inv_0_info_29,symTable,"inv_0.@info.29",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_183_inv_0_info_3(*rel_183_inv_0_info_3,symTable,"inv_0.@info.3",std::array<const char *,5>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,5>{{"clause_num","head_vars","rel_0","rel_1","clause_repr"}}),

wrapper_rel_184_inv_0_info_30(*rel_184_inv_0_info_30,symTable,"inv_0.@info.30",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_185_inv_0_info_31(*rel_185_inv_0_info_31,symTable,"inv_0.@info.31",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_186_inv_0_info_32(*rel_186_inv_0_info_32,symTable,"inv_0.@info.32",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_187_inv_0_info_33(*rel_187_inv_0_info_33,symTable,"inv_0.@info.33",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_188_inv_0_info_34(*rel_188_inv_0_info_34,symTable,"inv_0.@info.34",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_189_inv_0_info_35(*rel_189_inv_0_info_35,symTable,"inv_0.@info.35",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_190_inv_0_info_36(*rel_190_inv_0_info_36,symTable,"inv_0.@info.36",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_191_inv_0_info_37(*rel_191_inv_0_info_37,symTable,"inv_0.@info.37",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_192_inv_0_info_38(*rel_192_inv_0_info_38,symTable,"inv_0.@info.38",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_193_inv_0_info_39(*rel_193_inv_0_info_39,symTable,"inv_0.@info.39",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_194_inv_0_info_4(*rel_194_inv_0_info_4,symTable,"inv_0.@info.4",std::array<const char *,5>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,5>{{"clause_num","head_vars","rel_0","rel_1","clause_repr"}}),

wrapper_rel_195_inv_0_info_40(*rel_195_inv_0_info_40,symTable,"inv_0.@info.40",std::array<const char *,5>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,5>{{"clause_num","head_vars","rel_0","rel_1","clause_repr"}}),

wrapper_rel_196_inv_0_info_41(*rel_196_inv_0_info_41,symTable,"inv_0.@info.41",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_197_inv_0_info_42(*rel_197_inv_0_info_42,symTable,"inv_0.@info.42",std::array<const char *,5>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,5>{{"clause_num","head_vars","rel_0","rel_1","clause_repr"}}),

wrapper_rel_198_inv_0_info_43(*rel_198_inv_0_info_43,symTable,"inv_0.@info.43",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_199_inv_0_info_44(*rel_199_inv_0_info_44,symTable,"inv_0.@info.44",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_200_inv_0_info_45(*rel_200_inv_0_info_45,symTable,"inv_0.@info.45",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_201_inv_0_info_46(*rel_201_inv_0_info_46,symTable,"inv_0.@info.46",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_202_inv_0_info_47(*rel_202_inv_0_info_47,symTable,"inv_0.@info.47",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_203_inv_0_info_48(*rel_203_inv_0_info_48,symTable,"inv_0.@info.48",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_204_inv_0_info_49(*rel_204_inv_0_info_49,symTable,"inv_0.@info.49",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_205_inv_0_info_5(*rel_205_inv_0_info_5,symTable,"inv_0.@info.5",std::array<const char *,5>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,5>{{"clause_num","head_vars","rel_0","rel_1","clause_repr"}}),

wrapper_rel_206_inv_0_info_50(*rel_206_inv_0_info_50,symTable,"inv_0.@info.50",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_207_inv_0_info_51(*rel_207_inv_0_info_51,symTable,"inv_0.@info.51",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_208_inv_0_info_52(*rel_208_inv_0_info_52,symTable,"inv_0.@info.52",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_209_inv_0_info_53(*rel_209_inv_0_info_53,symTable,"inv_0.@info.53",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_210_inv_0_info_54(*rel_210_inv_0_info_54,symTable,"inv_0.@info.54",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_211_inv_0_info_55(*rel_211_inv_0_info_55,symTable,"inv_0.@info.55",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_212_inv_0_info_56(*rel_212_inv_0_info_56,symTable,"inv_0.@info.56",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_213_inv_0_info_57(*rel_213_inv_0_info_57,symTable,"inv_0.@info.57",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_214_inv_0_info_58(*rel_214_inv_0_info_58,symTable,"inv_0.@info.58",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_215_inv_0_info_59(*rel_215_inv_0_info_59,symTable,"inv_0.@info.59",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_216_inv_0_info_6(*rel_216_inv_0_info_6,symTable,"inv_0.@info.6",std::array<const char *,5>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,5>{{"clause_num","head_vars","rel_0","rel_1","clause_repr"}}),

wrapper_rel_217_inv_0_info_60(*rel_217_inv_0_info_60,symTable,"inv_0.@info.60",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_218_inv_0_info_61(*rel_218_inv_0_info_61,symTable,"inv_0.@info.61",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_219_inv_0_info_62(*rel_219_inv_0_info_62,symTable,"inv_0.@info.62",std::array<const char *,5>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,5>{{"clause_num","head_vars","rel_0","rel_1","clause_repr"}}),

wrapper_rel_220_inv_0_info_63(*rel_220_inv_0_info_63,symTable,"inv_0.@info.63",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_221_inv_0_info_64(*rel_221_inv_0_info_64,symTable,"inv_0.@info.64",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_222_inv_0_info_65(*rel_222_inv_0_info_65,symTable,"inv_0.@info.65",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_223_inv_0_info_66(*rel_223_inv_0_info_66,symTable,"inv_0.@info.66",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_224_inv_0_info_67(*rel_224_inv_0_info_67,symTable,"inv_0.@info.67",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_225_inv_0_info_68(*rel_225_inv_0_info_68,symTable,"inv_0.@info.68",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_226_inv_0_info_69(*rel_226_inv_0_info_69,symTable,"inv_0.@info.69",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_227_inv_0_info_7(*rel_227_inv_0_info_7,symTable,"inv_0.@info.7",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_228_inv_0_info_70(*rel_228_inv_0_info_70,symTable,"inv_0.@info.70",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}),

wrapper_rel_229_inv_0_info_8(*rel_229_inv_0_info_8,symTable,"inv_0.@info.8",std::array<const char *,5>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,5>{{"clause_num","head_vars","rel_0","rel_1","clause_repr"}}),

wrapper_rel_230_inv_0_info_9(*rel_230_inv_0_info_9,symTable,"inv_0.@info.9",std::array<const char *,6>{{"i:number","s:symbol","s:symbol","s:symbol","s:symbol","s:symbol"}},std::array<const char *,6>{{"clause_num","head_vars","rel_0","rel_1","rel_2","clause_repr"}}){
addRelation("Iauthor",&wrapper_rel_1_Iauthor,true,false);
addRelation("Rule",&wrapper_rel_2_Rule,true,false);
addRelation("genre",&wrapper_rel_3_genre,true,false);
addRelation("precededBy",&wrapper_rel_4_precededBy,true,false);
addRelation("inv_0",&wrapper_rel_5_inv_0,false,true);
addRelation("author",&wrapper_rel_8_author,false,true);
addRelation("author.@info.1",&wrapper_rel_11_author_info_1,false,false);
addRelation("author.@info.10",&wrapper_rel_12_author_info_10,false,false);
addRelation("author.@info.100",&wrapper_rel_13_author_info_100,false,false);
addRelation("author.@info.101",&wrapper_rel_14_author_info_101,false,false);
addRelation("author.@info.102",&wrapper_rel_15_author_info_102,false,false);
addRelation("author.@info.103",&wrapper_rel_16_author_info_103,false,false);
addRelation("author.@info.104",&wrapper_rel_17_author_info_104,false,false);
addRelation("author.@info.105",&wrapper_rel_18_author_info_105,false,false);
addRelation("author.@info.106",&wrapper_rel_19_author_info_106,false,false);
addRelation("author.@info.107",&wrapper_rel_20_author_info_107,false,false);
addRelation("author.@info.108",&wrapper_rel_21_author_info_108,false,false);
addRelation("author.@info.109",&wrapper_rel_22_author_info_109,false,false);
addRelation("author.@info.11",&wrapper_rel_23_author_info_11,false,false);
addRelation("author.@info.110",&wrapper_rel_24_author_info_110,false,false);
addRelation("author.@info.111",&wrapper_rel_25_author_info_111,false,false);
addRelation("author.@info.112",&wrapper_rel_26_author_info_112,false,false);
addRelation("author.@info.113",&wrapper_rel_27_author_info_113,false,false);
addRelation("author.@info.114",&wrapper_rel_28_author_info_114,false,false);
addRelation("author.@info.115",&wrapper_rel_29_author_info_115,false,false);
addRelation("author.@info.116",&wrapper_rel_30_author_info_116,false,false);
addRelation("author.@info.117",&wrapper_rel_31_author_info_117,false,false);
addRelation("author.@info.118",&wrapper_rel_32_author_info_118,false,false);
addRelation("author.@info.119",&wrapper_rel_33_author_info_119,false,false);
addRelation("author.@info.12",&wrapper_rel_34_author_info_12,false,false);
addRelation("author.@info.120",&wrapper_rel_35_author_info_120,false,false);
addRelation("author.@info.121",&wrapper_rel_36_author_info_121,false,false);
addRelation("author.@info.122",&wrapper_rel_37_author_info_122,false,false);
addRelation("author.@info.123",&wrapper_rel_38_author_info_123,false,false);
addRelation("author.@info.124",&wrapper_rel_39_author_info_124,false,false);
addRelation("author.@info.125",&wrapper_rel_40_author_info_125,false,false);
addRelation("author.@info.126",&wrapper_rel_41_author_info_126,false,false);
addRelation("author.@info.127",&wrapper_rel_42_author_info_127,false,false);
addRelation("author.@info.128",&wrapper_rel_43_author_info_128,false,false);
addRelation("author.@info.129",&wrapper_rel_44_author_info_129,false,false);
addRelation("author.@info.13",&wrapper_rel_45_author_info_13,false,false);
addRelation("author.@info.130",&wrapper_rel_46_author_info_130,false,false);
addRelation("author.@info.131",&wrapper_rel_47_author_info_131,false,false);
addRelation("author.@info.132",&wrapper_rel_48_author_info_132,false,false);
addRelation("author.@info.133",&wrapper_rel_49_author_info_133,false,false);
addRelation("author.@info.134",&wrapper_rel_50_author_info_134,false,false);
addRelation("author.@info.135",&wrapper_rel_51_author_info_135,false,false);
addRelation("author.@info.136",&wrapper_rel_52_author_info_136,false,false);
addRelation("author.@info.137",&wrapper_rel_53_author_info_137,false,false);
addRelation("author.@info.138",&wrapper_rel_54_author_info_138,false,false);
addRelation("author.@info.139",&wrapper_rel_55_author_info_139,false,false);
addRelation("author.@info.14",&wrapper_rel_56_author_info_14,false,false);
addRelation("author.@info.140",&wrapper_rel_57_author_info_140,false,false);
addRelation("author.@info.141",&wrapper_rel_58_author_info_141,false,false);
addRelation("author.@info.142",&wrapper_rel_59_author_info_142,false,false);
addRelation("author.@info.143",&wrapper_rel_60_author_info_143,false,false);
addRelation("author.@info.144",&wrapper_rel_61_author_info_144,false,false);
addRelation("author.@info.145",&wrapper_rel_62_author_info_145,false,false);
addRelation("author.@info.146",&wrapper_rel_63_author_info_146,false,false);
addRelation("author.@info.147",&wrapper_rel_64_author_info_147,false,false);
addRelation("author.@info.148",&wrapper_rel_65_author_info_148,false,false);
addRelation("author.@info.149",&wrapper_rel_66_author_info_149,false,false);
addRelation("author.@info.15",&wrapper_rel_67_author_info_15,false,false);
addRelation("author.@info.150",&wrapper_rel_68_author_info_150,false,false);
addRelation("author.@info.16",&wrapper_rel_69_author_info_16,false,false);
addRelation("author.@info.17",&wrapper_rel_70_author_info_17,false,false);
addRelation("author.@info.18",&wrapper_rel_71_author_info_18,false,false);
addRelation("author.@info.19",&wrapper_rel_72_author_info_19,false,false);
addRelation("author.@info.2",&wrapper_rel_73_author_info_2,false,false);
addRelation("author.@info.20",&wrapper_rel_74_author_info_20,false,false);
addRelation("author.@info.21",&wrapper_rel_75_author_info_21,false,false);
addRelation("author.@info.22",&wrapper_rel_76_author_info_22,false,false);
addRelation("author.@info.23",&wrapper_rel_77_author_info_23,false,false);
addRelation("author.@info.24",&wrapper_rel_78_author_info_24,false,false);
addRelation("author.@info.25",&wrapper_rel_79_author_info_25,false,false);
addRelation("author.@info.26",&wrapper_rel_80_author_info_26,false,false);
addRelation("author.@info.27",&wrapper_rel_81_author_info_27,false,false);
addRelation("author.@info.28",&wrapper_rel_82_author_info_28,false,false);
addRelation("author.@info.29",&wrapper_rel_83_author_info_29,false,false);
addRelation("author.@info.3",&wrapper_rel_84_author_info_3,false,false);
addRelation("author.@info.30",&wrapper_rel_85_author_info_30,false,false);
addRelation("author.@info.31",&wrapper_rel_86_author_info_31,false,false);
addRelation("author.@info.32",&wrapper_rel_87_author_info_32,false,false);
addRelation("author.@info.33",&wrapper_rel_88_author_info_33,false,false);
addRelation("author.@info.34",&wrapper_rel_89_author_info_34,false,false);
addRelation("author.@info.35",&wrapper_rel_90_author_info_35,false,false);
addRelation("author.@info.36",&wrapper_rel_91_author_info_36,false,false);
addRelation("author.@info.37",&wrapper_rel_92_author_info_37,false,false);
addRelation("author.@info.38",&wrapper_rel_93_author_info_38,false,false);
addRelation("author.@info.39",&wrapper_rel_94_author_info_39,false,false);
addRelation("author.@info.4",&wrapper_rel_95_author_info_4,false,false);
addRelation("author.@info.40",&wrapper_rel_96_author_info_40,false,false);
addRelation("author.@info.41",&wrapper_rel_97_author_info_41,false,false);
addRelation("author.@info.42",&wrapper_rel_98_author_info_42,false,false);
addRelation("author.@info.43",&wrapper_rel_99_author_info_43,false,false);
addRelation("author.@info.44",&wrapper_rel_100_author_info_44,false,false);
addRelation("author.@info.45",&wrapper_rel_101_author_info_45,false,false);
addRelation("author.@info.46",&wrapper_rel_102_author_info_46,false,false);
addRelation("author.@info.47",&wrapper_rel_103_author_info_47,false,false);
addRelation("author.@info.48",&wrapper_rel_104_author_info_48,false,false);
addRelation("author.@info.49",&wrapper_rel_105_author_info_49,false,false);
addRelation("author.@info.5",&wrapper_rel_106_author_info_5,false,false);
addRelation("author.@info.50",&wrapper_rel_107_author_info_50,false,false);
addRelation("author.@info.51",&wrapper_rel_108_author_info_51,false,false);
addRelation("author.@info.52",&wrapper_rel_109_author_info_52,false,false);
addRelation("author.@info.53",&wrapper_rel_110_author_info_53,false,false);
addRelation("author.@info.54",&wrapper_rel_111_author_info_54,false,false);
addRelation("author.@info.55",&wrapper_rel_112_author_info_55,false,false);
addRelation("author.@info.56",&wrapper_rel_113_author_info_56,false,false);
addRelation("author.@info.57",&wrapper_rel_114_author_info_57,false,false);
addRelation("author.@info.58",&wrapper_rel_115_author_info_58,false,false);
addRelation("author.@info.59",&wrapper_rel_116_author_info_59,false,false);
addRelation("author.@info.6",&wrapper_rel_117_author_info_6,false,false);
addRelation("author.@info.60",&wrapper_rel_118_author_info_60,false,false);
addRelation("author.@info.61",&wrapper_rel_119_author_info_61,false,false);
addRelation("author.@info.62",&wrapper_rel_120_author_info_62,false,false);
addRelation("author.@info.63",&wrapper_rel_121_author_info_63,false,false);
addRelation("author.@info.64",&wrapper_rel_122_author_info_64,false,false);
addRelation("author.@info.65",&wrapper_rel_123_author_info_65,false,false);
addRelation("author.@info.66",&wrapper_rel_124_author_info_66,false,false);
addRelation("author.@info.67",&wrapper_rel_125_author_info_67,false,false);
addRelation("author.@info.68",&wrapper_rel_126_author_info_68,false,false);
addRelation("author.@info.69",&wrapper_rel_127_author_info_69,false,false);
addRelation("author.@info.7",&wrapper_rel_128_author_info_7,false,false);
addRelation("author.@info.70",&wrapper_rel_129_author_info_70,false,false);
addRelation("author.@info.71",&wrapper_rel_130_author_info_71,false,false);
addRelation("author.@info.72",&wrapper_rel_131_author_info_72,false,false);
addRelation("author.@info.73",&wrapper_rel_132_author_info_73,false,false);
addRelation("author.@info.74",&wrapper_rel_133_author_info_74,false,false);
addRelation("author.@info.75",&wrapper_rel_134_author_info_75,false,false);
addRelation("author.@info.76",&wrapper_rel_135_author_info_76,false,false);
addRelation("author.@info.77",&wrapper_rel_136_author_info_77,false,false);
addRelation("author.@info.78",&wrapper_rel_137_author_info_78,false,false);
addRelation("author.@info.79",&wrapper_rel_138_author_info_79,false,false);
addRelation("author.@info.8",&wrapper_rel_139_author_info_8,false,false);
addRelation("author.@info.80",&wrapper_rel_140_author_info_80,false,false);
addRelation("author.@info.81",&wrapper_rel_141_author_info_81,false,false);
addRelation("author.@info.82",&wrapper_rel_142_author_info_82,false,false);
addRelation("author.@info.83",&wrapper_rel_143_author_info_83,false,false);
addRelation("author.@info.84",&wrapper_rel_144_author_info_84,false,false);
addRelation("author.@info.85",&wrapper_rel_145_author_info_85,false,false);
addRelation("author.@info.86",&wrapper_rel_146_author_info_86,false,false);
addRelation("author.@info.87",&wrapper_rel_147_author_info_87,false,false);
addRelation("author.@info.88",&wrapper_rel_148_author_info_88,false,false);
addRelation("author.@info.89",&wrapper_rel_149_author_info_89,false,false);
addRelation("author.@info.9",&wrapper_rel_150_author_info_9,false,false);
addRelation("author.@info.90",&wrapper_rel_151_author_info_90,false,false);
addRelation("author.@info.91",&wrapper_rel_152_author_info_91,false,false);
addRelation("author.@info.92",&wrapper_rel_153_author_info_92,false,false);
addRelation("author.@info.93",&wrapper_rel_154_author_info_93,false,false);
addRelation("author.@info.94",&wrapper_rel_155_author_info_94,false,false);
addRelation("author.@info.95",&wrapper_rel_156_author_info_95,false,false);
addRelation("author.@info.96",&wrapper_rel_157_author_info_96,false,false);
addRelation("author.@info.97",&wrapper_rel_158_author_info_97,false,false);
addRelation("author.@info.98",&wrapper_rel_159_author_info_98,false,false);
addRelation("author.@info.99",&wrapper_rel_160_author_info_99,false,false);
addRelation("inv_0.@info.1",&wrapper_rel_161_inv_0_info_1,false,false);
addRelation("inv_0.@info.10",&wrapper_rel_162_inv_0_info_10,false,false);
addRelation("inv_0.@info.11",&wrapper_rel_163_inv_0_info_11,false,false);
addRelation("inv_0.@info.12",&wrapper_rel_164_inv_0_info_12,false,false);
addRelation("inv_0.@info.13",&wrapper_rel_165_inv_0_info_13,false,false);
addRelation("inv_0.@info.14",&wrapper_rel_166_inv_0_info_14,false,false);
addRelation("inv_0.@info.15",&wrapper_rel_167_inv_0_info_15,false,false);
addRelation("inv_0.@info.16",&wrapper_rel_168_inv_0_info_16,false,false);
addRelation("inv_0.@info.17",&wrapper_rel_169_inv_0_info_17,false,false);
addRelation("inv_0.@info.18",&wrapper_rel_170_inv_0_info_18,false,false);
addRelation("inv_0.@info.19",&wrapper_rel_171_inv_0_info_19,false,false);
addRelation("inv_0.@info.2",&wrapper_rel_172_inv_0_info_2,false,false);
addRelation("inv_0.@info.20",&wrapper_rel_173_inv_0_info_20,false,false);
addRelation("inv_0.@info.21",&wrapper_rel_174_inv_0_info_21,false,false);
addRelation("inv_0.@info.22",&wrapper_rel_175_inv_0_info_22,false,false);
addRelation("inv_0.@info.23",&wrapper_rel_176_inv_0_info_23,false,false);
addRelation("inv_0.@info.24",&wrapper_rel_177_inv_0_info_24,false,false);
addRelation("inv_0.@info.25",&wrapper_rel_178_inv_0_info_25,false,false);
addRelation("inv_0.@info.26",&wrapper_rel_179_inv_0_info_26,false,false);
addRelation("inv_0.@info.27",&wrapper_rel_180_inv_0_info_27,false,false);
addRelation("inv_0.@info.28",&wrapper_rel_181_inv_0_info_28,false,false);
addRelation("inv_0.@info.29",&wrapper_rel_182_inv_0_info_29,false,false);
addRelation("inv_0.@info.3",&wrapper_rel_183_inv_0_info_3,false,false);
addRelation("inv_0.@info.30",&wrapper_rel_184_inv_0_info_30,false,false);
addRelation("inv_0.@info.31",&wrapper_rel_185_inv_0_info_31,false,false);
addRelation("inv_0.@info.32",&wrapper_rel_186_inv_0_info_32,false,false);
addRelation("inv_0.@info.33",&wrapper_rel_187_inv_0_info_33,false,false);
addRelation("inv_0.@info.34",&wrapper_rel_188_inv_0_info_34,false,false);
addRelation("inv_0.@info.35",&wrapper_rel_189_inv_0_info_35,false,false);
addRelation("inv_0.@info.36",&wrapper_rel_190_inv_0_info_36,false,false);
addRelation("inv_0.@info.37",&wrapper_rel_191_inv_0_info_37,false,false);
addRelation("inv_0.@info.38",&wrapper_rel_192_inv_0_info_38,false,false);
addRelation("inv_0.@info.39",&wrapper_rel_193_inv_0_info_39,false,false);
addRelation("inv_0.@info.4",&wrapper_rel_194_inv_0_info_4,false,false);
addRelation("inv_0.@info.40",&wrapper_rel_195_inv_0_info_40,false,false);
addRelation("inv_0.@info.41",&wrapper_rel_196_inv_0_info_41,false,false);
addRelation("inv_0.@info.42",&wrapper_rel_197_inv_0_info_42,false,false);
addRelation("inv_0.@info.43",&wrapper_rel_198_inv_0_info_43,false,false);
addRelation("inv_0.@info.44",&wrapper_rel_199_inv_0_info_44,false,false);
addRelation("inv_0.@info.45",&wrapper_rel_200_inv_0_info_45,false,false);
addRelation("inv_0.@info.46",&wrapper_rel_201_inv_0_info_46,false,false);
addRelation("inv_0.@info.47",&wrapper_rel_202_inv_0_info_47,false,false);
addRelation("inv_0.@info.48",&wrapper_rel_203_inv_0_info_48,false,false);
addRelation("inv_0.@info.49",&wrapper_rel_204_inv_0_info_49,false,false);
addRelation("inv_0.@info.5",&wrapper_rel_205_inv_0_info_5,false,false);
addRelation("inv_0.@info.50",&wrapper_rel_206_inv_0_info_50,false,false);
addRelation("inv_0.@info.51",&wrapper_rel_207_inv_0_info_51,false,false);
addRelation("inv_0.@info.52",&wrapper_rel_208_inv_0_info_52,false,false);
addRelation("inv_0.@info.53",&wrapper_rel_209_inv_0_info_53,false,false);
addRelation("inv_0.@info.54",&wrapper_rel_210_inv_0_info_54,false,false);
addRelation("inv_0.@info.55",&wrapper_rel_211_inv_0_info_55,false,false);
addRelation("inv_0.@info.56",&wrapper_rel_212_inv_0_info_56,false,false);
addRelation("inv_0.@info.57",&wrapper_rel_213_inv_0_info_57,false,false);
addRelation("inv_0.@info.58",&wrapper_rel_214_inv_0_info_58,false,false);
addRelation("inv_0.@info.59",&wrapper_rel_215_inv_0_info_59,false,false);
addRelation("inv_0.@info.6",&wrapper_rel_216_inv_0_info_6,false,false);
addRelation("inv_0.@info.60",&wrapper_rel_217_inv_0_info_60,false,false);
addRelation("inv_0.@info.61",&wrapper_rel_218_inv_0_info_61,false,false);
addRelation("inv_0.@info.62",&wrapper_rel_219_inv_0_info_62,false,false);
addRelation("inv_0.@info.63",&wrapper_rel_220_inv_0_info_63,false,false);
addRelation("inv_0.@info.64",&wrapper_rel_221_inv_0_info_64,false,false);
addRelation("inv_0.@info.65",&wrapper_rel_222_inv_0_info_65,false,false);
addRelation("inv_0.@info.66",&wrapper_rel_223_inv_0_info_66,false,false);
addRelation("inv_0.@info.67",&wrapper_rel_224_inv_0_info_67,false,false);
addRelation("inv_0.@info.68",&wrapper_rel_225_inv_0_info_68,false,false);
addRelation("inv_0.@info.69",&wrapper_rel_226_inv_0_info_69,false,false);
addRelation("inv_0.@info.7",&wrapper_rel_227_inv_0_info_7,false,false);
addRelation("inv_0.@info.70",&wrapper_rel_228_inv_0_info_70,false,false);
addRelation("inv_0.@info.8",&wrapper_rel_229_inv_0_info_8,false,false);
addRelation("inv_0.@info.9",&wrapper_rel_230_inv_0_info_9,false,false);
}
~Sf_souffle_small() {
}
private:
void runFunction(std::string inputDirectory = ".", std::string outputDirectory = ".", size_t stratumIndex = (size_t) -1, bool performIO = false) {
SignalHandler::instance()->set();
std::atomic<size_t> iter(0);

#if defined(_OPENMP)
if (getNumThreads() > 0) {omp_set_num_threads(getNumThreads());}
#endif

// -- query evaluation --
/* BEGIN STRATUM 0 */
[&]() {
if (performIO) {
try {std::map<std::string, std::string> directiveMap({{"IO","file"},{"filename","./Iauthor.facts"},{"name","Iauthor"}});
if (!inputDirectory.empty() && directiveMap["IO"] == "file" && directiveMap["filename"].front() != '/') {directiveMap["filename"] = inputDirectory + "/" + directiveMap["filename"];}
IODirectives ioDirectives(directiveMap);
IOSystem::getInstance().getReader(std::vector<bool>({1,1,0,0}), symTable, ioDirectives, true)->readAll(*rel_1_Iauthor);
} catch (std::exception& e) {std::cerr << "Error loading data: " << e.what() << '\n';}
}
}();
/* END STRATUM 0 */
/* BEGIN STRATUM 1 */
[&]() {
if (performIO) {
try {std::map<std::string, std::string> directiveMap({{"IO","file"},{"filename","./Rule.facts"},{"name","Rule"}});
if (!inputDirectory.empty() && directiveMap["IO"] == "file" && directiveMap["filename"].front() != '/') {directiveMap["filename"] = inputDirectory + "/" + directiveMap["filename"];}
IODirectives ioDirectives(directiveMap);
IOSystem::getInstance().getReader(std::vector<bool>({0,0,0}), symTable, ioDirectives, true)->readAll(*rel_2_Rule);
} catch (std::exception& e) {std::cerr << "Error loading data: " << e.what() << '\n';}
}
}();
/* END STRATUM 1 */
/* BEGIN STRATUM 2 */
[&]() {
if (performIO) {
try {std::map<std::string, std::string> directiveMap({{"IO","file"},{"filename","./genre.facts"},{"name","genre"}});
if (!inputDirectory.empty() && directiveMap["IO"] == "file" && directiveMap["filename"].front() != '/') {directiveMap["filename"] = inputDirectory + "/" + directiveMap["filename"];}
IODirectives ioDirectives(directiveMap);
IOSystem::getInstance().getReader(std::vector<bool>({1,1,0,0}), symTable, ioDirectives, true)->readAll(*rel_3_genre);
} catch (std::exception& e) {std::cerr << "Error loading data: " << e.what() << '\n';}
}
}();
/* END STRATUM 2 */
/* BEGIN STRATUM 3 */
[&]() {
if (performIO) {
try {std::map<std::string, std::string> directiveMap({{"IO","file"},{"filename","./precededBy.facts"},{"name","precededBy"}});
if (!inputDirectory.empty() && directiveMap["IO"] == "file" && directiveMap["filename"].front() != '/') {directiveMap["filename"] = inputDirectory + "/" + directiveMap["filename"];}
IODirectives ioDirectives(directiveMap);
IOSystem::getInstance().getReader(std::vector<bool>({1,1,0,0}), symTable, ioDirectives, true)->readAll(*rel_4_precededBy);
} catch (std::exception& e) {std::cerr << "Error loading data: " << e.what() << '\n';}
}
}();
/* END STRATUM 3 */
/* BEGIN STRATUM 4 */
[&]() {
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,1,(max(@level_num_0,@level_num_1)+1)) :- 
   Rule(0,_,@level_num_0),
   precededBy(v0,v1,_,@level_num_1).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [23:1-23:46])_");
if(!(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(0),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(RamDomain(1)),static_cast<RamDomain>((std::max({env0[2], env1[3], })) + (RamDomain(1)))}});
rel_5_inv_0->insert(tuple,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,2,(max(@level_num_0,@level_num_1)+1)) :- 
   Rule(1,_,@level_num_0),
   precededBy(v1,v0,_,@level_num_1).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [24:1-24:46])_");
if(!(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(1),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(2)),static_cast<RamDomain>((std::max({env0[2], env1[3], })) + (RamDomain(1)))}});
rel_5_inv_0->insert(tuple,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,3,(max(@level_num_0,@level_num_1)+1)) :- 
   Rule(2,_,@level_num_0),
   genre(v0,v1,_,@level_num_1).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [25:1-25:41])_");
if(!(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(2),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_3_genre) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(RamDomain(3)),static_cast<RamDomain>((std::max({env0[2], env1[3], })) + (RamDomain(1)))}});
rel_5_inv_0->insert(tuple,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,4,(max(@level_num_0,@level_num_1)+1)) :- 
   Rule(3,_,@level_num_0),
   genre(v1,v0,_,@level_num_1).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [26:1-26:41])_");
if(!(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(3),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_3_genre) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(4)),static_cast<RamDomain>((std::max({env0[2], env1[3], })) + (RamDomain(1)))}});
rel_5_inv_0->insert(tuple,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,6,(max(@level_num_0,@level_num_1)+1)) :- 
   Rule(8,_,@level_num_0),
   precededBy(v0,v1,_,@level_num_1).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [28:1-28:66])_");
if(!(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(8),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(RamDomain(6)),static_cast<RamDomain>((std::max({env0[2], env1[3], })) + (RamDomain(1)))}});
rel_5_inv_0->insert(tuple,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,7,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(9,_,@level_num_0),
   precededBy(v0,v1,_,@level_num_1),
   precededBy(v1,v0,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [29:1-29:66])_");
if(!(rel_4_precededBy->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(9),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{env1[1],env1[0],0,0}});
auto range = rel_4_precededBy->equalRange_3(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(RamDomain(7)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_5_inv_0->insert(tuple,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,8,(max(@level_num_0,@level_num_1)+1)) :- 
   Rule(10,_,@level_num_0),
   precededBy(v1,v0,_,@level_num_1).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [30:1-30:67])_");
if(!(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(10),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(8)),static_cast<RamDomain>((std::max({env0[2], env1[3], })) + (RamDomain(1)))}});
rel_5_inv_0->insert(tuple,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,9,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(11,_,@level_num_0),
   precededBy(v1,v0,_,@level_num_1),
   precededBy(v0,v1,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [31:1-31:67])_");
if(!(rel_4_precededBy->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(11),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{env1[1],env1[0],0,0}});
auto range = rel_4_precededBy->equalRange_3(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(9)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_5_inv_0->insert(tuple,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,10,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(12,_,@level_num_0),
   precededBy(v2,v1,_,@level_num_1),
   precededBy(v0,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [32:1-32:67])_");
if(!(rel_4_precededBy->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(12),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{0,env1[0],0,0}});
auto range = rel_4_precededBy->equalRange_2(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(RamDomain(10)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_5_inv_0->insert(tuple,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,11,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(13,_,@level_num_0),
   precededBy(v1,v2,_,@level_num_1),
   precededBy(v2,v0,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [33:1-33:67])_");
if(!(rel_4_precededBy->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(13),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{env1[1],0,0,0}});
auto range = rel_4_precededBy->equalRange_1(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(11)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_5_inv_0->insert(tuple,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,12,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(14,_,@level_num_0),
   precededBy(v2,v0,_,@level_num_1),
   precededBy(v1,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [34:1-34:67])_");
if(!(rel_4_precededBy->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(14),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{0,env1[0],0,0}});
auto range = rel_4_precededBy->equalRange_2(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(RamDomain(12)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_5_inv_0->insert(tuple,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,13,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(15,_,@level_num_0),
   precededBy(v2,v0,_,@level_num_1),
   precededBy(v2,v1,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [35:1-35:67])_");
if(!(rel_4_precededBy->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(15),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{env1[0],0,0,0}});
auto range = rel_4_precededBy->equalRange_1(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(RamDomain(13)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_5_inv_0->insert(tuple,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,14,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(16,_,@level_num_0),
   precededBy(v0,v2,_,@level_num_1),
   precededBy(v1,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [36:1-36:67])_");
if(!(rel_4_precededBy->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(16),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{0,env1[1],0,0}});
auto range = rel_4_precededBy->equalRange_2(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(RamDomain(14)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_5_inv_0->insert(tuple,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,15,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(17,_,@level_num_0),
   precededBy(v0,v2,_,@level_num_1),
   precededBy(v2,v1,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [37:1-37:67])_");
if(!(rel_4_precededBy->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(17),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{env1[1],0,0,0}});
auto range = rel_4_precededBy->equalRange_1(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(RamDomain(15)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_5_inv_0->insert(tuple,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,16,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(18,_,@level_num_0),
   precededBy(v2,v1,_,@level_num_1),
   precededBy(v2,v0,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [38:1-38:67])_");
if(!(rel_4_precededBy->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(18),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{env1[0],0,0,0}});
auto range = rel_4_precededBy->equalRange_1(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(RamDomain(16)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_5_inv_0->insert(tuple,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,17,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(19,_,@level_num_0),
   precededBy(v1,v2,_,@level_num_1),
   precededBy(v0,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [39:1-39:67])_");
if(!(rel_4_precededBy->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(19),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{0,env1[1],0,0}});
auto range = rel_4_precededBy->equalRange_2(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(17)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_5_inv_0->insert(tuple,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,18,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(20,_,@level_num_0),
   precededBy(v0,v1,_,@level_num_1),
   genre(v0,v1,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [40:1-40:62])_");
if(!(rel_3_genre->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(20),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{env1[0],env1[1],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(RamDomain(18)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_5_inv_0->insert(tuple,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,19,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(21,_,@level_num_0),
   precededBy(v0,v1,_,@level_num_1),
   genre(v1,v0,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [41:1-41:62])_");
if(!(rel_3_genre->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(21),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{env1[1],env1[0],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(RamDomain(19)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_5_inv_0->insert(tuple,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,20,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(22,_,@level_num_0),
   precededBy(v1,v0,_,@level_num_1),
   genre(v1,v0,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [42:1-42:62])_");
if(!(rel_3_genre->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(22),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{env1[0],env1[1],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(20)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_5_inv_0->insert(tuple,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,21,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(23,_,@level_num_0),
   precededBy(v1,v0,_,@level_num_1),
   genre(v0,v1,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [43:1-43:62])_");
if(!(rel_3_genre->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(23),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{env1[1],env1[0],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(21)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_5_inv_0->insert(tuple,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,22,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(24,_,@level_num_0),
   precededBy(v2,v1,_,@level_num_1),
   genre(v0,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [44:1-44:62])_");
if(!(rel_3_genre->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(24),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{0,env1[0],0,0}});
auto range = rel_3_genre->equalRange_2(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(RamDomain(22)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_5_inv_0->insert(tuple,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,23,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(25,_,@level_num_0),
   precededBy(v1,v2,_,@level_num_1),
   genre(v2,v0,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [45:1-45:62])_");
if(!(rel_3_genre->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(25),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{env1[1],0,0,0}});
auto range = rel_3_genre->equalRange_1(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(23)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_5_inv_0->insert(tuple,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,24,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(26,_,@level_num_0),
   precededBy(v2,v0,_,@level_num_1),
   genre(v1,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [46:1-46:62])_");
if(!(rel_3_genre->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(26),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{0,env1[0],0,0}});
auto range = rel_3_genre->equalRange_2(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(RamDomain(24)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_5_inv_0->insert(tuple,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,25,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(27,_,@level_num_0),
   precededBy(v2,v0,_,@level_num_1),
   genre(v2,v1,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [47:1-47:62])_");
if(!(rel_3_genre->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(27),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{env1[0],0,0,0}});
auto range = rel_3_genre->equalRange_1(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(RamDomain(25)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_5_inv_0->insert(tuple,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,26,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(28,_,@level_num_0),
   precededBy(v0,v2,_,@level_num_1),
   genre(v1,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [48:1-48:62])_");
if(!(rel_3_genre->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(28),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{0,env1[1],0,0}});
auto range = rel_3_genre->equalRange_2(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(RamDomain(26)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_5_inv_0->insert(tuple,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,27,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(29,_,@level_num_0),
   precededBy(v0,v2,_,@level_num_1),
   genre(v2,v1,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [49:1-49:62])_");
if(!(rel_3_genre->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(29),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{env1[1],0,0,0}});
auto range = rel_3_genre->equalRange_1(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(RamDomain(27)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_5_inv_0->insert(tuple,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,28,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(30,_,@level_num_0),
   precededBy(v2,v1,_,@level_num_1),
   genre(v2,v0,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [50:1-50:62])_");
if(!(rel_3_genre->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(30),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{env1[0],0,0,0}});
auto range = rel_3_genre->equalRange_1(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(RamDomain(28)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_5_inv_0->insert(tuple,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,29,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(31,_,@level_num_0),
   precededBy(v1,v2,_,@level_num_1),
   genre(v0,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [51:1-51:62])_");
if(!(rel_3_genre->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(31),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{0,env1[1],0,0}});
auto range = rel_3_genre->equalRange_2(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(29)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_5_inv_0->insert(tuple,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,40,(max(@level_num_0,@level_num_1)+1)) :- 
   Rule(56,_,@level_num_0),
   genre(v0,v1,_,@level_num_1).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [62:1-62:57])_");
if(!(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(56),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_3_genre) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(RamDomain(40)),static_cast<RamDomain>((std::max({env0[2], env1[3], })) + (RamDomain(1)))}});
rel_5_inv_0->insert(tuple,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,41,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(57,_,@level_num_0),
   genre(v0,v1,_,@level_num_1),
   genre(v1,v0,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [63:1-63:57])_");
if(!(rel_3_genre->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(57),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_3_genre) {
const Tuple<RamDomain,4> key({{env1[1],env1[0],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(RamDomain(41)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_5_inv_0->insert(tuple,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,42,(max(@level_num_0,@level_num_1)+1)) :- 
   Rule(58,_,@level_num_0),
   genre(v1,v0,_,@level_num_1).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [64:1-64:57])_");
if(!(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(58),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_3_genre) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(42)),static_cast<RamDomain>((std::max({env0[2], env1[3], })) + (RamDomain(1)))}});
rel_5_inv_0->insert(tuple,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,43,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(59,_,@level_num_0),
   genre(v1,v0,_,@level_num_1),
   genre(v0,v1,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [65:1-65:57])_");
if(!(rel_3_genre->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(59),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_3_genre) {
const Tuple<RamDomain,4> key({{env1[1],env1[0],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(43)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_5_inv_0->insert(tuple,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,44,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(60,_,@level_num_0),
   genre(v2,v1,_,@level_num_1),
   genre(v0,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [66:1-66:57])_");
if(!(rel_3_genre->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(60),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_3_genre) {
const Tuple<RamDomain,4> key({{0,env1[0],0,0}});
auto range = rel_3_genre->equalRange_2(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(RamDomain(44)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_5_inv_0->insert(tuple,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,45,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(61,_,@level_num_0),
   genre(v1,v2,_,@level_num_1),
   genre(v2,v0,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [67:1-67:57])_");
if(!(rel_3_genre->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(61),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_3_genre) {
const Tuple<RamDomain,4> key({{env1[1],0,0,0}});
auto range = rel_3_genre->equalRange_1(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(45)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_5_inv_0->insert(tuple,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,46,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(62,_,@level_num_0),
   genre(v2,v0,_,@level_num_1),
   genre(v1,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [68:1-68:57])_");
if(!(rel_3_genre->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(62),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_3_genre) {
const Tuple<RamDomain,4> key({{0,env1[0],0,0}});
auto range = rel_3_genre->equalRange_2(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(RamDomain(46)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_5_inv_0->insert(tuple,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,47,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(63,_,@level_num_0),
   genre(v2,v0,_,@level_num_1),
   genre(v2,v1,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [69:1-69:57])_");
if(!(rel_3_genre->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(63),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_3_genre) {
const Tuple<RamDomain,4> key({{env1[0],0,0,0}});
auto range = rel_3_genre->equalRange_1(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(RamDomain(47)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_5_inv_0->insert(tuple,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,48,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(64,_,@level_num_0),
   genre(v0,v2,_,@level_num_1),
   genre(v1,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [70:1-70:57])_");
if(!(rel_3_genre->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(64),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_3_genre) {
const Tuple<RamDomain,4> key({{0,env1[1],0,0}});
auto range = rel_3_genre->equalRange_2(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(RamDomain(48)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_5_inv_0->insert(tuple,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,49,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(65,_,@level_num_0),
   genre(v0,v2,_,@level_num_1),
   genre(v2,v1,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [71:1-71:57])_");
if(!(rel_3_genre->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(65),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_3_genre) {
const Tuple<RamDomain,4> key({{env1[1],0,0,0}});
auto range = rel_3_genre->equalRange_1(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(RamDomain(49)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_5_inv_0->insert(tuple,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,50,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(66,_,@level_num_0),
   genre(v2,v1,_,@level_num_1),
   genre(v2,v0,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [72:1-72:57])_");
if(!(rel_3_genre->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(66),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_3_genre) {
const Tuple<RamDomain,4> key({{env1[0],0,0,0}});
auto range = rel_3_genre->equalRange_1(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(RamDomain(50)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_5_inv_0->insert(tuple,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,51,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(67,_,@level_num_0),
   genre(v1,v2,_,@level_num_1),
   genre(v0,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [73:1-73:57])_");
if(!(rel_3_genre->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(67),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_3_genre) {
const Tuple<RamDomain,4> key({{0,env1[1],0,0}});
auto range = rel_3_genre->equalRange_2(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(51)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_5_inv_0->insert(tuple,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
rel_6_delta_inv_0->insertAll(*rel_5_inv_0);
iter = 0;
for(;;) {
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,5,(max(@level_num_0,@level_num_1)+1)) :- 
   Rule(7,_,@level_num_0),
   inv_0(v1,v0,_,@level_num_1).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [27:1-27:41])_");
if(!(rel_6_delta_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(7),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt,rel_6_delta_inv_0->createContext());
CREATE_OP_CONTEXT(rel_7_new_inv_0_op_ctxt,rel_7_new_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_6_delta_inv_0) {
if( !([&]() -> bool {
auto existenceCheck = rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{env1[1],env1[0],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({env0[2], env1[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(5)),static_cast<RamDomain>((std::max({env0[2], env1[3], })) + (RamDomain(1)))}});
rel_7_new_inv_0->insert(tuple,READ_OP_CONTEXT(rel_7_new_inv_0_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,30,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(45,_,@level_num_0),
   precededBy(v0,v1,_,@level_num_1),
   inv_0(v1,v0,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [52:1-52:62])_");
if(!(rel_6_delta_inv_0->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(45),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt,rel_6_delta_inv_0->createContext());
CREATE_OP_CONTEXT(rel_7_new_inv_0_op_ctxt,rel_7_new_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{env1[1],env1[0],0,0}});
auto range = rel_6_delta_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{env1[0],env1[1],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(RamDomain(30)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_7_new_inv_0->insert(tuple,READ_OP_CONTEXT(rel_7_new_inv_0_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,31,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(46,_,@level_num_0),
   precededBy(v1,v0,_,@level_num_1),
   inv_0(v1,v0,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [53:1-53:62])_");
if(!(rel_6_delta_inv_0->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(46),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt,rel_6_delta_inv_0->createContext());
CREATE_OP_CONTEXT(rel_7_new_inv_0_op_ctxt,rel_7_new_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{env1[0],env1[1],0,0}});
auto range = rel_6_delta_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{env1[1],env1[0],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(31)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_7_new_inv_0->insert(tuple,READ_OP_CONTEXT(rel_7_new_inv_0_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,32,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(48,_,@level_num_0),
   precededBy(v2,v1,_,@level_num_1),
   inv_0(v0,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [54:1-54:62])_");
if(!(rel_6_delta_inv_0->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(48),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt,rel_6_delta_inv_0->createContext());
CREATE_OP_CONTEXT(rel_7_new_inv_0_op_ctxt,rel_7_new_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{0,env1[0],0,0}});
auto range = rel_6_delta_inv_0->equalRange_2(key,READ_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{env2[0],env1[1],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(RamDomain(32)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_7_new_inv_0->insert(tuple,READ_OP_CONTEXT(rel_7_new_inv_0_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,33,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(49,_,@level_num_0),
   precededBy(v1,v2,_,@level_num_1),
   inv_0(v2,v0,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [55:1-55:62])_");
if(!(rel_6_delta_inv_0->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(49),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt,rel_6_delta_inv_0->createContext());
CREATE_OP_CONTEXT(rel_7_new_inv_0_op_ctxt,rel_7_new_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{env1[1],0,0,0}});
auto range = rel_6_delta_inv_0->equalRange_1(key,READ_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{env2[1],env1[0],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(33)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_7_new_inv_0->insert(tuple,READ_OP_CONTEXT(rel_7_new_inv_0_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,34,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(50,_,@level_num_0),
   precededBy(v2,v0,_,@level_num_1),
   inv_0(v1,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [56:1-56:62])_");
if(!(rel_6_delta_inv_0->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(50),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt,rel_6_delta_inv_0->createContext());
CREATE_OP_CONTEXT(rel_7_new_inv_0_op_ctxt,rel_7_new_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{0,env1[0],0,0}});
auto range = rel_6_delta_inv_0->equalRange_2(key,READ_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{env1[1],env2[0],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(RamDomain(34)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_7_new_inv_0->insert(tuple,READ_OP_CONTEXT(rel_7_new_inv_0_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,35,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(51,_,@level_num_0),
   precededBy(v2,v0,_,@level_num_1),
   inv_0(v2,v1,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [57:1-57:62])_");
if(!(rel_6_delta_inv_0->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(51),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt,rel_6_delta_inv_0->createContext());
CREATE_OP_CONTEXT(rel_7_new_inv_0_op_ctxt,rel_7_new_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{env1[0],0,0,0}});
auto range = rel_6_delta_inv_0->equalRange_1(key,READ_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{env1[1],env2[1],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(RamDomain(35)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_7_new_inv_0->insert(tuple,READ_OP_CONTEXT(rel_7_new_inv_0_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,36,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(52,_,@level_num_0),
   precededBy(v0,v2,_,@level_num_1),
   inv_0(v1,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [58:1-58:62])_");
if(!(rel_6_delta_inv_0->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(52),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt,rel_6_delta_inv_0->createContext());
CREATE_OP_CONTEXT(rel_7_new_inv_0_op_ctxt,rel_7_new_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{0,env1[1],0,0}});
auto range = rel_6_delta_inv_0->equalRange_2(key,READ_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{env1[0],env2[0],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(RamDomain(36)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_7_new_inv_0->insert(tuple,READ_OP_CONTEXT(rel_7_new_inv_0_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,37,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(53,_,@level_num_0),
   precededBy(v0,v2,_,@level_num_1),
   inv_0(v2,v1,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [59:1-59:62])_");
if(!(rel_6_delta_inv_0->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(53),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt,rel_6_delta_inv_0->createContext());
CREATE_OP_CONTEXT(rel_7_new_inv_0_op_ctxt,rel_7_new_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{env1[1],0,0,0}});
auto range = rel_6_delta_inv_0->equalRange_1(key,READ_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{env1[0],env2[1],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(RamDomain(37)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_7_new_inv_0->insert(tuple,READ_OP_CONTEXT(rel_7_new_inv_0_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,38,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(54,_,@level_num_0),
   precededBy(v2,v1,_,@level_num_1),
   inv_0(v2,v0,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [60:1-60:62])_");
if(!(rel_6_delta_inv_0->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(54),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt,rel_6_delta_inv_0->createContext());
CREATE_OP_CONTEXT(rel_7_new_inv_0_op_ctxt,rel_7_new_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{env1[0],0,0,0}});
auto range = rel_6_delta_inv_0->equalRange_1(key,READ_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{env2[1],env1[1],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(RamDomain(38)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_7_new_inv_0->insert(tuple,READ_OP_CONTEXT(rel_7_new_inv_0_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,39,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(55,_,@level_num_0),
   precededBy(v1,v2,_,@level_num_1),
   inv_0(v0,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [61:1-61:62])_");
if(!(rel_6_delta_inv_0->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(55),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt,rel_6_delta_inv_0->createContext());
CREATE_OP_CONTEXT(rel_7_new_inv_0_op_ctxt,rel_7_new_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{0,env1[1],0,0}});
auto range = rel_6_delta_inv_0->equalRange_2(key,READ_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{env2[0],env1[0],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(39)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_7_new_inv_0->insert(tuple,READ_OP_CONTEXT(rel_7_new_inv_0_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,52,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(81,_,@level_num_0),
   genre(v0,v1,_,@level_num_1),
   inv_0(v1,v0,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [74:1-74:57])_");
if(!(rel_6_delta_inv_0->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(81),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt,rel_6_delta_inv_0->createContext());
CREATE_OP_CONTEXT(rel_7_new_inv_0_op_ctxt,rel_7_new_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_3_genre) {
const Tuple<RamDomain,4> key({{env1[1],env1[0],0,0}});
auto range = rel_6_delta_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{env1[0],env1[1],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(RamDomain(52)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_7_new_inv_0->insert(tuple,READ_OP_CONTEXT(rel_7_new_inv_0_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,53,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(82,_,@level_num_0),
   genre(v1,v0,_,@level_num_1),
   inv_0(v1,v0,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [75:1-75:57])_");
if(!(rel_6_delta_inv_0->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(82),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt,rel_6_delta_inv_0->createContext());
CREATE_OP_CONTEXT(rel_7_new_inv_0_op_ctxt,rel_7_new_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_3_genre) {
const Tuple<RamDomain,4> key({{env1[0],env1[1],0,0}});
auto range = rel_6_delta_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{env1[1],env1[0],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(53)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_7_new_inv_0->insert(tuple,READ_OP_CONTEXT(rel_7_new_inv_0_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,54,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(84,_,@level_num_0),
   genre(v2,v1,_,@level_num_1),
   inv_0(v0,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [76:1-76:57])_");
if(!(rel_6_delta_inv_0->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(84),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt,rel_6_delta_inv_0->createContext());
CREATE_OP_CONTEXT(rel_7_new_inv_0_op_ctxt,rel_7_new_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_3_genre) {
const Tuple<RamDomain,4> key({{0,env1[0],0,0}});
auto range = rel_6_delta_inv_0->equalRange_2(key,READ_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{env2[0],env1[1],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(RamDomain(54)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_7_new_inv_0->insert(tuple,READ_OP_CONTEXT(rel_7_new_inv_0_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,55,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(85,_,@level_num_0),
   genre(v1,v2,_,@level_num_1),
   inv_0(v2,v0,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [77:1-77:57])_");
if(!(rel_6_delta_inv_0->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(85),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt,rel_6_delta_inv_0->createContext());
CREATE_OP_CONTEXT(rel_7_new_inv_0_op_ctxt,rel_7_new_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_3_genre) {
const Tuple<RamDomain,4> key({{env1[1],0,0,0}});
auto range = rel_6_delta_inv_0->equalRange_1(key,READ_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{env2[1],env1[0],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(55)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_7_new_inv_0->insert(tuple,READ_OP_CONTEXT(rel_7_new_inv_0_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,56,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(86,_,@level_num_0),
   genre(v2,v0,_,@level_num_1),
   inv_0(v1,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [78:1-78:57])_");
if(!(rel_6_delta_inv_0->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(86),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt,rel_6_delta_inv_0->createContext());
CREATE_OP_CONTEXT(rel_7_new_inv_0_op_ctxt,rel_7_new_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_3_genre) {
const Tuple<RamDomain,4> key({{0,env1[0],0,0}});
auto range = rel_6_delta_inv_0->equalRange_2(key,READ_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{env1[1],env2[0],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(RamDomain(56)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_7_new_inv_0->insert(tuple,READ_OP_CONTEXT(rel_7_new_inv_0_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,57,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(87,_,@level_num_0),
   genre(v2,v0,_,@level_num_1),
   inv_0(v2,v1,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [79:1-79:57])_");
if(!(rel_6_delta_inv_0->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(87),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt,rel_6_delta_inv_0->createContext());
CREATE_OP_CONTEXT(rel_7_new_inv_0_op_ctxt,rel_7_new_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_3_genre) {
const Tuple<RamDomain,4> key({{env1[0],0,0,0}});
auto range = rel_6_delta_inv_0->equalRange_1(key,READ_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{env1[1],env2[1],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(RamDomain(57)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_7_new_inv_0->insert(tuple,READ_OP_CONTEXT(rel_7_new_inv_0_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,58,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(88,_,@level_num_0),
   genre(v0,v2,_,@level_num_1),
   inv_0(v1,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [80:1-80:57])_");
if(!(rel_6_delta_inv_0->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(88),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt,rel_6_delta_inv_0->createContext());
CREATE_OP_CONTEXT(rel_7_new_inv_0_op_ctxt,rel_7_new_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_3_genre) {
const Tuple<RamDomain,4> key({{0,env1[1],0,0}});
auto range = rel_6_delta_inv_0->equalRange_2(key,READ_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{env1[0],env2[0],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(RamDomain(58)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_7_new_inv_0->insert(tuple,READ_OP_CONTEXT(rel_7_new_inv_0_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,59,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(89,_,@level_num_0),
   genre(v0,v2,_,@level_num_1),
   inv_0(v2,v1,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [81:1-81:57])_");
if(!(rel_6_delta_inv_0->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(89),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt,rel_6_delta_inv_0->createContext());
CREATE_OP_CONTEXT(rel_7_new_inv_0_op_ctxt,rel_7_new_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_3_genre) {
const Tuple<RamDomain,4> key({{env1[1],0,0,0}});
auto range = rel_6_delta_inv_0->equalRange_1(key,READ_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{env1[0],env2[1],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(RamDomain(59)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_7_new_inv_0->insert(tuple,READ_OP_CONTEXT(rel_7_new_inv_0_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,60,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(90,_,@level_num_0),
   genre(v2,v1,_,@level_num_1),
   inv_0(v2,v0,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [82:1-82:57])_");
if(!(rel_6_delta_inv_0->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(90),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt,rel_6_delta_inv_0->createContext());
CREATE_OP_CONTEXT(rel_7_new_inv_0_op_ctxt,rel_7_new_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_3_genre) {
const Tuple<RamDomain,4> key({{env1[0],0,0,0}});
auto range = rel_6_delta_inv_0->equalRange_1(key,READ_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{env2[1],env1[1],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(RamDomain(60)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_7_new_inv_0->insert(tuple,READ_OP_CONTEXT(rel_7_new_inv_0_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,61,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(91,_,@level_num_0),
   genre(v1,v2,_,@level_num_1),
   inv_0(v0,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [83:1-83:57])_");
if(!(rel_6_delta_inv_0->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(91),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt,rel_6_delta_inv_0->createContext());
CREATE_OP_CONTEXT(rel_7_new_inv_0_op_ctxt,rel_7_new_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_3_genre) {
const Tuple<RamDomain,4> key({{0,env1[1],0,0}});
auto range = rel_6_delta_inv_0->equalRange_2(key,READ_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{env2[0],env1[0],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(61)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_7_new_inv_0->insert(tuple,READ_OP_CONTEXT(rel_7_new_inv_0_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,62,(max(@level_num_0,@level_num_1)+1)) :- 
   Rule(118,_,@level_num_0),
   inv_0(v1,v0,_,@level_num_1).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [84:1-84:58])_");
if(!(rel_6_delta_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(118),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt,rel_6_delta_inv_0->createContext());
CREATE_OP_CONTEXT(rel_7_new_inv_0_op_ctxt,rel_7_new_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_6_delta_inv_0) {
if( !([&]() -> bool {
auto existenceCheck = rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{env1[1],env1[0],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({env0[2], env1[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(62)),static_cast<RamDomain>((std::max({env0[2], env1[3], })) + (RamDomain(1)))}});
rel_7_new_inv_0->insert(tuple,READ_OP_CONTEXT(rel_7_new_inv_0_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,63,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(120,_,@level_num_0),
   inv_0(v2,v1,_,@level_num_1),
   inv_0(v0,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [85:1-85:58])_");
if(!(rel_5_inv_0->empty()) && !(rel_6_delta_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(120),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt,rel_6_delta_inv_0->createContext());
CREATE_OP_CONTEXT(rel_7_new_inv_0_op_ctxt,rel_7_new_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_6_delta_inv_0) {
const Tuple<RamDomain,4> key({{0,env1[0],0,0}});
auto range = rel_5_inv_0->equalRange_2(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( !(!rel_6_delta_inv_0->equalRange_3(Tuple<RamDomain,4>({{env2[0],env1[0],0,0}}),READ_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt)).empty()) && !([&]() -> bool {
auto existenceCheck = rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{env2[0],env1[1],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(RamDomain(63)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_7_new_inv_0->insert(tuple,READ_OP_CONTEXT(rel_7_new_inv_0_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,63,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(120,_,@level_num_0),
   inv_0(v2,v1,_,@level_num_1),
   inv_0(v0,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [85:1-85:58])_");
if(!(rel_6_delta_inv_0->empty()) && !(rel_5_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(120),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt,rel_6_delta_inv_0->createContext());
CREATE_OP_CONTEXT(rel_7_new_inv_0_op_ctxt,rel_7_new_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_5_inv_0) {
const Tuple<RamDomain,4> key({{0,env1[0],0,0}});
auto range = rel_6_delta_inv_0->equalRange_2(key,READ_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{env2[0],env1[1],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(RamDomain(63)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_7_new_inv_0->insert(tuple,READ_OP_CONTEXT(rel_7_new_inv_0_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,64,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(121,_,@level_num_0),
   inv_0(v1,v2,_,@level_num_1),
   inv_0(v2,v0,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [86:1-86:58])_");
if(!(rel_5_inv_0->empty()) && !(rel_6_delta_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(121),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt,rel_6_delta_inv_0->createContext());
CREATE_OP_CONTEXT(rel_7_new_inv_0_op_ctxt,rel_7_new_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_6_delta_inv_0) {
const Tuple<RamDomain,4> key({{env1[1],0,0,0}});
auto range = rel_5_inv_0->equalRange_1(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( !(!rel_6_delta_inv_0->equalRange_3(Tuple<RamDomain,4>({{env1[1],env2[1],0,0}}),READ_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt)).empty()) && !([&]() -> bool {
auto existenceCheck = rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{env2[1],env1[0],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(64)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_7_new_inv_0->insert(tuple,READ_OP_CONTEXT(rel_7_new_inv_0_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,64,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(121,_,@level_num_0),
   inv_0(v1,v2,_,@level_num_1),
   inv_0(v2,v0,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [86:1-86:58])_");
if(!(rel_6_delta_inv_0->empty()) && !(rel_5_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(121),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt,rel_6_delta_inv_0->createContext());
CREATE_OP_CONTEXT(rel_7_new_inv_0_op_ctxt,rel_7_new_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_5_inv_0) {
const Tuple<RamDomain,4> key({{env1[1],0,0,0}});
auto range = rel_6_delta_inv_0->equalRange_1(key,READ_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{env2[1],env1[0],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(64)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_7_new_inv_0->insert(tuple,READ_OP_CONTEXT(rel_7_new_inv_0_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,65,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(122,_,@level_num_0),
   inv_0(v2,v0,_,@level_num_1),
   inv_0(v1,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [87:1-87:58])_");
if(!(rel_5_inv_0->empty()) && !(rel_6_delta_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(122),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt,rel_6_delta_inv_0->createContext());
CREATE_OP_CONTEXT(rel_7_new_inv_0_op_ctxt,rel_7_new_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_6_delta_inv_0) {
const Tuple<RamDomain,4> key({{0,env1[0],0,0}});
auto range = rel_5_inv_0->equalRange_2(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( !(!rel_6_delta_inv_0->equalRange_3(Tuple<RamDomain,4>({{env2[0],env1[0],0,0}}),READ_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt)).empty()) && !([&]() -> bool {
auto existenceCheck = rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{env1[1],env2[0],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(RamDomain(65)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_7_new_inv_0->insert(tuple,READ_OP_CONTEXT(rel_7_new_inv_0_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,65,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(122,_,@level_num_0),
   inv_0(v2,v0,_,@level_num_1),
   inv_0(v1,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [87:1-87:58])_");
if(!(rel_6_delta_inv_0->empty()) && !(rel_5_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(122),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt,rel_6_delta_inv_0->createContext());
CREATE_OP_CONTEXT(rel_7_new_inv_0_op_ctxt,rel_7_new_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_5_inv_0) {
const Tuple<RamDomain,4> key({{0,env1[0],0,0}});
auto range = rel_6_delta_inv_0->equalRange_2(key,READ_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{env1[1],env2[0],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(RamDomain(65)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_7_new_inv_0->insert(tuple,READ_OP_CONTEXT(rel_7_new_inv_0_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,66,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(123,_,@level_num_0),
   inv_0(v2,v0,_,@level_num_1),
   inv_0(v2,v1,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [88:1-88:58])_");
if(!(rel_5_inv_0->empty()) && !(rel_6_delta_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(123),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt,rel_6_delta_inv_0->createContext());
CREATE_OP_CONTEXT(rel_7_new_inv_0_op_ctxt,rel_7_new_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_6_delta_inv_0) {
const Tuple<RamDomain,4> key({{env1[0],0,0,0}});
auto range = rel_5_inv_0->equalRange_1(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( !(!rel_6_delta_inv_0->equalRange_3(Tuple<RamDomain,4>({{env1[0],env2[1],0,0}}),READ_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt)).empty()) && !([&]() -> bool {
auto existenceCheck = rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{env1[1],env2[1],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(RamDomain(66)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_7_new_inv_0->insert(tuple,READ_OP_CONTEXT(rel_7_new_inv_0_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,66,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(123,_,@level_num_0),
   inv_0(v2,v0,_,@level_num_1),
   inv_0(v2,v1,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [88:1-88:58])_");
if(!(rel_6_delta_inv_0->empty()) && !(rel_5_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(123),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt,rel_6_delta_inv_0->createContext());
CREATE_OP_CONTEXT(rel_7_new_inv_0_op_ctxt,rel_7_new_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_5_inv_0) {
const Tuple<RamDomain,4> key({{env1[0],0,0,0}});
auto range = rel_6_delta_inv_0->equalRange_1(key,READ_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{env1[1],env2[1],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(RamDomain(66)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_7_new_inv_0->insert(tuple,READ_OP_CONTEXT(rel_7_new_inv_0_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,67,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(124,_,@level_num_0),
   inv_0(v0,v2,_,@level_num_1),
   inv_0(v1,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [89:1-89:58])_");
if(!(rel_5_inv_0->empty()) && !(rel_6_delta_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(124),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt,rel_6_delta_inv_0->createContext());
CREATE_OP_CONTEXT(rel_7_new_inv_0_op_ctxt,rel_7_new_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_6_delta_inv_0) {
const Tuple<RamDomain,4> key({{0,env1[1],0,0}});
auto range = rel_5_inv_0->equalRange_2(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( !(!rel_6_delta_inv_0->equalRange_3(Tuple<RamDomain,4>({{env2[0],env1[1],0,0}}),READ_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt)).empty()) && !([&]() -> bool {
auto existenceCheck = rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{env1[0],env2[0],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(RamDomain(67)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_7_new_inv_0->insert(tuple,READ_OP_CONTEXT(rel_7_new_inv_0_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,67,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(124,_,@level_num_0),
   inv_0(v0,v2,_,@level_num_1),
   inv_0(v1,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [89:1-89:58])_");
if(!(rel_6_delta_inv_0->empty()) && !(rel_5_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(124),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt,rel_6_delta_inv_0->createContext());
CREATE_OP_CONTEXT(rel_7_new_inv_0_op_ctxt,rel_7_new_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_5_inv_0) {
const Tuple<RamDomain,4> key({{0,env1[1],0,0}});
auto range = rel_6_delta_inv_0->equalRange_2(key,READ_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{env1[0],env2[0],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(RamDomain(67)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_7_new_inv_0->insert(tuple,READ_OP_CONTEXT(rel_7_new_inv_0_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,68,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(125,_,@level_num_0),
   inv_0(v0,v2,_,@level_num_1),
   inv_0(v2,v1,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [90:1-90:58])_");
if(!(rel_5_inv_0->empty()) && !(rel_6_delta_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(125),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt,rel_6_delta_inv_0->createContext());
CREATE_OP_CONTEXT(rel_7_new_inv_0_op_ctxt,rel_7_new_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_6_delta_inv_0) {
const Tuple<RamDomain,4> key({{env1[1],0,0,0}});
auto range = rel_5_inv_0->equalRange_1(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( !(!rel_6_delta_inv_0->equalRange_3(Tuple<RamDomain,4>({{env1[1],env2[1],0,0}}),READ_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt)).empty()) && !([&]() -> bool {
auto existenceCheck = rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{env1[0],env2[1],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(RamDomain(68)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_7_new_inv_0->insert(tuple,READ_OP_CONTEXT(rel_7_new_inv_0_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,68,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(125,_,@level_num_0),
   inv_0(v0,v2,_,@level_num_1),
   inv_0(v2,v1,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [90:1-90:58])_");
if(!(rel_6_delta_inv_0->empty()) && !(rel_5_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(125),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt,rel_6_delta_inv_0->createContext());
CREATE_OP_CONTEXT(rel_7_new_inv_0_op_ctxt,rel_7_new_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_5_inv_0) {
const Tuple<RamDomain,4> key({{env1[1],0,0,0}});
auto range = rel_6_delta_inv_0->equalRange_1(key,READ_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{env1[0],env2[1],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(RamDomain(68)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_7_new_inv_0->insert(tuple,READ_OP_CONTEXT(rel_7_new_inv_0_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,69,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(126,_,@level_num_0),
   inv_0(v2,v1,_,@level_num_1),
   inv_0(v2,v0,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [91:1-91:58])_");
if(!(rel_5_inv_0->empty()) && !(rel_6_delta_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(126),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt,rel_6_delta_inv_0->createContext());
CREATE_OP_CONTEXT(rel_7_new_inv_0_op_ctxt,rel_7_new_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_6_delta_inv_0) {
const Tuple<RamDomain,4> key({{env1[0],0,0,0}});
auto range = rel_5_inv_0->equalRange_1(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( !(!rel_6_delta_inv_0->equalRange_3(Tuple<RamDomain,4>({{env1[0],env2[1],0,0}}),READ_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt)).empty()) && !([&]() -> bool {
auto existenceCheck = rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{env2[1],env1[1],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(RamDomain(69)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_7_new_inv_0->insert(tuple,READ_OP_CONTEXT(rel_7_new_inv_0_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,69,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(126,_,@level_num_0),
   inv_0(v2,v1,_,@level_num_1),
   inv_0(v2,v0,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [91:1-91:58])_");
if(!(rel_6_delta_inv_0->empty()) && !(rel_5_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(126),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt,rel_6_delta_inv_0->createContext());
CREATE_OP_CONTEXT(rel_7_new_inv_0_op_ctxt,rel_7_new_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_5_inv_0) {
const Tuple<RamDomain,4> key({{env1[0],0,0,0}});
auto range = rel_6_delta_inv_0->equalRange_1(key,READ_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{env2[1],env1[1],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(RamDomain(69)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_7_new_inv_0->insert(tuple,READ_OP_CONTEXT(rel_7_new_inv_0_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,70,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(127,_,@level_num_0),
   inv_0(v1,v2,_,@level_num_1),
   inv_0(v0,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [92:1-92:58])_");
if(!(rel_5_inv_0->empty()) && !(rel_6_delta_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(127),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt,rel_6_delta_inv_0->createContext());
CREATE_OP_CONTEXT(rel_7_new_inv_0_op_ctxt,rel_7_new_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_6_delta_inv_0) {
const Tuple<RamDomain,4> key({{0,env1[1],0,0}});
auto range = rel_5_inv_0->equalRange_2(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( !(!rel_6_delta_inv_0->equalRange_3(Tuple<RamDomain,4>({{env2[0],env1[1],0,0}}),READ_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt)).empty()) && !([&]() -> bool {
auto existenceCheck = rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{env2[0],env1[0],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(70)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_7_new_inv_0->insert(tuple,READ_OP_CONTEXT(rel_7_new_inv_0_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(inv_0(v0,v1,70,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(127,_,@level_num_0),
   inv_0(v1,v2,_,@level_num_1),
   inv_0(v0,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [92:1-92:58])_");
if(!(rel_6_delta_inv_0->empty()) && !(rel_5_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(127),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt,rel_6_delta_inv_0->createContext());
CREATE_OP_CONTEXT(rel_7_new_inv_0_op_ctxt,rel_7_new_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_5_inv_0) {
const Tuple<RamDomain,4> key({{0,env1[1],0,0}});
auto range = rel_6_delta_inv_0->equalRange_2(key,READ_OP_CONTEXT(rel_6_delta_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{env2[0],env1[0],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(70)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_7_new_inv_0->insert(tuple,READ_OP_CONTEXT(rel_7_new_inv_0_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
if(rel_7_new_inv_0->empty()) break;
rel_5_inv_0->insertAll(*rel_7_new_inv_0);
std::swap(rel_6_delta_inv_0, rel_7_new_inv_0);
rel_7_new_inv_0->purge();
iter++;
}
iter = 0;
if (!isHintsProfilingEnabled()) rel_6_delta_inv_0->purge();
if (!isHintsProfilingEnabled()) rel_7_new_inv_0->purge();
if (performIO) {
try {std::map<std::string, std::string> directiveMap({{"IO","file"},{"attributeNames","v0\tv1"},{"filename","./inv_0.csv"},{"name","inv_0"}});
if (!outputDirectory.empty() && directiveMap["IO"] == "file" && directiveMap["filename"].front() != '/') {directiveMap["filename"] = outputDirectory + "/" + directiveMap["filename"];}
IODirectives ioDirectives(directiveMap);
IOSystem::getInstance().getWriter(std::vector<bool>({1,1,0,0}), symTable, ioDirectives, true)->writeAll(*rel_5_inv_0);
} catch (std::exception& e) {std::cerr << e.what();exit(1);}
}
}();
/* END STRATUM 4 */
/* BEGIN STRATUM 5 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author(v0,v1,1,(max(@level_num_0,@level_num_1)+1)) :- 
   Rule(128,_,@level_num_0),
   precededBy(v0,v1,_,@level_num_1).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [93:1-93:49])_");
if(!(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(128),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(RamDomain(1)),static_cast<RamDomain>((std::max({env0[2], env1[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,2,(max(@level_num_0,@level_num_1)+1)) :- 
   Rule(129,_,@level_num_0),
   precededBy(v1,v0,_,@level_num_1).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [94:1-94:49])_");
if(!(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(129),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(2)),static_cast<RamDomain>((std::max({env0[2], env1[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,3,(max(@level_num_0,@level_num_1)+1)) :- 
   Rule(130,_,@level_num_0),
   genre(v0,v1,_,@level_num_1).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [95:1-95:44])_");
if(!(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(130),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_3_genre) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(RamDomain(3)),static_cast<RamDomain>((std::max({env0[2], env1[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,4,(max(@level_num_0,@level_num_1)+1)) :- 
   Rule(131,_,@level_num_0),
   genre(v1,v0,_,@level_num_1).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [96:1-96:44])_");
if(!(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(131),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_3_genre) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(4)),static_cast<RamDomain>((std::max({env0[2], env1[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,5,(max(@level_num_0,@level_num_1)+1)) :- 
   Rule(134,_,@level_num_0),
   inv_0(v0,v1,_,@level_num_1).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [97:1-97:44])_");
if(!(rel_5_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(134),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_5_inv_0) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(RamDomain(5)),static_cast<RamDomain>((std::max({env0[2], env1[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,6,(max(@level_num_0,@level_num_1)+1)) :- 
   Rule(135,_,@level_num_0),
   inv_0(v1,v0,_,@level_num_1).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [98:1-98:44])_");
if(!(rel_5_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(135),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_5_inv_0) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(6)),static_cast<RamDomain>((std::max({env0[2], env1[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,8,(max(@level_num_0,@level_num_1)+1)) :- 
   Rule(138,_,@level_num_0),
   precededBy(v0,v1,_,@level_num_1).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [100:1-100:69])_");
if(!(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(138),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(RamDomain(8)),static_cast<RamDomain>((std::max({env0[2], env1[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,9,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(139,_,@level_num_0),
   precededBy(v0,v1,_,@level_num_1),
   precededBy(v1,v0,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [101:1-101:69])_");
if(!(rel_4_precededBy->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(139),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{env1[1],env1[0],0,0}});
auto range = rel_4_precededBy->equalRange_3(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(RamDomain(9)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,10,(max(@level_num_0,@level_num_1)+1)) :- 
   Rule(140,_,@level_num_0),
   precededBy(v1,v0,_,@level_num_1).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [102:1-102:69])_");
if(!(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(140),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(10)),static_cast<RamDomain>((std::max({env0[2], env1[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,11,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(141,_,@level_num_0),
   precededBy(v1,v0,_,@level_num_1),
   precededBy(v0,v1,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [103:1-103:69])_");
if(!(rel_4_precededBy->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(141),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{env1[1],env1[0],0,0}});
auto range = rel_4_precededBy->equalRange_3(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(11)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,12,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(142,_,@level_num_0),
   precededBy(v2,v1,_,@level_num_1),
   precededBy(v0,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [104:1-104:69])_");
if(!(rel_4_precededBy->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(142),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{0,env1[0],0,0}});
auto range = rel_4_precededBy->equalRange_2(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(RamDomain(12)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,13,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(143,_,@level_num_0),
   precededBy(v1,v2,_,@level_num_1),
   precededBy(v2,v0,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [105:1-105:69])_");
if(!(rel_4_precededBy->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(143),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{env1[1],0,0,0}});
auto range = rel_4_precededBy->equalRange_1(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(13)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,14,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(144,_,@level_num_0),
   precededBy(v2,v0,_,@level_num_1),
   precededBy(v1,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [106:1-106:69])_");
if(!(rel_4_precededBy->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(144),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{0,env1[0],0,0}});
auto range = rel_4_precededBy->equalRange_2(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(RamDomain(14)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,15,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(145,_,@level_num_0),
   precededBy(v2,v0,_,@level_num_1),
   precededBy(v2,v1,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [107:1-107:69])_");
if(!(rel_4_precededBy->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(145),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{env1[0],0,0,0}});
auto range = rel_4_precededBy->equalRange_1(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(RamDomain(15)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,16,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(146,_,@level_num_0),
   precededBy(v0,v2,_,@level_num_1),
   precededBy(v1,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [108:1-108:69])_");
if(!(rel_4_precededBy->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(146),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{0,env1[1],0,0}});
auto range = rel_4_precededBy->equalRange_2(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(RamDomain(16)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,17,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(147,_,@level_num_0),
   precededBy(v0,v2,_,@level_num_1),
   precededBy(v2,v1,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [109:1-109:69])_");
if(!(rel_4_precededBy->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(147),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{env1[1],0,0,0}});
auto range = rel_4_precededBy->equalRange_1(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(RamDomain(17)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,18,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(148,_,@level_num_0),
   precededBy(v2,v1,_,@level_num_1),
   precededBy(v2,v0,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [110:1-110:69])_");
if(!(rel_4_precededBy->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(148),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{env1[0],0,0,0}});
auto range = rel_4_precededBy->equalRange_1(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(RamDomain(18)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,19,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(149,_,@level_num_0),
   precededBy(v1,v2,_,@level_num_1),
   precededBy(v0,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [111:1-111:69])_");
if(!(rel_4_precededBy->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(149),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{0,env1[1],0,0}});
auto range = rel_4_precededBy->equalRange_2(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(19)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,20,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(150,_,@level_num_0),
   precededBy(v0,v1,_,@level_num_1),
   genre(v0,v1,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [112:1-112:64])_");
if(!(rel_3_genre->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(150),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{env1[0],env1[1],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(RamDomain(20)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,21,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(151,_,@level_num_0),
   precededBy(v0,v1,_,@level_num_1),
   genre(v1,v0,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [113:1-113:64])_");
if(!(rel_3_genre->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(151),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{env1[1],env1[0],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(RamDomain(21)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,22,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(152,_,@level_num_0),
   precededBy(v1,v0,_,@level_num_1),
   genre(v1,v0,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [114:1-114:64])_");
if(!(rel_3_genre->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(152),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{env1[0],env1[1],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(22)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,23,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(153,_,@level_num_0),
   precededBy(v1,v0,_,@level_num_1),
   genre(v0,v1,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [115:1-115:64])_");
if(!(rel_3_genre->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(153),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{env1[1],env1[0],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(23)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,24,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(154,_,@level_num_0),
   precededBy(v2,v1,_,@level_num_1),
   genre(v0,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [116:1-116:64])_");
if(!(rel_3_genre->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(154),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{0,env1[0],0,0}});
auto range = rel_3_genre->equalRange_2(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(RamDomain(24)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,25,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(155,_,@level_num_0),
   precededBy(v1,v2,_,@level_num_1),
   genre(v2,v0,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [117:1-117:64])_");
if(!(rel_3_genre->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(155),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{env1[1],0,0,0}});
auto range = rel_3_genre->equalRange_1(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(25)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,26,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(156,_,@level_num_0),
   precededBy(v2,v0,_,@level_num_1),
   genre(v1,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [118:1-118:64])_");
if(!(rel_3_genre->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(156),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{0,env1[0],0,0}});
auto range = rel_3_genre->equalRange_2(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(RamDomain(26)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,27,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(157,_,@level_num_0),
   precededBy(v2,v0,_,@level_num_1),
   genre(v2,v1,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [119:1-119:64])_");
if(!(rel_3_genre->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(157),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{env1[0],0,0,0}});
auto range = rel_3_genre->equalRange_1(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(RamDomain(27)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,28,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(158,_,@level_num_0),
   precededBy(v0,v2,_,@level_num_1),
   genre(v1,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [120:1-120:64])_");
if(!(rel_3_genre->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(158),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{0,env1[1],0,0}});
auto range = rel_3_genre->equalRange_2(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(RamDomain(28)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,29,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(159,_,@level_num_0),
   precededBy(v0,v2,_,@level_num_1),
   genre(v2,v1,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [121:1-121:64])_");
if(!(rel_3_genre->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(159),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{env1[1],0,0,0}});
auto range = rel_3_genre->equalRange_1(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(RamDomain(29)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,30,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(160,_,@level_num_0),
   precededBy(v2,v1,_,@level_num_1),
   genre(v2,v0,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [122:1-122:64])_");
if(!(rel_3_genre->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(160),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{env1[0],0,0,0}});
auto range = rel_3_genre->equalRange_1(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(RamDomain(30)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,31,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(161,_,@level_num_0),
   precededBy(v1,v2,_,@level_num_1),
   genre(v0,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [123:1-123:64])_");
if(!(rel_3_genre->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(161),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{0,env1[1],0,0}});
auto range = rel_3_genre->equalRange_2(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(31)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,32,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(166,_,@level_num_0),
   precededBy(v2,v1,_,@level_num_1),
   Iauthor(v0,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [124:1-124:66])_");
if(!(rel_1_Iauthor->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(166),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{0,env1[0],0,0}});
auto range = rel_1_Iauthor->equalRange_2(key,READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(RamDomain(32)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,33,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(167,_,@level_num_0),
   precededBy(v1,v2,_,@level_num_1),
   Iauthor(v2,v0,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [125:1-125:66])_");
if(!(rel_1_Iauthor->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(167),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{env1[1],0,0,0}});
auto range = rel_1_Iauthor->equalRange_1(key,READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(33)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,34,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(168,_,@level_num_0),
   precededBy(v2,v0,_,@level_num_1),
   Iauthor(v1,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [126:1-126:66])_");
if(!(rel_1_Iauthor->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(168),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{0,env1[0],0,0}});
auto range = rel_1_Iauthor->equalRange_2(key,READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(RamDomain(34)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,35,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(169,_,@level_num_0),
   precededBy(v2,v0,_,@level_num_1),
   Iauthor(v2,v1,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [127:1-127:66])_");
if(!(rel_1_Iauthor->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(169),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{env1[0],0,0,0}});
auto range = rel_1_Iauthor->equalRange_1(key,READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(RamDomain(35)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,36,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(170,_,@level_num_0),
   precededBy(v0,v2,_,@level_num_1),
   Iauthor(v1,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [128:1-128:66])_");
if(!(rel_1_Iauthor->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(170),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{0,env1[1],0,0}});
auto range = rel_1_Iauthor->equalRange_2(key,READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(RamDomain(36)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,37,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(171,_,@level_num_0),
   precededBy(v0,v2,_,@level_num_1),
   Iauthor(v2,v1,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [129:1-129:66])_");
if(!(rel_1_Iauthor->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(171),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{env1[1],0,0,0}});
auto range = rel_1_Iauthor->equalRange_1(key,READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(RamDomain(37)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,38,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(172,_,@level_num_0),
   precededBy(v2,v1,_,@level_num_1),
   Iauthor(v2,v0,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [130:1-130:66])_");
if(!(rel_1_Iauthor->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(172),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{env1[0],0,0,0}});
auto range = rel_1_Iauthor->equalRange_1(key,READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(RamDomain(38)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,39,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(173,_,@level_num_0),
   precededBy(v1,v2,_,@level_num_1),
   Iauthor(v0,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [131:1-131:66])_");
if(!(rel_1_Iauthor->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(173),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{0,env1[1],0,0}});
auto range = rel_1_Iauthor->equalRange_2(key,READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(39)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,40,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(174,_,@level_num_0),
   precededBy(v0,v1,_,@level_num_1),
   inv_0(v0,v1,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [132:1-132:64])_");
if(!(rel_5_inv_0->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(174),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{env1[0],env1[1],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(RamDomain(40)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,41,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(175,_,@level_num_0),
   precededBy(v0,v1,_,@level_num_1),
   inv_0(v1,v0,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [133:1-133:64])_");
if(!(rel_5_inv_0->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(175),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{env1[1],env1[0],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(RamDomain(41)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,42,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(176,_,@level_num_0),
   precededBy(v1,v0,_,@level_num_1),
   inv_0(v1,v0,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [134:1-134:64])_");
if(!(rel_5_inv_0->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(176),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{env1[0],env1[1],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(42)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,43,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(177,_,@level_num_0),
   precededBy(v1,v0,_,@level_num_1),
   inv_0(v0,v1,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [135:1-135:64])_");
if(!(rel_5_inv_0->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(177),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{env1[1],env1[0],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(43)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,44,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(178,_,@level_num_0),
   precededBy(v2,v1,_,@level_num_1),
   inv_0(v0,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [136:1-136:64])_");
if(!(rel_5_inv_0->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(178),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{0,env1[0],0,0}});
auto range = rel_5_inv_0->equalRange_2(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(RamDomain(44)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,45,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(179,_,@level_num_0),
   precededBy(v1,v2,_,@level_num_1),
   inv_0(v2,v0,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [137:1-137:64])_");
if(!(rel_5_inv_0->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(179),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{env1[1],0,0,0}});
auto range = rel_5_inv_0->equalRange_1(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(45)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,46,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(180,_,@level_num_0),
   precededBy(v2,v0,_,@level_num_1),
   inv_0(v1,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [138:1-138:64])_");
if(!(rel_5_inv_0->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(180),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{0,env1[0],0,0}});
auto range = rel_5_inv_0->equalRange_2(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(RamDomain(46)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,47,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(181,_,@level_num_0),
   precededBy(v2,v0,_,@level_num_1),
   inv_0(v2,v1,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [139:1-139:64])_");
if(!(rel_5_inv_0->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(181),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{env1[0],0,0,0}});
auto range = rel_5_inv_0->equalRange_1(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(RamDomain(47)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,48,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(182,_,@level_num_0),
   precededBy(v0,v2,_,@level_num_1),
   inv_0(v1,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [140:1-140:64])_");
if(!(rel_5_inv_0->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(182),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{0,env1[1],0,0}});
auto range = rel_5_inv_0->equalRange_2(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(RamDomain(48)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,49,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(183,_,@level_num_0),
   precededBy(v0,v2,_,@level_num_1),
   inv_0(v2,v1,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [141:1-141:64])_");
if(!(rel_5_inv_0->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(183),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{env1[1],0,0,0}});
auto range = rel_5_inv_0->equalRange_1(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(RamDomain(49)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,50,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(184,_,@level_num_0),
   precededBy(v2,v1,_,@level_num_1),
   inv_0(v2,v0,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [142:1-142:64])_");
if(!(rel_5_inv_0->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(184),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{env1[0],0,0,0}});
auto range = rel_5_inv_0->equalRange_1(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(RamDomain(50)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,51,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(185,_,@level_num_0),
   precededBy(v1,v2,_,@level_num_1),
   inv_0(v0,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [143:1-143:64])_");
if(!(rel_5_inv_0->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(185),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{0,env1[1],0,0}});
auto range = rel_5_inv_0->equalRange_2(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(51)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,62,(max(@level_num_0,@level_num_1)+1)) :- 
   Rule(198,_,@level_num_0),
   genre(v0,v1,_,@level_num_1).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [154:1-154:59])_");
if(!(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(198),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_3_genre) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(RamDomain(62)),static_cast<RamDomain>((std::max({env0[2], env1[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,63,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(199,_,@level_num_0),
   genre(v0,v1,_,@level_num_1),
   genre(v1,v0,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [155:1-155:59])_");
if(!(rel_3_genre->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(199),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_3_genre) {
const Tuple<RamDomain,4> key({{env1[1],env1[0],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(RamDomain(63)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,64,(max(@level_num_0,@level_num_1)+1)) :- 
   Rule(200,_,@level_num_0),
   genre(v1,v0,_,@level_num_1).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [156:1-156:59])_");
if(!(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(200),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_3_genre) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(64)),static_cast<RamDomain>((std::max({env0[2], env1[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,65,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(201,_,@level_num_0),
   genre(v1,v0,_,@level_num_1),
   genre(v0,v1,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [157:1-157:59])_");
if(!(rel_3_genre->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(201),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_3_genre) {
const Tuple<RamDomain,4> key({{env1[1],env1[0],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(65)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,66,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(202,_,@level_num_0),
   genre(v2,v1,_,@level_num_1),
   genre(v0,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [158:1-158:59])_");
if(!(rel_3_genre->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(202),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_3_genre) {
const Tuple<RamDomain,4> key({{0,env1[0],0,0}});
auto range = rel_3_genre->equalRange_2(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(RamDomain(66)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,67,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(203,_,@level_num_0),
   genre(v1,v2,_,@level_num_1),
   genre(v2,v0,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [159:1-159:59])_");
if(!(rel_3_genre->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(203),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_3_genre) {
const Tuple<RamDomain,4> key({{env1[1],0,0,0}});
auto range = rel_3_genre->equalRange_1(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(67)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,68,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(204,_,@level_num_0),
   genre(v2,v0,_,@level_num_1),
   genre(v1,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [160:1-160:59])_");
if(!(rel_3_genre->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(204),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_3_genre) {
const Tuple<RamDomain,4> key({{0,env1[0],0,0}});
auto range = rel_3_genre->equalRange_2(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(RamDomain(68)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,69,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(205,_,@level_num_0),
   genre(v2,v0,_,@level_num_1),
   genre(v2,v1,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [161:1-161:59])_");
if(!(rel_3_genre->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(205),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_3_genre) {
const Tuple<RamDomain,4> key({{env1[0],0,0,0}});
auto range = rel_3_genre->equalRange_1(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(RamDomain(69)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,70,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(206,_,@level_num_0),
   genre(v0,v2,_,@level_num_1),
   genre(v1,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [162:1-162:59])_");
if(!(rel_3_genre->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(206),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_3_genre) {
const Tuple<RamDomain,4> key({{0,env1[1],0,0}});
auto range = rel_3_genre->equalRange_2(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(RamDomain(70)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,71,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(207,_,@level_num_0),
   genre(v0,v2,_,@level_num_1),
   genre(v2,v1,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [163:1-163:59])_");
if(!(rel_3_genre->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(207),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_3_genre) {
const Tuple<RamDomain,4> key({{env1[1],0,0,0}});
auto range = rel_3_genre->equalRange_1(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(RamDomain(71)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,72,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(208,_,@level_num_0),
   genre(v2,v1,_,@level_num_1),
   genre(v2,v0,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [164:1-164:59])_");
if(!(rel_3_genre->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(208),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_3_genre) {
const Tuple<RamDomain,4> key({{env1[0],0,0,0}});
auto range = rel_3_genre->equalRange_1(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(RamDomain(72)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,73,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(209,_,@level_num_0),
   genre(v1,v2,_,@level_num_1),
   genre(v0,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [165:1-165:59])_");
if(!(rel_3_genre->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(209),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_3_genre) {
const Tuple<RamDomain,4> key({{0,env1[1],0,0}});
auto range = rel_3_genre->equalRange_2(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(73)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,74,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(214,_,@level_num_0),
   genre(v2,v1,_,@level_num_1),
   Iauthor(v0,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [166:1-166:61])_");
if(!(rel_1_Iauthor->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(214),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_3_genre) {
const Tuple<RamDomain,4> key({{0,env1[0],0,0}});
auto range = rel_1_Iauthor->equalRange_2(key,READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(RamDomain(74)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,75,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(215,_,@level_num_0),
   genre(v1,v2,_,@level_num_1),
   Iauthor(v2,v0,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [167:1-167:61])_");
if(!(rel_1_Iauthor->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(215),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_3_genre) {
const Tuple<RamDomain,4> key({{env1[1],0,0,0}});
auto range = rel_1_Iauthor->equalRange_1(key,READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(75)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,76,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(216,_,@level_num_0),
   genre(v2,v0,_,@level_num_1),
   Iauthor(v1,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [168:1-168:61])_");
if(!(rel_1_Iauthor->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(216),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_3_genre) {
const Tuple<RamDomain,4> key({{0,env1[0],0,0}});
auto range = rel_1_Iauthor->equalRange_2(key,READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(RamDomain(76)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,77,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(217,_,@level_num_0),
   genre(v2,v0,_,@level_num_1),
   Iauthor(v2,v1,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [169:1-169:61])_");
if(!(rel_1_Iauthor->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(217),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_3_genre) {
const Tuple<RamDomain,4> key({{env1[0],0,0,0}});
auto range = rel_1_Iauthor->equalRange_1(key,READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(RamDomain(77)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,78,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(218,_,@level_num_0),
   genre(v0,v2,_,@level_num_1),
   Iauthor(v1,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [170:1-170:61])_");
if(!(rel_1_Iauthor->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(218),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_3_genre) {
const Tuple<RamDomain,4> key({{0,env1[1],0,0}});
auto range = rel_1_Iauthor->equalRange_2(key,READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(RamDomain(78)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,79,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(219,_,@level_num_0),
   genre(v0,v2,_,@level_num_1),
   Iauthor(v2,v1,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [171:1-171:61])_");
if(!(rel_1_Iauthor->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(219),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_3_genre) {
const Tuple<RamDomain,4> key({{env1[1],0,0,0}});
auto range = rel_1_Iauthor->equalRange_1(key,READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(RamDomain(79)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,80,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(220,_,@level_num_0),
   genre(v2,v1,_,@level_num_1),
   Iauthor(v2,v0,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [172:1-172:61])_");
if(!(rel_1_Iauthor->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(220),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_3_genre) {
const Tuple<RamDomain,4> key({{env1[0],0,0,0}});
auto range = rel_1_Iauthor->equalRange_1(key,READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(RamDomain(80)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,81,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(221,_,@level_num_0),
   genre(v1,v2,_,@level_num_1),
   Iauthor(v0,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [173:1-173:61])_");
if(!(rel_1_Iauthor->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(221),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_3_genre) {
const Tuple<RamDomain,4> key({{0,env1[1],0,0}});
auto range = rel_1_Iauthor->equalRange_2(key,READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(81)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,82,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(222,_,@level_num_0),
   genre(v0,v1,_,@level_num_1),
   inv_0(v0,v1,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [174:1-174:59])_");
if(!(rel_5_inv_0->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(222),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_3_genre) {
const Tuple<RamDomain,4> key({{env1[0],env1[1],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(RamDomain(82)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,83,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(223,_,@level_num_0),
   genre(v0,v1,_,@level_num_1),
   inv_0(v1,v0,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [175:1-175:59])_");
if(!(rel_5_inv_0->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(223),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_3_genre) {
const Tuple<RamDomain,4> key({{env1[1],env1[0],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(RamDomain(83)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,84,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(224,_,@level_num_0),
   genre(v1,v0,_,@level_num_1),
   inv_0(v1,v0,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [176:1-176:59])_");
if(!(rel_5_inv_0->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(224),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_3_genre) {
const Tuple<RamDomain,4> key({{env1[0],env1[1],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(84)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,85,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(225,_,@level_num_0),
   genre(v1,v0,_,@level_num_1),
   inv_0(v0,v1,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [177:1-177:59])_");
if(!(rel_5_inv_0->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(225),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_3_genre) {
const Tuple<RamDomain,4> key({{env1[1],env1[0],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(85)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,86,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(226,_,@level_num_0),
   genre(v2,v1,_,@level_num_1),
   inv_0(v0,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [178:1-178:59])_");
if(!(rel_5_inv_0->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(226),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_3_genre) {
const Tuple<RamDomain,4> key({{0,env1[0],0,0}});
auto range = rel_5_inv_0->equalRange_2(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(RamDomain(86)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,87,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(227,_,@level_num_0),
   genre(v1,v2,_,@level_num_1),
   inv_0(v2,v0,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [179:1-179:59])_");
if(!(rel_5_inv_0->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(227),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_3_genre) {
const Tuple<RamDomain,4> key({{env1[1],0,0,0}});
auto range = rel_5_inv_0->equalRange_1(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(87)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,88,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(228,_,@level_num_0),
   genre(v2,v0,_,@level_num_1),
   inv_0(v1,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [180:1-180:59])_");
if(!(rel_5_inv_0->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(228),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_3_genre) {
const Tuple<RamDomain,4> key({{0,env1[0],0,0}});
auto range = rel_5_inv_0->equalRange_2(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(RamDomain(88)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,89,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(229,_,@level_num_0),
   genre(v2,v0,_,@level_num_1),
   inv_0(v2,v1,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [181:1-181:59])_");
if(!(rel_5_inv_0->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(229),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_3_genre) {
const Tuple<RamDomain,4> key({{env1[0],0,0,0}});
auto range = rel_5_inv_0->equalRange_1(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(RamDomain(89)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,90,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(230,_,@level_num_0),
   genre(v0,v2,_,@level_num_1),
   inv_0(v1,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [182:1-182:59])_");
if(!(rel_5_inv_0->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(230),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_3_genre) {
const Tuple<RamDomain,4> key({{0,env1[1],0,0}});
auto range = rel_5_inv_0->equalRange_2(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(RamDomain(90)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,91,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(231,_,@level_num_0),
   genre(v0,v2,_,@level_num_1),
   inv_0(v2,v1,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [183:1-183:59])_");
if(!(rel_5_inv_0->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(231),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_3_genre) {
const Tuple<RamDomain,4> key({{env1[1],0,0,0}});
auto range = rel_5_inv_0->equalRange_1(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(RamDomain(91)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,92,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(232,_,@level_num_0),
   genre(v2,v1,_,@level_num_1),
   inv_0(v2,v0,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [184:1-184:59])_");
if(!(rel_5_inv_0->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(232),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_3_genre) {
const Tuple<RamDomain,4> key({{env1[0],0,0,0}});
auto range = rel_5_inv_0->equalRange_1(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(RamDomain(92)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,93,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(233,_,@level_num_0),
   genre(v1,v2,_,@level_num_1),
   inv_0(v0,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [185:1-185:59])_");
if(!(rel_5_inv_0->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(233),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_3_genre) {
const Tuple<RamDomain,4> key({{0,env1[1],0,0}});
auto range = rel_5_inv_0->equalRange_2(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(93)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,104,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(250,_,@level_num_0),
   Iauthor(v2,v1,_,@level_num_1),
   Iauthor(v0,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [196:1-196:63])_");
if(!(rel_1_Iauthor->empty()) && !(rel_1_Iauthor->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(250),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_1_Iauthor) {
const Tuple<RamDomain,4> key({{0,env1[0],0,0}});
auto range = rel_1_Iauthor->equalRange_2(key,READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(RamDomain(104)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,105,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(251,_,@level_num_0),
   Iauthor(v1,v2,_,@level_num_1),
   Iauthor(v2,v0,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [197:1-197:63])_");
if(!(rel_1_Iauthor->empty()) && !(rel_1_Iauthor->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(251),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_1_Iauthor) {
const Tuple<RamDomain,4> key({{env1[1],0,0,0}});
auto range = rel_1_Iauthor->equalRange_1(key,READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(105)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,106,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(252,_,@level_num_0),
   Iauthor(v2,v0,_,@level_num_1),
   Iauthor(v1,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [198:1-198:63])_");
if(!(rel_1_Iauthor->empty()) && !(rel_1_Iauthor->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(252),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_1_Iauthor) {
const Tuple<RamDomain,4> key({{0,env1[0],0,0}});
auto range = rel_1_Iauthor->equalRange_2(key,READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(RamDomain(106)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,107,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(253,_,@level_num_0),
   Iauthor(v2,v0,_,@level_num_1),
   Iauthor(v2,v1,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [199:1-199:63])_");
if(!(rel_1_Iauthor->empty()) && !(rel_1_Iauthor->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(253),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_1_Iauthor) {
const Tuple<RamDomain,4> key({{env1[0],0,0,0}});
auto range = rel_1_Iauthor->equalRange_1(key,READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(RamDomain(107)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,108,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(254,_,@level_num_0),
   Iauthor(v0,v2,_,@level_num_1),
   Iauthor(v1,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [200:1-200:63])_");
if(!(rel_1_Iauthor->empty()) && !(rel_1_Iauthor->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(254),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_1_Iauthor) {
const Tuple<RamDomain,4> key({{0,env1[1],0,0}});
auto range = rel_1_Iauthor->equalRange_2(key,READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(RamDomain(108)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,109,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(255,_,@level_num_0),
   Iauthor(v0,v2,_,@level_num_1),
   Iauthor(v2,v1,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [201:1-201:63])_");
if(!(rel_1_Iauthor->empty()) && !(rel_1_Iauthor->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(255),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_1_Iauthor) {
const Tuple<RamDomain,4> key({{env1[1],0,0,0}});
auto range = rel_1_Iauthor->equalRange_1(key,READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(RamDomain(109)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,110,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(256,_,@level_num_0),
   Iauthor(v2,v1,_,@level_num_1),
   Iauthor(v2,v0,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [202:1-202:63])_");
if(!(rel_1_Iauthor->empty()) && !(rel_1_Iauthor->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(256),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_1_Iauthor) {
const Tuple<RamDomain,4> key({{env1[0],0,0,0}});
auto range = rel_1_Iauthor->equalRange_1(key,READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(RamDomain(110)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,111,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(257,_,@level_num_0),
   Iauthor(v1,v2,_,@level_num_1),
   Iauthor(v0,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [203:1-203:63])_");
if(!(rel_1_Iauthor->empty()) && !(rel_1_Iauthor->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(257),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_1_Iauthor) {
const Tuple<RamDomain,4> key({{0,env1[1],0,0}});
auto range = rel_1_Iauthor->equalRange_2(key,READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(111)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,120,(max(@level_num_0,@level_num_1)+1)) :- 
   Rule(282,_,@level_num_0),
   inv_0(v0,v1,_,@level_num_1).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [212:1-212:59])_");
if(!(rel_5_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(282),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_5_inv_0) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(RamDomain(120)),static_cast<RamDomain>((std::max({env0[2], env1[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,121,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(283,_,@level_num_0),
   inv_0(v0,v1,_,@level_num_1),
   inv_0(v1,v0,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [213:1-213:59])_");
if(!(rel_5_inv_0->empty()) && !(rel_5_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(283),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_5_inv_0) {
const Tuple<RamDomain,4> key({{env1[1],env1[0],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(RamDomain(121)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,122,(max(@level_num_0,@level_num_1)+1)) :- 
   Rule(284,_,@level_num_0),
   inv_0(v1,v0,_,@level_num_1).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [214:1-214:59])_");
if(!(rel_5_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(284),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_5_inv_0) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(122)),static_cast<RamDomain>((std::max({env0[2], env1[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,123,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(285,_,@level_num_0),
   inv_0(v1,v0,_,@level_num_1),
   inv_0(v0,v1,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [215:1-215:59])_");
if(!(rel_5_inv_0->empty()) && !(rel_5_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(285),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_5_inv_0) {
const Tuple<RamDomain,4> key({{env1[1],env1[0],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(123)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,124,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(286,_,@level_num_0),
   inv_0(v2,v1,_,@level_num_1),
   inv_0(v0,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [216:1-216:59])_");
if(!(rel_5_inv_0->empty()) && !(rel_5_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(286),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_5_inv_0) {
const Tuple<RamDomain,4> key({{0,env1[0],0,0}});
auto range = rel_5_inv_0->equalRange_2(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(RamDomain(124)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,125,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(287,_,@level_num_0),
   inv_0(v1,v2,_,@level_num_1),
   inv_0(v2,v0,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [217:1-217:59])_");
if(!(rel_5_inv_0->empty()) && !(rel_5_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(287),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_5_inv_0) {
const Tuple<RamDomain,4> key({{env1[1],0,0,0}});
auto range = rel_5_inv_0->equalRange_1(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(125)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,126,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(288,_,@level_num_0),
   inv_0(v2,v0,_,@level_num_1),
   inv_0(v1,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [218:1-218:59])_");
if(!(rel_5_inv_0->empty()) && !(rel_5_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(288),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_5_inv_0) {
const Tuple<RamDomain,4> key({{0,env1[0],0,0}});
auto range = rel_5_inv_0->equalRange_2(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(RamDomain(126)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,127,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(289,_,@level_num_0),
   inv_0(v2,v0,_,@level_num_1),
   inv_0(v2,v1,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [219:1-219:59])_");
if(!(rel_5_inv_0->empty()) && !(rel_5_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(289),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_5_inv_0) {
const Tuple<RamDomain,4> key({{env1[0],0,0,0}});
auto range = rel_5_inv_0->equalRange_1(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(RamDomain(127)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,128,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(290,_,@level_num_0),
   inv_0(v0,v2,_,@level_num_1),
   inv_0(v1,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [220:1-220:59])_");
if(!(rel_5_inv_0->empty()) && !(rel_5_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(290),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_5_inv_0) {
const Tuple<RamDomain,4> key({{0,env1[1],0,0}});
auto range = rel_5_inv_0->equalRange_2(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(RamDomain(128)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,129,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(291,_,@level_num_0),
   inv_0(v0,v2,_,@level_num_1),
   inv_0(v2,v1,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [221:1-221:59])_");
if(!(rel_5_inv_0->empty()) && !(rel_5_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(291),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_5_inv_0) {
const Tuple<RamDomain,4> key({{env1[1],0,0,0}});
auto range = rel_5_inv_0->equalRange_1(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(RamDomain(129)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,130,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(292,_,@level_num_0),
   inv_0(v2,v1,_,@level_num_1),
   inv_0(v2,v0,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [222:1-222:59])_");
if(!(rel_5_inv_0->empty()) && !(rel_5_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(292),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_5_inv_0) {
const Tuple<RamDomain,4> key({{env1[0],0,0,0}});
auto range = rel_5_inv_0->equalRange_1(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(RamDomain(130)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,131,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(293,_,@level_num_0),
   inv_0(v1,v2,_,@level_num_1),
   inv_0(v0,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [223:1-223:59])_");
if(!(rel_5_inv_0->empty()) && !(rel_5_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(293),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_5_inv_0) {
const Tuple<RamDomain,4> key({{0,env1[1],0,0}});
auto range = rel_5_inv_0->equalRange_2(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(131)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_8_author->insert(tuple,READ_OP_CONTEXT(rel_8_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
rel_9_delta_author->insertAll(*rel_8_author);
iter = 0;
for(;;) {
SignalHandler::instance()->setMsg(R"_(author(v0,v1,7,(max(@level_num_0,@level_num_1)+1)) :- 
   Rule(137,_,@level_num_0),
   author(v1,v0,_,@level_num_1).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [99:1-99:45])_");
if(!(rel_9_delta_author->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(137),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
CREATE_OP_CONTEXT(rel_10_new_author_op_ctxt,rel_10_new_author->createContext());
CREATE_OP_CONTEXT(rel_9_delta_author_op_ctxt,rel_9_delta_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_9_delta_author) {
if( !([&]() -> bool {
auto existenceCheck = rel_8_author->equalRange_3(Tuple<RamDomain,4>({{env1[1],env1[0],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({env0[2], env1[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(7)),static_cast<RamDomain>((std::max({env0[2], env1[3], })) + (RamDomain(1)))}});
rel_10_new_author->insert(tuple,READ_OP_CONTEXT(rel_10_new_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,52,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(187,_,@level_num_0),
   precededBy(v0,v1,_,@level_num_1),
   author(v1,v0,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [144:1-144:65])_");
if(!(rel_9_delta_author->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(187),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
CREATE_OP_CONTEXT(rel_10_new_author_op_ctxt,rel_10_new_author->createContext());
CREATE_OP_CONTEXT(rel_9_delta_author_op_ctxt,rel_9_delta_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{env1[1],env1[0],0,0}});
auto range = rel_9_delta_author->equalRange_3(key,READ_OP_CONTEXT(rel_9_delta_author_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_8_author->equalRange_3(Tuple<RamDomain,4>({{env1[0],env1[1],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(RamDomain(52)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_10_new_author->insert(tuple,READ_OP_CONTEXT(rel_10_new_author_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,53,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(188,_,@level_num_0),
   precededBy(v1,v0,_,@level_num_1),
   author(v1,v0,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [145:1-145:65])_");
if(!(rel_9_delta_author->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(188),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
CREATE_OP_CONTEXT(rel_10_new_author_op_ctxt,rel_10_new_author->createContext());
CREATE_OP_CONTEXT(rel_9_delta_author_op_ctxt,rel_9_delta_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{env1[0],env1[1],0,0}});
auto range = rel_9_delta_author->equalRange_3(key,READ_OP_CONTEXT(rel_9_delta_author_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_8_author->equalRange_3(Tuple<RamDomain,4>({{env1[1],env1[0],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(53)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_10_new_author->insert(tuple,READ_OP_CONTEXT(rel_10_new_author_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,54,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(190,_,@level_num_0),
   precededBy(v2,v1,_,@level_num_1),
   author(v0,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [146:1-146:65])_");
if(!(rel_9_delta_author->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(190),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
CREATE_OP_CONTEXT(rel_10_new_author_op_ctxt,rel_10_new_author->createContext());
CREATE_OP_CONTEXT(rel_9_delta_author_op_ctxt,rel_9_delta_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{0,env1[0],0,0}});
auto range = rel_9_delta_author->equalRange_2(key,READ_OP_CONTEXT(rel_9_delta_author_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_8_author->equalRange_3(Tuple<RamDomain,4>({{env2[0],env1[1],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(RamDomain(54)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_10_new_author->insert(tuple,READ_OP_CONTEXT(rel_10_new_author_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,55,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(191,_,@level_num_0),
   precededBy(v1,v2,_,@level_num_1),
   author(v2,v0,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [147:1-147:65])_");
if(!(rel_9_delta_author->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(191),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
CREATE_OP_CONTEXT(rel_10_new_author_op_ctxt,rel_10_new_author->createContext());
CREATE_OP_CONTEXT(rel_9_delta_author_op_ctxt,rel_9_delta_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{env1[1],0,0,0}});
auto range = rel_9_delta_author->equalRange_1(key,READ_OP_CONTEXT(rel_9_delta_author_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_8_author->equalRange_3(Tuple<RamDomain,4>({{env2[1],env1[0],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(55)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_10_new_author->insert(tuple,READ_OP_CONTEXT(rel_10_new_author_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,56,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(192,_,@level_num_0),
   precededBy(v2,v0,_,@level_num_1),
   author(v1,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [148:1-148:65])_");
if(!(rel_9_delta_author->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(192),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
CREATE_OP_CONTEXT(rel_10_new_author_op_ctxt,rel_10_new_author->createContext());
CREATE_OP_CONTEXT(rel_9_delta_author_op_ctxt,rel_9_delta_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{0,env1[0],0,0}});
auto range = rel_9_delta_author->equalRange_2(key,READ_OP_CONTEXT(rel_9_delta_author_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_8_author->equalRange_3(Tuple<RamDomain,4>({{env1[1],env2[0],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(RamDomain(56)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_10_new_author->insert(tuple,READ_OP_CONTEXT(rel_10_new_author_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,57,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(193,_,@level_num_0),
   precededBy(v2,v0,_,@level_num_1),
   author(v2,v1,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [149:1-149:65])_");
if(!(rel_9_delta_author->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(193),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
CREATE_OP_CONTEXT(rel_10_new_author_op_ctxt,rel_10_new_author->createContext());
CREATE_OP_CONTEXT(rel_9_delta_author_op_ctxt,rel_9_delta_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{env1[0],0,0,0}});
auto range = rel_9_delta_author->equalRange_1(key,READ_OP_CONTEXT(rel_9_delta_author_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_8_author->equalRange_3(Tuple<RamDomain,4>({{env1[1],env2[1],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(RamDomain(57)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_10_new_author->insert(tuple,READ_OP_CONTEXT(rel_10_new_author_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,58,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(194,_,@level_num_0),
   precededBy(v0,v2,_,@level_num_1),
   author(v1,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [150:1-150:65])_");
if(!(rel_9_delta_author->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(194),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
CREATE_OP_CONTEXT(rel_10_new_author_op_ctxt,rel_10_new_author->createContext());
CREATE_OP_CONTEXT(rel_9_delta_author_op_ctxt,rel_9_delta_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{0,env1[1],0,0}});
auto range = rel_9_delta_author->equalRange_2(key,READ_OP_CONTEXT(rel_9_delta_author_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_8_author->equalRange_3(Tuple<RamDomain,4>({{env1[0],env2[0],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(RamDomain(58)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_10_new_author->insert(tuple,READ_OP_CONTEXT(rel_10_new_author_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,59,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(195,_,@level_num_0),
   precededBy(v0,v2,_,@level_num_1),
   author(v2,v1,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [151:1-151:65])_");
if(!(rel_9_delta_author->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(195),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
CREATE_OP_CONTEXT(rel_10_new_author_op_ctxt,rel_10_new_author->createContext());
CREATE_OP_CONTEXT(rel_9_delta_author_op_ctxt,rel_9_delta_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{env1[1],0,0,0}});
auto range = rel_9_delta_author->equalRange_1(key,READ_OP_CONTEXT(rel_9_delta_author_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_8_author->equalRange_3(Tuple<RamDomain,4>({{env1[0],env2[1],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(RamDomain(59)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_10_new_author->insert(tuple,READ_OP_CONTEXT(rel_10_new_author_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,60,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(196,_,@level_num_0),
   precededBy(v2,v1,_,@level_num_1),
   author(v2,v0,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [152:1-152:65])_");
if(!(rel_9_delta_author->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(196),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
CREATE_OP_CONTEXT(rel_10_new_author_op_ctxt,rel_10_new_author->createContext());
CREATE_OP_CONTEXT(rel_9_delta_author_op_ctxt,rel_9_delta_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{env1[0],0,0,0}});
auto range = rel_9_delta_author->equalRange_1(key,READ_OP_CONTEXT(rel_9_delta_author_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_8_author->equalRange_3(Tuple<RamDomain,4>({{env2[1],env1[1],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(RamDomain(60)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_10_new_author->insert(tuple,READ_OP_CONTEXT(rel_10_new_author_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,61,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(197,_,@level_num_0),
   precededBy(v1,v2,_,@level_num_1),
   author(v0,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [153:1-153:65])_");
if(!(rel_9_delta_author->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(197),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
CREATE_OP_CONTEXT(rel_10_new_author_op_ctxt,rel_10_new_author->createContext());
CREATE_OP_CONTEXT(rel_9_delta_author_op_ctxt,rel_9_delta_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_4_precededBy) {
const Tuple<RamDomain,4> key({{0,env1[1],0,0}});
auto range = rel_9_delta_author->equalRange_2(key,READ_OP_CONTEXT(rel_9_delta_author_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_8_author->equalRange_3(Tuple<RamDomain,4>({{env2[0],env1[0],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(61)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_10_new_author->insert(tuple,READ_OP_CONTEXT(rel_10_new_author_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,94,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(235,_,@level_num_0),
   genre(v0,v1,_,@level_num_1),
   author(v1,v0,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [186:1-186:60])_");
if(!(rel_9_delta_author->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(235),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
CREATE_OP_CONTEXT(rel_10_new_author_op_ctxt,rel_10_new_author->createContext());
CREATE_OP_CONTEXT(rel_9_delta_author_op_ctxt,rel_9_delta_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_3_genre) {
const Tuple<RamDomain,4> key({{env1[1],env1[0],0,0}});
auto range = rel_9_delta_author->equalRange_3(key,READ_OP_CONTEXT(rel_9_delta_author_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_8_author->equalRange_3(Tuple<RamDomain,4>({{env1[0],env1[1],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(RamDomain(94)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_10_new_author->insert(tuple,READ_OP_CONTEXT(rel_10_new_author_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,95,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(236,_,@level_num_0),
   genre(v1,v0,_,@level_num_1),
   author(v1,v0,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [187:1-187:60])_");
if(!(rel_9_delta_author->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(236),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
CREATE_OP_CONTEXT(rel_10_new_author_op_ctxt,rel_10_new_author->createContext());
CREATE_OP_CONTEXT(rel_9_delta_author_op_ctxt,rel_9_delta_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_3_genre) {
const Tuple<RamDomain,4> key({{env1[0],env1[1],0,0}});
auto range = rel_9_delta_author->equalRange_3(key,READ_OP_CONTEXT(rel_9_delta_author_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_8_author->equalRange_3(Tuple<RamDomain,4>({{env1[1],env1[0],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(95)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_10_new_author->insert(tuple,READ_OP_CONTEXT(rel_10_new_author_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,96,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(238,_,@level_num_0),
   genre(v2,v1,_,@level_num_1),
   author(v0,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [188:1-188:60])_");
if(!(rel_9_delta_author->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(238),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
CREATE_OP_CONTEXT(rel_10_new_author_op_ctxt,rel_10_new_author->createContext());
CREATE_OP_CONTEXT(rel_9_delta_author_op_ctxt,rel_9_delta_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_3_genre) {
const Tuple<RamDomain,4> key({{0,env1[0],0,0}});
auto range = rel_9_delta_author->equalRange_2(key,READ_OP_CONTEXT(rel_9_delta_author_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_8_author->equalRange_3(Tuple<RamDomain,4>({{env2[0],env1[1],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(RamDomain(96)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_10_new_author->insert(tuple,READ_OP_CONTEXT(rel_10_new_author_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,97,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(239,_,@level_num_0),
   genre(v1,v2,_,@level_num_1),
   author(v2,v0,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [189:1-189:60])_");
if(!(rel_9_delta_author->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(239),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
CREATE_OP_CONTEXT(rel_10_new_author_op_ctxt,rel_10_new_author->createContext());
CREATE_OP_CONTEXT(rel_9_delta_author_op_ctxt,rel_9_delta_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_3_genre) {
const Tuple<RamDomain,4> key({{env1[1],0,0,0}});
auto range = rel_9_delta_author->equalRange_1(key,READ_OP_CONTEXT(rel_9_delta_author_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_8_author->equalRange_3(Tuple<RamDomain,4>({{env2[1],env1[0],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(97)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_10_new_author->insert(tuple,READ_OP_CONTEXT(rel_10_new_author_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,98,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(240,_,@level_num_0),
   genre(v2,v0,_,@level_num_1),
   author(v1,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [190:1-190:60])_");
if(!(rel_9_delta_author->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(240),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
CREATE_OP_CONTEXT(rel_10_new_author_op_ctxt,rel_10_new_author->createContext());
CREATE_OP_CONTEXT(rel_9_delta_author_op_ctxt,rel_9_delta_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_3_genre) {
const Tuple<RamDomain,4> key({{0,env1[0],0,0}});
auto range = rel_9_delta_author->equalRange_2(key,READ_OP_CONTEXT(rel_9_delta_author_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_8_author->equalRange_3(Tuple<RamDomain,4>({{env1[1],env2[0],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(RamDomain(98)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_10_new_author->insert(tuple,READ_OP_CONTEXT(rel_10_new_author_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,99,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(241,_,@level_num_0),
   genre(v2,v0,_,@level_num_1),
   author(v2,v1,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [191:1-191:60])_");
if(!(rel_9_delta_author->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(241),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
CREATE_OP_CONTEXT(rel_10_new_author_op_ctxt,rel_10_new_author->createContext());
CREATE_OP_CONTEXT(rel_9_delta_author_op_ctxt,rel_9_delta_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_3_genre) {
const Tuple<RamDomain,4> key({{env1[0],0,0,0}});
auto range = rel_9_delta_author->equalRange_1(key,READ_OP_CONTEXT(rel_9_delta_author_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_8_author->equalRange_3(Tuple<RamDomain,4>({{env1[1],env2[1],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(RamDomain(99)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_10_new_author->insert(tuple,READ_OP_CONTEXT(rel_10_new_author_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,100,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(242,_,@level_num_0),
   genre(v0,v2,_,@level_num_1),
   author(v1,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [192:1-192:60])_");
if(!(rel_9_delta_author->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(242),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
CREATE_OP_CONTEXT(rel_10_new_author_op_ctxt,rel_10_new_author->createContext());
CREATE_OP_CONTEXT(rel_9_delta_author_op_ctxt,rel_9_delta_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_3_genre) {
const Tuple<RamDomain,4> key({{0,env1[1],0,0}});
auto range = rel_9_delta_author->equalRange_2(key,READ_OP_CONTEXT(rel_9_delta_author_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_8_author->equalRange_3(Tuple<RamDomain,4>({{env1[0],env2[0],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(RamDomain(100)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_10_new_author->insert(tuple,READ_OP_CONTEXT(rel_10_new_author_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,101,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(243,_,@level_num_0),
   genre(v0,v2,_,@level_num_1),
   author(v2,v1,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [193:1-193:60])_");
if(!(rel_9_delta_author->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(243),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
CREATE_OP_CONTEXT(rel_10_new_author_op_ctxt,rel_10_new_author->createContext());
CREATE_OP_CONTEXT(rel_9_delta_author_op_ctxt,rel_9_delta_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_3_genre) {
const Tuple<RamDomain,4> key({{env1[1],0,0,0}});
auto range = rel_9_delta_author->equalRange_1(key,READ_OP_CONTEXT(rel_9_delta_author_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_8_author->equalRange_3(Tuple<RamDomain,4>({{env1[0],env2[1],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(RamDomain(101)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_10_new_author->insert(tuple,READ_OP_CONTEXT(rel_10_new_author_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,102,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(244,_,@level_num_0),
   genre(v2,v1,_,@level_num_1),
   author(v2,v0,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [194:1-194:60])_");
if(!(rel_9_delta_author->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(244),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
CREATE_OP_CONTEXT(rel_10_new_author_op_ctxt,rel_10_new_author->createContext());
CREATE_OP_CONTEXT(rel_9_delta_author_op_ctxt,rel_9_delta_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_3_genre) {
const Tuple<RamDomain,4> key({{env1[0],0,0,0}});
auto range = rel_9_delta_author->equalRange_1(key,READ_OP_CONTEXT(rel_9_delta_author_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_8_author->equalRange_3(Tuple<RamDomain,4>({{env2[1],env1[1],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(RamDomain(102)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_10_new_author->insert(tuple,READ_OP_CONTEXT(rel_10_new_author_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,103,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(245,_,@level_num_0),
   genre(v1,v2,_,@level_num_1),
   author(v0,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [195:1-195:60])_");
if(!(rel_9_delta_author->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(245),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
CREATE_OP_CONTEXT(rel_10_new_author_op_ctxt,rel_10_new_author->createContext());
CREATE_OP_CONTEXT(rel_9_delta_author_op_ctxt,rel_9_delta_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_3_genre) {
const Tuple<RamDomain,4> key({{0,env1[1],0,0}});
auto range = rel_9_delta_author->equalRange_2(key,READ_OP_CONTEXT(rel_9_delta_author_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_8_author->equalRange_3(Tuple<RamDomain,4>({{env2[0],env1[0],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(103)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_10_new_author->insert(tuple,READ_OP_CONTEXT(rel_10_new_author_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,112,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(274,_,@level_num_0),
   Iauthor(v2,v1,_,@level_num_1),
   author(v0,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [204:1-204:62])_");
if(!(rel_9_delta_author->empty()) && !(rel_1_Iauthor->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(274),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
CREATE_OP_CONTEXT(rel_10_new_author_op_ctxt,rel_10_new_author->createContext());
CREATE_OP_CONTEXT(rel_9_delta_author_op_ctxt,rel_9_delta_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_1_Iauthor) {
const Tuple<RamDomain,4> key({{0,env1[0],0,0}});
auto range = rel_9_delta_author->equalRange_2(key,READ_OP_CONTEXT(rel_9_delta_author_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_8_author->equalRange_3(Tuple<RamDomain,4>({{env2[0],env1[1],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(RamDomain(112)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_10_new_author->insert(tuple,READ_OP_CONTEXT(rel_10_new_author_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,113,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(275,_,@level_num_0),
   Iauthor(v1,v2,_,@level_num_1),
   author(v2,v0,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [205:1-205:62])_");
if(!(rel_9_delta_author->empty()) && !(rel_1_Iauthor->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(275),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
CREATE_OP_CONTEXT(rel_10_new_author_op_ctxt,rel_10_new_author->createContext());
CREATE_OP_CONTEXT(rel_9_delta_author_op_ctxt,rel_9_delta_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_1_Iauthor) {
const Tuple<RamDomain,4> key({{env1[1],0,0,0}});
auto range = rel_9_delta_author->equalRange_1(key,READ_OP_CONTEXT(rel_9_delta_author_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_8_author->equalRange_3(Tuple<RamDomain,4>({{env2[1],env1[0],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(113)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_10_new_author->insert(tuple,READ_OP_CONTEXT(rel_10_new_author_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,114,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(276,_,@level_num_0),
   Iauthor(v2,v0,_,@level_num_1),
   author(v1,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [206:1-206:62])_");
if(!(rel_9_delta_author->empty()) && !(rel_1_Iauthor->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(276),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
CREATE_OP_CONTEXT(rel_10_new_author_op_ctxt,rel_10_new_author->createContext());
CREATE_OP_CONTEXT(rel_9_delta_author_op_ctxt,rel_9_delta_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_1_Iauthor) {
const Tuple<RamDomain,4> key({{0,env1[0],0,0}});
auto range = rel_9_delta_author->equalRange_2(key,READ_OP_CONTEXT(rel_9_delta_author_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_8_author->equalRange_3(Tuple<RamDomain,4>({{env1[1],env2[0],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(RamDomain(114)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_10_new_author->insert(tuple,READ_OP_CONTEXT(rel_10_new_author_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,115,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(277,_,@level_num_0),
   Iauthor(v2,v0,_,@level_num_1),
   author(v2,v1,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [207:1-207:62])_");
if(!(rel_9_delta_author->empty()) && !(rel_1_Iauthor->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(277),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
CREATE_OP_CONTEXT(rel_10_new_author_op_ctxt,rel_10_new_author->createContext());
CREATE_OP_CONTEXT(rel_9_delta_author_op_ctxt,rel_9_delta_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_1_Iauthor) {
const Tuple<RamDomain,4> key({{env1[0],0,0,0}});
auto range = rel_9_delta_author->equalRange_1(key,READ_OP_CONTEXT(rel_9_delta_author_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_8_author->equalRange_3(Tuple<RamDomain,4>({{env1[1],env2[1],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(RamDomain(115)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_10_new_author->insert(tuple,READ_OP_CONTEXT(rel_10_new_author_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,116,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(278,_,@level_num_0),
   Iauthor(v0,v2,_,@level_num_1),
   author(v1,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [208:1-208:62])_");
if(!(rel_9_delta_author->empty()) && !(rel_1_Iauthor->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(278),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
CREATE_OP_CONTEXT(rel_10_new_author_op_ctxt,rel_10_new_author->createContext());
CREATE_OP_CONTEXT(rel_9_delta_author_op_ctxt,rel_9_delta_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_1_Iauthor) {
const Tuple<RamDomain,4> key({{0,env1[1],0,0}});
auto range = rel_9_delta_author->equalRange_2(key,READ_OP_CONTEXT(rel_9_delta_author_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_8_author->equalRange_3(Tuple<RamDomain,4>({{env1[0],env2[0],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(RamDomain(116)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_10_new_author->insert(tuple,READ_OP_CONTEXT(rel_10_new_author_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,117,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(279,_,@level_num_0),
   Iauthor(v0,v2,_,@level_num_1),
   author(v2,v1,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [209:1-209:62])_");
if(!(rel_9_delta_author->empty()) && !(rel_1_Iauthor->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(279),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
CREATE_OP_CONTEXT(rel_10_new_author_op_ctxt,rel_10_new_author->createContext());
CREATE_OP_CONTEXT(rel_9_delta_author_op_ctxt,rel_9_delta_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_1_Iauthor) {
const Tuple<RamDomain,4> key({{env1[1],0,0,0}});
auto range = rel_9_delta_author->equalRange_1(key,READ_OP_CONTEXT(rel_9_delta_author_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_8_author->equalRange_3(Tuple<RamDomain,4>({{env1[0],env2[1],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(RamDomain(117)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_10_new_author->insert(tuple,READ_OP_CONTEXT(rel_10_new_author_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,118,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(280,_,@level_num_0),
   Iauthor(v2,v1,_,@level_num_1),
   author(v2,v0,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [210:1-210:62])_");
if(!(rel_9_delta_author->empty()) && !(rel_1_Iauthor->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(280),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
CREATE_OP_CONTEXT(rel_10_new_author_op_ctxt,rel_10_new_author->createContext());
CREATE_OP_CONTEXT(rel_9_delta_author_op_ctxt,rel_9_delta_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_1_Iauthor) {
const Tuple<RamDomain,4> key({{env1[0],0,0,0}});
auto range = rel_9_delta_author->equalRange_1(key,READ_OP_CONTEXT(rel_9_delta_author_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_8_author->equalRange_3(Tuple<RamDomain,4>({{env2[1],env1[1],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(RamDomain(118)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_10_new_author->insert(tuple,READ_OP_CONTEXT(rel_10_new_author_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,119,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(281,_,@level_num_0),
   Iauthor(v1,v2,_,@level_num_1),
   author(v0,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [211:1-211:62])_");
if(!(rel_9_delta_author->empty()) && !(rel_1_Iauthor->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(281),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
CREATE_OP_CONTEXT(rel_10_new_author_op_ctxt,rel_10_new_author->createContext());
CREATE_OP_CONTEXT(rel_9_delta_author_op_ctxt,rel_9_delta_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_1_Iauthor) {
const Tuple<RamDomain,4> key({{0,env1[1],0,0}});
auto range = rel_9_delta_author->equalRange_2(key,READ_OP_CONTEXT(rel_9_delta_author_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_8_author->equalRange_3(Tuple<RamDomain,4>({{env2[0],env1[0],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(119)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_10_new_author->insert(tuple,READ_OP_CONTEXT(rel_10_new_author_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,132,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(295,_,@level_num_0),
   inv_0(v0,v1,_,@level_num_1),
   author(v1,v0,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [224:1-224:60])_");
if(!(rel_9_delta_author->empty()) && !(rel_5_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(295),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
CREATE_OP_CONTEXT(rel_10_new_author_op_ctxt,rel_10_new_author->createContext());
CREATE_OP_CONTEXT(rel_9_delta_author_op_ctxt,rel_9_delta_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_5_inv_0) {
const Tuple<RamDomain,4> key({{env1[1],env1[0],0,0}});
auto range = rel_9_delta_author->equalRange_3(key,READ_OP_CONTEXT(rel_9_delta_author_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_8_author->equalRange_3(Tuple<RamDomain,4>({{env1[0],env1[1],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(RamDomain(132)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_10_new_author->insert(tuple,READ_OP_CONTEXT(rel_10_new_author_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,133,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(296,_,@level_num_0),
   inv_0(v1,v0,_,@level_num_1),
   author(v1,v0,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [225:1-225:60])_");
if(!(rel_9_delta_author->empty()) && !(rel_5_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(296),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
CREATE_OP_CONTEXT(rel_10_new_author_op_ctxt,rel_10_new_author->createContext());
CREATE_OP_CONTEXT(rel_9_delta_author_op_ctxt,rel_9_delta_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_5_inv_0) {
const Tuple<RamDomain,4> key({{env1[0],env1[1],0,0}});
auto range = rel_9_delta_author->equalRange_3(key,READ_OP_CONTEXT(rel_9_delta_author_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_8_author->equalRange_3(Tuple<RamDomain,4>({{env1[1],env1[0],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(133)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_10_new_author->insert(tuple,READ_OP_CONTEXT(rel_10_new_author_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,134,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(298,_,@level_num_0),
   inv_0(v2,v1,_,@level_num_1),
   author(v0,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [226:1-226:60])_");
if(!(rel_9_delta_author->empty()) && !(rel_5_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(298),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
CREATE_OP_CONTEXT(rel_10_new_author_op_ctxt,rel_10_new_author->createContext());
CREATE_OP_CONTEXT(rel_9_delta_author_op_ctxt,rel_9_delta_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_5_inv_0) {
const Tuple<RamDomain,4> key({{0,env1[0],0,0}});
auto range = rel_9_delta_author->equalRange_2(key,READ_OP_CONTEXT(rel_9_delta_author_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_8_author->equalRange_3(Tuple<RamDomain,4>({{env2[0],env1[1],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(RamDomain(134)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_10_new_author->insert(tuple,READ_OP_CONTEXT(rel_10_new_author_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,135,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(299,_,@level_num_0),
   inv_0(v1,v2,_,@level_num_1),
   author(v2,v0,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [227:1-227:60])_");
if(!(rel_9_delta_author->empty()) && !(rel_5_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(299),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
CREATE_OP_CONTEXT(rel_10_new_author_op_ctxt,rel_10_new_author->createContext());
CREATE_OP_CONTEXT(rel_9_delta_author_op_ctxt,rel_9_delta_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_5_inv_0) {
const Tuple<RamDomain,4> key({{env1[1],0,0,0}});
auto range = rel_9_delta_author->equalRange_1(key,READ_OP_CONTEXT(rel_9_delta_author_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_8_author->equalRange_3(Tuple<RamDomain,4>({{env2[1],env1[0],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(135)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_10_new_author->insert(tuple,READ_OP_CONTEXT(rel_10_new_author_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,136,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(300,_,@level_num_0),
   inv_0(v2,v0,_,@level_num_1),
   author(v1,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [228:1-228:60])_");
if(!(rel_9_delta_author->empty()) && !(rel_5_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(300),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
CREATE_OP_CONTEXT(rel_10_new_author_op_ctxt,rel_10_new_author->createContext());
CREATE_OP_CONTEXT(rel_9_delta_author_op_ctxt,rel_9_delta_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_5_inv_0) {
const Tuple<RamDomain,4> key({{0,env1[0],0,0}});
auto range = rel_9_delta_author->equalRange_2(key,READ_OP_CONTEXT(rel_9_delta_author_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_8_author->equalRange_3(Tuple<RamDomain,4>({{env1[1],env2[0],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(RamDomain(136)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_10_new_author->insert(tuple,READ_OP_CONTEXT(rel_10_new_author_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,137,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(301,_,@level_num_0),
   inv_0(v2,v0,_,@level_num_1),
   author(v2,v1,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [229:1-229:60])_");
if(!(rel_9_delta_author->empty()) && !(rel_5_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(301),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
CREATE_OP_CONTEXT(rel_10_new_author_op_ctxt,rel_10_new_author->createContext());
CREATE_OP_CONTEXT(rel_9_delta_author_op_ctxt,rel_9_delta_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_5_inv_0) {
const Tuple<RamDomain,4> key({{env1[0],0,0,0}});
auto range = rel_9_delta_author->equalRange_1(key,READ_OP_CONTEXT(rel_9_delta_author_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_8_author->equalRange_3(Tuple<RamDomain,4>({{env1[1],env2[1],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(RamDomain(137)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_10_new_author->insert(tuple,READ_OP_CONTEXT(rel_10_new_author_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,138,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(302,_,@level_num_0),
   inv_0(v0,v2,_,@level_num_1),
   author(v1,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [230:1-230:60])_");
if(!(rel_9_delta_author->empty()) && !(rel_5_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(302),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
CREATE_OP_CONTEXT(rel_10_new_author_op_ctxt,rel_10_new_author->createContext());
CREATE_OP_CONTEXT(rel_9_delta_author_op_ctxt,rel_9_delta_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_5_inv_0) {
const Tuple<RamDomain,4> key({{0,env1[1],0,0}});
auto range = rel_9_delta_author->equalRange_2(key,READ_OP_CONTEXT(rel_9_delta_author_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_8_author->equalRange_3(Tuple<RamDomain,4>({{env1[0],env2[0],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(RamDomain(138)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_10_new_author->insert(tuple,READ_OP_CONTEXT(rel_10_new_author_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,139,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(303,_,@level_num_0),
   inv_0(v0,v2,_,@level_num_1),
   author(v2,v1,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [231:1-231:60])_");
if(!(rel_9_delta_author->empty()) && !(rel_5_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(303),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
CREATE_OP_CONTEXT(rel_10_new_author_op_ctxt,rel_10_new_author->createContext());
CREATE_OP_CONTEXT(rel_9_delta_author_op_ctxt,rel_9_delta_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_5_inv_0) {
const Tuple<RamDomain,4> key({{env1[1],0,0,0}});
auto range = rel_9_delta_author->equalRange_1(key,READ_OP_CONTEXT(rel_9_delta_author_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_8_author->equalRange_3(Tuple<RamDomain,4>({{env1[0],env2[1],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(RamDomain(139)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_10_new_author->insert(tuple,READ_OP_CONTEXT(rel_10_new_author_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,140,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(304,_,@level_num_0),
   inv_0(v2,v1,_,@level_num_1),
   author(v2,v0,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [232:1-232:60])_");
if(!(rel_9_delta_author->empty()) && !(rel_5_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(304),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
CREATE_OP_CONTEXT(rel_10_new_author_op_ctxt,rel_10_new_author->createContext());
CREATE_OP_CONTEXT(rel_9_delta_author_op_ctxt,rel_9_delta_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_5_inv_0) {
const Tuple<RamDomain,4> key({{env1[0],0,0,0}});
auto range = rel_9_delta_author->equalRange_1(key,READ_OP_CONTEXT(rel_9_delta_author_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_8_author->equalRange_3(Tuple<RamDomain,4>({{env2[1],env1[1],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(RamDomain(140)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_10_new_author->insert(tuple,READ_OP_CONTEXT(rel_10_new_author_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,141,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(305,_,@level_num_0),
   inv_0(v1,v2,_,@level_num_1),
   author(v0,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [233:1-233:60])_");
if(!(rel_9_delta_author->empty()) && !(rel_5_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(305),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
CREATE_OP_CONTEXT(rel_10_new_author_op_ctxt,rel_10_new_author->createContext());
CREATE_OP_CONTEXT(rel_9_delta_author_op_ctxt,rel_9_delta_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_5_inv_0) {
const Tuple<RamDomain,4> key({{0,env1[1],0,0}});
auto range = rel_9_delta_author->equalRange_2(key,READ_OP_CONTEXT(rel_9_delta_author_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_8_author->equalRange_3(Tuple<RamDomain,4>({{env2[0],env1[0],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(141)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_10_new_author->insert(tuple,READ_OP_CONTEXT(rel_10_new_author_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,142,(max(@level_num_0,@level_num_1)+1)) :- 
   Rule(308,_,@level_num_0),
   author(v1,v0,_,@level_num_1).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [234:1-234:61])_");
if(!(rel_9_delta_author->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(308),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
CREATE_OP_CONTEXT(rel_10_new_author_op_ctxt,rel_10_new_author->createContext());
CREATE_OP_CONTEXT(rel_9_delta_author_op_ctxt,rel_9_delta_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_9_delta_author) {
if( !([&]() -> bool {
auto existenceCheck = rel_8_author->equalRange_3(Tuple<RamDomain,4>({{env1[1],env1[0],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({env0[2], env1[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(142)),static_cast<RamDomain>((std::max({env0[2], env1[3], })) + (RamDomain(1)))}});
rel_10_new_author->insert(tuple,READ_OP_CONTEXT(rel_10_new_author_op_ctxt));
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,143,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(310,_,@level_num_0),
   author(v2,v1,_,@level_num_1),
   author(v0,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [235:1-235:61])_");
if(!(rel_8_author->empty()) && !(rel_9_delta_author->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(310),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
CREATE_OP_CONTEXT(rel_10_new_author_op_ctxt,rel_10_new_author->createContext());
CREATE_OP_CONTEXT(rel_9_delta_author_op_ctxt,rel_9_delta_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_9_delta_author) {
const Tuple<RamDomain,4> key({{0,env1[0],0,0}});
auto range = rel_8_author->equalRange_2(key,READ_OP_CONTEXT(rel_8_author_op_ctxt));
for(const auto& env2 : range) {
if( !(!rel_9_delta_author->equalRange_3(Tuple<RamDomain,4>({{env2[0],env1[0],0,0}}),READ_OP_CONTEXT(rel_9_delta_author_op_ctxt)).empty()) && !([&]() -> bool {
auto existenceCheck = rel_8_author->equalRange_3(Tuple<RamDomain,4>({{env2[0],env1[1],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(RamDomain(143)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_10_new_author->insert(tuple,READ_OP_CONTEXT(rel_10_new_author_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,143,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(310,_,@level_num_0),
   author(v2,v1,_,@level_num_1),
   author(v0,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [235:1-235:61])_");
if(!(rel_9_delta_author->empty()) && !(rel_8_author->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(310),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
CREATE_OP_CONTEXT(rel_10_new_author_op_ctxt,rel_10_new_author->createContext());
CREATE_OP_CONTEXT(rel_9_delta_author_op_ctxt,rel_9_delta_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_8_author) {
const Tuple<RamDomain,4> key({{0,env1[0],0,0}});
auto range = rel_9_delta_author->equalRange_2(key,READ_OP_CONTEXT(rel_9_delta_author_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_8_author->equalRange_3(Tuple<RamDomain,4>({{env2[0],env1[1],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(RamDomain(143)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_10_new_author->insert(tuple,READ_OP_CONTEXT(rel_10_new_author_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,144,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(311,_,@level_num_0),
   author(v1,v2,_,@level_num_1),
   author(v2,v0,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [236:1-236:61])_");
if(!(rel_8_author->empty()) && !(rel_9_delta_author->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(311),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
CREATE_OP_CONTEXT(rel_10_new_author_op_ctxt,rel_10_new_author->createContext());
CREATE_OP_CONTEXT(rel_9_delta_author_op_ctxt,rel_9_delta_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_9_delta_author) {
const Tuple<RamDomain,4> key({{env1[1],0,0,0}});
auto range = rel_8_author->equalRange_1(key,READ_OP_CONTEXT(rel_8_author_op_ctxt));
for(const auto& env2 : range) {
if( !(!rel_9_delta_author->equalRange_3(Tuple<RamDomain,4>({{env1[1],env2[1],0,0}}),READ_OP_CONTEXT(rel_9_delta_author_op_ctxt)).empty()) && !([&]() -> bool {
auto existenceCheck = rel_8_author->equalRange_3(Tuple<RamDomain,4>({{env2[1],env1[0],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(144)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_10_new_author->insert(tuple,READ_OP_CONTEXT(rel_10_new_author_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,144,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(311,_,@level_num_0),
   author(v1,v2,_,@level_num_1),
   author(v2,v0,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [236:1-236:61])_");
if(!(rel_9_delta_author->empty()) && !(rel_8_author->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(311),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
CREATE_OP_CONTEXT(rel_10_new_author_op_ctxt,rel_10_new_author->createContext());
CREATE_OP_CONTEXT(rel_9_delta_author_op_ctxt,rel_9_delta_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_8_author) {
const Tuple<RamDomain,4> key({{env1[1],0,0,0}});
auto range = rel_9_delta_author->equalRange_1(key,READ_OP_CONTEXT(rel_9_delta_author_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_8_author->equalRange_3(Tuple<RamDomain,4>({{env2[1],env1[0],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(144)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_10_new_author->insert(tuple,READ_OP_CONTEXT(rel_10_new_author_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,145,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(312,_,@level_num_0),
   author(v2,v0,_,@level_num_1),
   author(v1,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [237:1-237:61])_");
if(!(rel_8_author->empty()) && !(rel_9_delta_author->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(312),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
CREATE_OP_CONTEXT(rel_10_new_author_op_ctxt,rel_10_new_author->createContext());
CREATE_OP_CONTEXT(rel_9_delta_author_op_ctxt,rel_9_delta_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_9_delta_author) {
const Tuple<RamDomain,4> key({{0,env1[0],0,0}});
auto range = rel_8_author->equalRange_2(key,READ_OP_CONTEXT(rel_8_author_op_ctxt));
for(const auto& env2 : range) {
if( !(!rel_9_delta_author->equalRange_3(Tuple<RamDomain,4>({{env2[0],env1[0],0,0}}),READ_OP_CONTEXT(rel_9_delta_author_op_ctxt)).empty()) && !([&]() -> bool {
auto existenceCheck = rel_8_author->equalRange_3(Tuple<RamDomain,4>({{env1[1],env2[0],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(RamDomain(145)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_10_new_author->insert(tuple,READ_OP_CONTEXT(rel_10_new_author_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,145,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(312,_,@level_num_0),
   author(v2,v0,_,@level_num_1),
   author(v1,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [237:1-237:61])_");
if(!(rel_9_delta_author->empty()) && !(rel_8_author->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(312),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
CREATE_OP_CONTEXT(rel_10_new_author_op_ctxt,rel_10_new_author->createContext());
CREATE_OP_CONTEXT(rel_9_delta_author_op_ctxt,rel_9_delta_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_8_author) {
const Tuple<RamDomain,4> key({{0,env1[0],0,0}});
auto range = rel_9_delta_author->equalRange_2(key,READ_OP_CONTEXT(rel_9_delta_author_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_8_author->equalRange_3(Tuple<RamDomain,4>({{env1[1],env2[0],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(RamDomain(145)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_10_new_author->insert(tuple,READ_OP_CONTEXT(rel_10_new_author_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,146,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(313,_,@level_num_0),
   author(v2,v0,_,@level_num_1),
   author(v2,v1,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [238:1-238:61])_");
if(!(rel_8_author->empty()) && !(rel_9_delta_author->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(313),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
CREATE_OP_CONTEXT(rel_10_new_author_op_ctxt,rel_10_new_author->createContext());
CREATE_OP_CONTEXT(rel_9_delta_author_op_ctxt,rel_9_delta_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_9_delta_author) {
const Tuple<RamDomain,4> key({{env1[0],0,0,0}});
auto range = rel_8_author->equalRange_1(key,READ_OP_CONTEXT(rel_8_author_op_ctxt));
for(const auto& env2 : range) {
if( !(!rel_9_delta_author->equalRange_3(Tuple<RamDomain,4>({{env1[0],env2[1],0,0}}),READ_OP_CONTEXT(rel_9_delta_author_op_ctxt)).empty()) && !([&]() -> bool {
auto existenceCheck = rel_8_author->equalRange_3(Tuple<RamDomain,4>({{env1[1],env2[1],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(RamDomain(146)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_10_new_author->insert(tuple,READ_OP_CONTEXT(rel_10_new_author_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,146,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(313,_,@level_num_0),
   author(v2,v0,_,@level_num_1),
   author(v2,v1,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [238:1-238:61])_");
if(!(rel_9_delta_author->empty()) && !(rel_8_author->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(313),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
CREATE_OP_CONTEXT(rel_10_new_author_op_ctxt,rel_10_new_author->createContext());
CREATE_OP_CONTEXT(rel_9_delta_author_op_ctxt,rel_9_delta_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_8_author) {
const Tuple<RamDomain,4> key({{env1[0],0,0,0}});
auto range = rel_9_delta_author->equalRange_1(key,READ_OP_CONTEXT(rel_9_delta_author_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_8_author->equalRange_3(Tuple<RamDomain,4>({{env1[1],env2[1],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(RamDomain(146)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_10_new_author->insert(tuple,READ_OP_CONTEXT(rel_10_new_author_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,147,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(314,_,@level_num_0),
   author(v0,v2,_,@level_num_1),
   author(v1,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [239:1-239:61])_");
if(!(rel_8_author->empty()) && !(rel_9_delta_author->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(314),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
CREATE_OP_CONTEXT(rel_10_new_author_op_ctxt,rel_10_new_author->createContext());
CREATE_OP_CONTEXT(rel_9_delta_author_op_ctxt,rel_9_delta_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_9_delta_author) {
const Tuple<RamDomain,4> key({{0,env1[1],0,0}});
auto range = rel_8_author->equalRange_2(key,READ_OP_CONTEXT(rel_8_author_op_ctxt));
for(const auto& env2 : range) {
if( !(!rel_9_delta_author->equalRange_3(Tuple<RamDomain,4>({{env2[0],env1[1],0,0}}),READ_OP_CONTEXT(rel_9_delta_author_op_ctxt)).empty()) && !([&]() -> bool {
auto existenceCheck = rel_8_author->equalRange_3(Tuple<RamDomain,4>({{env1[0],env2[0],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(RamDomain(147)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_10_new_author->insert(tuple,READ_OP_CONTEXT(rel_10_new_author_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,147,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(314,_,@level_num_0),
   author(v0,v2,_,@level_num_1),
   author(v1,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [239:1-239:61])_");
if(!(rel_9_delta_author->empty()) && !(rel_8_author->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(314),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
CREATE_OP_CONTEXT(rel_10_new_author_op_ctxt,rel_10_new_author->createContext());
CREATE_OP_CONTEXT(rel_9_delta_author_op_ctxt,rel_9_delta_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_8_author) {
const Tuple<RamDomain,4> key({{0,env1[1],0,0}});
auto range = rel_9_delta_author->equalRange_2(key,READ_OP_CONTEXT(rel_9_delta_author_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_8_author->equalRange_3(Tuple<RamDomain,4>({{env1[0],env2[0],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(RamDomain(147)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_10_new_author->insert(tuple,READ_OP_CONTEXT(rel_10_new_author_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,148,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(315,_,@level_num_0),
   author(v0,v2,_,@level_num_1),
   author(v2,v1,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [240:1-240:61])_");
if(!(rel_8_author->empty()) && !(rel_9_delta_author->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(315),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
CREATE_OP_CONTEXT(rel_10_new_author_op_ctxt,rel_10_new_author->createContext());
CREATE_OP_CONTEXT(rel_9_delta_author_op_ctxt,rel_9_delta_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_9_delta_author) {
const Tuple<RamDomain,4> key({{env1[1],0,0,0}});
auto range = rel_8_author->equalRange_1(key,READ_OP_CONTEXT(rel_8_author_op_ctxt));
for(const auto& env2 : range) {
if( !(!rel_9_delta_author->equalRange_3(Tuple<RamDomain,4>({{env1[1],env2[1],0,0}}),READ_OP_CONTEXT(rel_9_delta_author_op_ctxt)).empty()) && !([&]() -> bool {
auto existenceCheck = rel_8_author->equalRange_3(Tuple<RamDomain,4>({{env1[0],env2[1],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(RamDomain(148)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_10_new_author->insert(tuple,READ_OP_CONTEXT(rel_10_new_author_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,148,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(315,_,@level_num_0),
   author(v0,v2,_,@level_num_1),
   author(v2,v1,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [240:1-240:61])_");
if(!(rel_9_delta_author->empty()) && !(rel_8_author->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(315),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
CREATE_OP_CONTEXT(rel_10_new_author_op_ctxt,rel_10_new_author->createContext());
CREATE_OP_CONTEXT(rel_9_delta_author_op_ctxt,rel_9_delta_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_8_author) {
const Tuple<RamDomain,4> key({{env1[1],0,0,0}});
auto range = rel_9_delta_author->equalRange_1(key,READ_OP_CONTEXT(rel_9_delta_author_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_8_author->equalRange_3(Tuple<RamDomain,4>({{env1[0],env2[1],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(RamDomain(148)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_10_new_author->insert(tuple,READ_OP_CONTEXT(rel_10_new_author_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,149,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(316,_,@level_num_0),
   author(v2,v1,_,@level_num_1),
   author(v2,v0,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [241:1-241:61])_");
if(!(rel_8_author->empty()) && !(rel_9_delta_author->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(316),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
CREATE_OP_CONTEXT(rel_10_new_author_op_ctxt,rel_10_new_author->createContext());
CREATE_OP_CONTEXT(rel_9_delta_author_op_ctxt,rel_9_delta_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_9_delta_author) {
const Tuple<RamDomain,4> key({{env1[0],0,0,0}});
auto range = rel_8_author->equalRange_1(key,READ_OP_CONTEXT(rel_8_author_op_ctxt));
for(const auto& env2 : range) {
if( !(!rel_9_delta_author->equalRange_3(Tuple<RamDomain,4>({{env1[0],env2[1],0,0}}),READ_OP_CONTEXT(rel_9_delta_author_op_ctxt)).empty()) && !([&]() -> bool {
auto existenceCheck = rel_8_author->equalRange_3(Tuple<RamDomain,4>({{env2[1],env1[1],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(RamDomain(149)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_10_new_author->insert(tuple,READ_OP_CONTEXT(rel_10_new_author_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,149,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(316,_,@level_num_0),
   author(v2,v1,_,@level_num_1),
   author(v2,v0,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [241:1-241:61])_");
if(!(rel_9_delta_author->empty()) && !(rel_8_author->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(316),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
CREATE_OP_CONTEXT(rel_10_new_author_op_ctxt,rel_10_new_author->createContext());
CREATE_OP_CONTEXT(rel_9_delta_author_op_ctxt,rel_9_delta_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_8_author) {
const Tuple<RamDomain,4> key({{env1[0],0,0,0}});
auto range = rel_9_delta_author->equalRange_1(key,READ_OP_CONTEXT(rel_9_delta_author_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_8_author->equalRange_3(Tuple<RamDomain,4>({{env2[1],env1[1],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[1]),static_cast<RamDomain>(env1[1]),static_cast<RamDomain>(RamDomain(149)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_10_new_author->insert(tuple,READ_OP_CONTEXT(rel_10_new_author_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,150,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(317,_,@level_num_0),
   author(v1,v2,_,@level_num_1),
   author(v0,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [242:1-242:61])_");
if(!(rel_8_author->empty()) && !(rel_9_delta_author->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(317),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
CREATE_OP_CONTEXT(rel_10_new_author_op_ctxt,rel_10_new_author->createContext());
CREATE_OP_CONTEXT(rel_9_delta_author_op_ctxt,rel_9_delta_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_9_delta_author) {
const Tuple<RamDomain,4> key({{0,env1[1],0,0}});
auto range = rel_8_author->equalRange_2(key,READ_OP_CONTEXT(rel_8_author_op_ctxt));
for(const auto& env2 : range) {
if( !(!rel_9_delta_author->equalRange_3(Tuple<RamDomain,4>({{env2[0],env1[1],0,0}}),READ_OP_CONTEXT(rel_9_delta_author_op_ctxt)).empty()) && !([&]() -> bool {
auto existenceCheck = rel_8_author->equalRange_3(Tuple<RamDomain,4>({{env2[0],env1[0],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(150)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_10_new_author->insert(tuple,READ_OP_CONTEXT(rel_10_new_author_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
SignalHandler::instance()->setMsg(R"_(author(v0,v1,150,(max(max(@level_num_0,@level_num_1),@level_num_2)+1)) :- 
   Rule(317,_,@level_num_0),
   author(v1,v2,_,@level_num_1),
   author(v0,v2,_,@level_num_2).
in file /home/johannes_tantow/DatalogLearning/prosynth/bookneg5/rules.dl [242:1-242:61])_");
if(!(rel_9_delta_author->empty()) && !(rel_8_author->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(317),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
CREATE_OP_CONTEXT(rel_10_new_author_op_ctxt,rel_10_new_author->createContext());
CREATE_OP_CONTEXT(rel_9_delta_author_op_ctxt,rel_9_delta_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
for(const auto& env1 : *rel_8_author) {
const Tuple<RamDomain,4> key({{0,env1[1],0,0}});
auto range = rel_9_delta_author->equalRange_2(key,READ_OP_CONTEXT(rel_9_delta_author_op_ctxt));
for(const auto& env2 : range) {
if( !([&]() -> bool {
auto existenceCheck = rel_8_author->equalRange_3(Tuple<RamDomain,4>({{env2[0],env1[0],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt));
if (existenceCheck.empty()) return false; else return (*existenceCheck.begin())[3] <= (std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1));}()
)) {
Tuple<RamDomain,4> tuple({{static_cast<RamDomain>(env2[0]),static_cast<RamDomain>(env1[0]),static_cast<RamDomain>(RamDomain(150)),static_cast<RamDomain>((std::max({std::max({env0[2], env1[3], }), env2[3], })) + (RamDomain(1)))}});
rel_10_new_author->insert(tuple,READ_OP_CONTEXT(rel_10_new_author_op_ctxt));
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
if(rel_10_new_author->empty()) break;
rel_8_author->insertAll(*rel_10_new_author);
std::swap(rel_9_delta_author, rel_10_new_author);
rel_10_new_author->purge();
iter++;
}
iter = 0;
if (!isHintsProfilingEnabled()) rel_9_delta_author->purge();
if (!isHintsProfilingEnabled()) rel_10_new_author->purge();
if (performIO) {
try {std::map<std::string, std::string> directiveMap({{"IO","file"},{"attributeNames","v0\tv1"},{"filename","./author.csv"},{"name","author"}});
if (!outputDirectory.empty() && directiveMap["IO"] == "file" && directiveMap["filename"].front() != '/') {directiveMap["filename"] = outputDirectory + "/" + directiveMap["filename"];}
IODirectives ioDirectives(directiveMap);
IOSystem::getInstance().getWriter(std::vector<bool>({1,1,0,0}), symTable, ioDirectives, true)->writeAll(*rel_8_author);
} catch (std::exception& e) {std::cerr << e.what();exit(1);}
}
}();
/* END STRATUM 5 */
/* BEGIN STRATUM 6 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.1(1,"v0,v1","Rule","precededBy,v0,v1","author(v0,v1) :- 
   Rule(128),
   precededBy(v0,v1).").
in file  [0:0-0:0])_");
rel_11_author_info_1->insert(RamDomain(1),RamDomain(0),RamDomain(1),RamDomain(2),RamDomain(3));
}();
/* END STRATUM 6 */
/* BEGIN STRATUM 7 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.10(10,"v0,v1","Rule","precededBy,v1,v0","author(v0,v1) :- 
   Rule(140),
   precededBy(v1,v0).").
in file  [0:0-0:0])_");
rel_12_author_info_10->insert(RamDomain(10),RamDomain(0),RamDomain(1),RamDomain(4),RamDomain(18));
}();
/* END STRATUM 7 */
/* BEGIN STRATUM 8 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.100(100,"v0,v1","Rule","genre,v0,v2","author,v1,v2","author(v0,v1) :- 
   Rule(242),
   genre(v0,v2),
   author(v1,v2).").
in file  [0:0-0:0])_");
rel_13_author_info_100->insert(RamDomain(100),RamDomain(0),RamDomain(1),RamDomain(36),RamDomain(82),RamDomain(128));
}();
/* END STRATUM 8 */
/* BEGIN STRATUM 9 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.101(101,"v0,v1","Rule","genre,v0,v2","author,v2,v1","author(v0,v1) :- 
   Rule(243),
   genre(v0,v2),
   author(v2,v1).").
in file  [0:0-0:0])_");
rel_14_author_info_101->insert(RamDomain(101),RamDomain(0),RamDomain(1),RamDomain(36),RamDomain(84),RamDomain(129));
}();
/* END STRATUM 9 */
/* BEGIN STRATUM 10 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.102(102,"v0,v1","Rule","genre,v2,v1","author,v2,v0","author(v0,v1) :- 
   Rule(244),
   genre(v2,v1),
   author(v2,v0).").
in file  [0:0-0:0])_");
rel_15_author_info_102->insert(RamDomain(102),RamDomain(0),RamDomain(1),RamDomain(42),RamDomain(80),RamDomain(130));
}();
/* END STRATUM 10 */
/* BEGIN STRATUM 11 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.103(103,"v0,v1","Rule","genre,v1,v2","author,v0,v2","author(v0,v1) :- 
   Rule(245),
   genre(v1,v2),
   author(v0,v2).").
in file  [0:0-0:0])_");
rel_16_author_info_103->insert(RamDomain(103),RamDomain(0),RamDomain(1),RamDomain(40),RamDomain(78),RamDomain(131));
}();
/* END STRATUM 11 */
/* BEGIN STRATUM 12 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.104(104,"v0,v1","Rule","Iauthor,v2,v1","Iauthor,v0,v2","author(v0,v1) :- 
   Rule(250),
   Iauthor(v2,v1),
   Iauthor(v0,v2).").
in file  [0:0-0:0])_");
rel_17_author_info_104->insert(RamDomain(104),RamDomain(0),RamDomain(1),RamDomain(54),RamDomain(48),RamDomain(132));
}();
/* END STRATUM 12 */
/* BEGIN STRATUM 13 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.105(105,"v0,v1","Rule","Iauthor,v1,v2","Iauthor,v2,v0","author(v0,v1) :- 
   Rule(251),
   Iauthor(v1,v2),
   Iauthor(v2,v0).").
in file  [0:0-0:0])_");
rel_18_author_info_105->insert(RamDomain(105),RamDomain(0),RamDomain(1),RamDomain(52),RamDomain(50),RamDomain(133));
}();
/* END STRATUM 13 */
/* BEGIN STRATUM 14 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.106(106,"v0,v1","Rule","Iauthor,v2,v0","Iauthor,v1,v2","author(v0,v1) :- 
   Rule(252),
   Iauthor(v2,v0),
   Iauthor(v1,v2).").
in file  [0:0-0:0])_");
rel_19_author_info_106->insert(RamDomain(106),RamDomain(0),RamDomain(1),RamDomain(50),RamDomain(52),RamDomain(134));
}();
/* END STRATUM 14 */
/* BEGIN STRATUM 15 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.107(107,"v0,v1","Rule","Iauthor,v2,v0","Iauthor,v2,v1","author(v0,v1) :- 
   Rule(253),
   Iauthor(v2,v0),
   Iauthor(v2,v1).").
in file  [0:0-0:0])_");
rel_20_author_info_107->insert(RamDomain(107),RamDomain(0),RamDomain(1),RamDomain(50),RamDomain(54),RamDomain(135));
}();
/* END STRATUM 15 */
/* BEGIN STRATUM 16 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.108(108,"v0,v1","Rule","Iauthor,v0,v2","Iauthor,v1,v2","author(v0,v1) :- 
   Rule(254),
   Iauthor(v0,v2),
   Iauthor(v1,v2).").
in file  [0:0-0:0])_");
rel_21_author_info_108->insert(RamDomain(108),RamDomain(0),RamDomain(1),RamDomain(48),RamDomain(52),RamDomain(136));
}();
/* END STRATUM 16 */
/* BEGIN STRATUM 17 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.109(109,"v0,v1","Rule","Iauthor,v0,v2","Iauthor,v2,v1","author(v0,v1) :- 
   Rule(255),
   Iauthor(v0,v2),
   Iauthor(v2,v1).").
in file  [0:0-0:0])_");
rel_22_author_info_109->insert(RamDomain(109),RamDomain(0),RamDomain(1),RamDomain(48),RamDomain(54),RamDomain(137));
}();
/* END STRATUM 17 */
/* BEGIN STRATUM 18 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.11(11,"v0,v1","Rule","precededBy,v1,v0","precededBy,v0,v1","author(v0,v1) :- 
   Rule(141),
   precededBy(v1,v0),
   precededBy(v0,v1).").
in file  [0:0-0:0])_");
rel_23_author_info_11->insert(RamDomain(11),RamDomain(0),RamDomain(1),RamDomain(4),RamDomain(2),RamDomain(19));
}();
/* END STRATUM 18 */
/* BEGIN STRATUM 19 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.110(110,"v0,v1","Rule","Iauthor,v2,v1","Iauthor,v2,v0","author(v0,v1) :- 
   Rule(256),
   Iauthor(v2,v1),
   Iauthor(v2,v0).").
in file  [0:0-0:0])_");
rel_24_author_info_110->insert(RamDomain(110),RamDomain(0),RamDomain(1),RamDomain(54),RamDomain(50),RamDomain(138));
}();
/* END STRATUM 19 */
/* BEGIN STRATUM 20 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.111(111,"v0,v1","Rule","Iauthor,v1,v2","Iauthor,v0,v2","author(v0,v1) :- 
   Rule(257),
   Iauthor(v1,v2),
   Iauthor(v0,v2).").
in file  [0:0-0:0])_");
rel_25_author_info_111->insert(RamDomain(111),RamDomain(0),RamDomain(1),RamDomain(52),RamDomain(48),RamDomain(139));
}();
/* END STRATUM 20 */
/* BEGIN STRATUM 21 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.112(112,"v0,v1","Rule","Iauthor,v2,v1","author,v0,v2","author(v0,v1) :- 
   Rule(274),
   Iauthor(v2,v1),
   author(v0,v2).").
in file  [0:0-0:0])_");
rel_26_author_info_112->insert(RamDomain(112),RamDomain(0),RamDomain(1),RamDomain(54),RamDomain(78),RamDomain(140));
}();
/* END STRATUM 21 */
/* BEGIN STRATUM 22 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.113(113,"v0,v1","Rule","Iauthor,v1,v2","author,v2,v0","author(v0,v1) :- 
   Rule(275),
   Iauthor(v1,v2),
   author(v2,v0).").
in file  [0:0-0:0])_");
rel_27_author_info_113->insert(RamDomain(113),RamDomain(0),RamDomain(1),RamDomain(52),RamDomain(80),RamDomain(141));
}();
/* END STRATUM 22 */
/* BEGIN STRATUM 23 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.114(114,"v0,v1","Rule","Iauthor,v2,v0","author,v1,v2","author(v0,v1) :- 
   Rule(276),
   Iauthor(v2,v0),
   author(v1,v2).").
in file  [0:0-0:0])_");
rel_28_author_info_114->insert(RamDomain(114),RamDomain(0),RamDomain(1),RamDomain(50),RamDomain(82),RamDomain(142));
}();
/* END STRATUM 23 */
/* BEGIN STRATUM 24 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.115(115,"v0,v1","Rule","Iauthor,v2,v0","author,v2,v1","author(v0,v1) :- 
   Rule(277),
   Iauthor(v2,v0),
   author(v2,v1).").
in file  [0:0-0:0])_");
rel_29_author_info_115->insert(RamDomain(115),RamDomain(0),RamDomain(1),RamDomain(50),RamDomain(84),RamDomain(143));
}();
/* END STRATUM 24 */
/* BEGIN STRATUM 25 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.116(116,"v0,v1","Rule","Iauthor,v0,v2","author,v1,v2","author(v0,v1) :- 
   Rule(278),
   Iauthor(v0,v2),
   author(v1,v2).").
in file  [0:0-0:0])_");
rel_30_author_info_116->insert(RamDomain(116),RamDomain(0),RamDomain(1),RamDomain(48),RamDomain(82),RamDomain(144));
}();
/* END STRATUM 25 */
/* BEGIN STRATUM 26 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.117(117,"v0,v1","Rule","Iauthor,v0,v2","author,v2,v1","author(v0,v1) :- 
   Rule(279),
   Iauthor(v0,v2),
   author(v2,v1).").
in file  [0:0-0:0])_");
rel_31_author_info_117->insert(RamDomain(117),RamDomain(0),RamDomain(1),RamDomain(48),RamDomain(84),RamDomain(145));
}();
/* END STRATUM 26 */
/* BEGIN STRATUM 27 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.118(118,"v0,v1","Rule","Iauthor,v2,v1","author,v2,v0","author(v0,v1) :- 
   Rule(280),
   Iauthor(v2,v1),
   author(v2,v0).").
in file  [0:0-0:0])_");
rel_32_author_info_118->insert(RamDomain(118),RamDomain(0),RamDomain(1),RamDomain(54),RamDomain(80),RamDomain(146));
}();
/* END STRATUM 27 */
/* BEGIN STRATUM 28 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.119(119,"v0,v1","Rule","Iauthor,v1,v2","author,v0,v2","author(v0,v1) :- 
   Rule(281),
   Iauthor(v1,v2),
   author(v0,v2).").
in file  [0:0-0:0])_");
rel_33_author_info_119->insert(RamDomain(119),RamDomain(0),RamDomain(1),RamDomain(52),RamDomain(78),RamDomain(147));
}();
/* END STRATUM 28 */
/* BEGIN STRATUM 29 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.12(12,"v0,v1","Rule","precededBy,v2,v1","precededBy,v0,v2","author(v0,v1) :- 
   Rule(142),
   precededBy(v2,v1),
   precededBy(v0,v2).").
in file  [0:0-0:0])_");
rel_34_author_info_12->insert(RamDomain(12),RamDomain(0),RamDomain(1),RamDomain(20),RamDomain(21),RamDomain(22));
}();
/* END STRATUM 29 */
/* BEGIN STRATUM 30 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.120(120,"v0,v1","Rule","inv_0,v0,v1","author(v0,v1) :- 
   Rule(282),
   inv_0(v0,v1).").
in file  [0:0-0:0])_");
rel_35_author_info_120->insert(RamDomain(120),RamDomain(0),RamDomain(1),RamDomain(10),RamDomain(148));
}();
/* END STRATUM 30 */
/* BEGIN STRATUM 31 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.121(121,"v0,v1","Rule","inv_0,v0,v1","inv_0,v1,v0","author(v0,v1) :- 
   Rule(283),
   inv_0(v0,v1),
   inv_0(v1,v0).").
in file  [0:0-0:0])_");
rel_36_author_info_121->insert(RamDomain(121),RamDomain(0),RamDomain(1),RamDomain(10),RamDomain(12),RamDomain(149));
}();
/* END STRATUM 31 */
/* BEGIN STRATUM 32 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.122(122,"v0,v1","Rule","inv_0,v1,v0","author(v0,v1) :- 
   Rule(284),
   inv_0(v1,v0).").
in file  [0:0-0:0])_");
rel_37_author_info_122->insert(RamDomain(122),RamDomain(0),RamDomain(1),RamDomain(12),RamDomain(150));
}();
/* END STRATUM 32 */
/* BEGIN STRATUM 33 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.123(123,"v0,v1","Rule","inv_0,v1,v0","inv_0,v0,v1","author(v0,v1) :- 
   Rule(285),
   inv_0(v1,v0),
   inv_0(v0,v1).").
in file  [0:0-0:0])_");
rel_38_author_info_123->insert(RamDomain(123),RamDomain(0),RamDomain(1),RamDomain(12),RamDomain(10),RamDomain(151));
}();
/* END STRATUM 33 */
/* BEGIN STRATUM 34 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.124(124,"v0,v1","Rule","inv_0,v2,v1","inv_0,v0,v2","author(v0,v1) :- 
   Rule(286),
   inv_0(v2,v1),
   inv_0(v0,v2).").
in file  [0:0-0:0])_");
rel_39_author_info_124->insert(RamDomain(124),RamDomain(0),RamDomain(1),RamDomain(70),RamDomain(64),RamDomain(152));
}();
/* END STRATUM 34 */
/* BEGIN STRATUM 35 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.125(125,"v0,v1","Rule","inv_0,v1,v2","inv_0,v2,v0","author(v0,v1) :- 
   Rule(287),
   inv_0(v1,v2),
   inv_0(v2,v0).").
in file  [0:0-0:0])_");
rel_40_author_info_125->insert(RamDomain(125),RamDomain(0),RamDomain(1),RamDomain(68),RamDomain(66),RamDomain(153));
}();
/* END STRATUM 35 */
/* BEGIN STRATUM 36 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.126(126,"v0,v1","Rule","inv_0,v2,v0","inv_0,v1,v2","author(v0,v1) :- 
   Rule(288),
   inv_0(v2,v0),
   inv_0(v1,v2).").
in file  [0:0-0:0])_");
rel_41_author_info_126->insert(RamDomain(126),RamDomain(0),RamDomain(1),RamDomain(66),RamDomain(68),RamDomain(154));
}();
/* END STRATUM 36 */
/* BEGIN STRATUM 37 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.127(127,"v0,v1","Rule","inv_0,v2,v0","inv_0,v2,v1","author(v0,v1) :- 
   Rule(289),
   inv_0(v2,v0),
   inv_0(v2,v1).").
in file  [0:0-0:0])_");
rel_42_author_info_127->insert(RamDomain(127),RamDomain(0),RamDomain(1),RamDomain(66),RamDomain(70),RamDomain(155));
}();
/* END STRATUM 37 */
/* BEGIN STRATUM 38 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.128(128,"v0,v1","Rule","inv_0,v0,v2","inv_0,v1,v2","author(v0,v1) :- 
   Rule(290),
   inv_0(v0,v2),
   inv_0(v1,v2).").
in file  [0:0-0:0])_");
rel_43_author_info_128->insert(RamDomain(128),RamDomain(0),RamDomain(1),RamDomain(64),RamDomain(68),RamDomain(156));
}();
/* END STRATUM 38 */
/* BEGIN STRATUM 39 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.129(129,"v0,v1","Rule","inv_0,v0,v2","inv_0,v2,v1","author(v0,v1) :- 
   Rule(291),
   inv_0(v0,v2),
   inv_0(v2,v1).").
in file  [0:0-0:0])_");
rel_44_author_info_129->insert(RamDomain(129),RamDomain(0),RamDomain(1),RamDomain(64),RamDomain(70),RamDomain(157));
}();
/* END STRATUM 39 */
/* BEGIN STRATUM 40 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.13(13,"v0,v1","Rule","precededBy,v1,v2","precededBy,v2,v0","author(v0,v1) :- 
   Rule(143),
   precededBy(v1,v2),
   precededBy(v2,v0).").
in file  [0:0-0:0])_");
rel_45_author_info_13->insert(RamDomain(13),RamDomain(0),RamDomain(1),RamDomain(23),RamDomain(24),RamDomain(25));
}();
/* END STRATUM 40 */
/* BEGIN STRATUM 41 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.130(130,"v0,v1","Rule","inv_0,v2,v1","inv_0,v2,v0","author(v0,v1) :- 
   Rule(292),
   inv_0(v2,v1),
   inv_0(v2,v0).").
in file  [0:0-0:0])_");
rel_46_author_info_130->insert(RamDomain(130),RamDomain(0),RamDomain(1),RamDomain(70),RamDomain(66),RamDomain(158));
}();
/* END STRATUM 41 */
/* BEGIN STRATUM 42 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.131(131,"v0,v1","Rule","inv_0,v1,v2","inv_0,v0,v2","author(v0,v1) :- 
   Rule(293),
   inv_0(v1,v2),
   inv_0(v0,v2).").
in file  [0:0-0:0])_");
rel_47_author_info_131->insert(RamDomain(131),RamDomain(0),RamDomain(1),RamDomain(68),RamDomain(64),RamDomain(159));
}();
/* END STRATUM 42 */
/* BEGIN STRATUM 43 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.132(132,"v0,v1","Rule","inv_0,v0,v1","author,v1,v0","author(v0,v1) :- 
   Rule(295),
   inv_0(v0,v1),
   author(v1,v0).").
in file  [0:0-0:0])_");
rel_48_author_info_132->insert(RamDomain(132),RamDomain(0),RamDomain(1),RamDomain(10),RamDomain(14),RamDomain(160));
}();
/* END STRATUM 43 */
/* BEGIN STRATUM 44 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.133(133,"v0,v1","Rule","inv_0,v1,v0","author,v1,v0","author(v0,v1) :- 
   Rule(296),
   inv_0(v1,v0),
   author(v1,v0).").
in file  [0:0-0:0])_");
rel_49_author_info_133->insert(RamDomain(133),RamDomain(0),RamDomain(1),RamDomain(12),RamDomain(14),RamDomain(161));
}();
/* END STRATUM 44 */
/* BEGIN STRATUM 45 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.134(134,"v0,v1","Rule","inv_0,v2,v1","author,v0,v2","author(v0,v1) :- 
   Rule(298),
   inv_0(v2,v1),
   author(v0,v2).").
in file  [0:0-0:0])_");
rel_50_author_info_134->insert(RamDomain(134),RamDomain(0),RamDomain(1),RamDomain(70),RamDomain(78),RamDomain(162));
}();
/* END STRATUM 45 */
/* BEGIN STRATUM 46 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.135(135,"v0,v1","Rule","inv_0,v1,v2","author,v2,v0","author(v0,v1) :- 
   Rule(299),
   inv_0(v1,v2),
   author(v2,v0).").
in file  [0:0-0:0])_");
rel_51_author_info_135->insert(RamDomain(135),RamDomain(0),RamDomain(1),RamDomain(68),RamDomain(80),RamDomain(163));
}();
/* END STRATUM 46 */
/* BEGIN STRATUM 47 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.136(136,"v0,v1","Rule","inv_0,v2,v0","author,v1,v2","author(v0,v1) :- 
   Rule(300),
   inv_0(v2,v0),
   author(v1,v2).").
in file  [0:0-0:0])_");
rel_52_author_info_136->insert(RamDomain(136),RamDomain(0),RamDomain(1),RamDomain(66),RamDomain(82),RamDomain(164));
}();
/* END STRATUM 47 */
/* BEGIN STRATUM 48 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.137(137,"v0,v1","Rule","inv_0,v2,v0","author,v2,v1","author(v0,v1) :- 
   Rule(301),
   inv_0(v2,v0),
   author(v2,v1).").
in file  [0:0-0:0])_");
rel_53_author_info_137->insert(RamDomain(137),RamDomain(0),RamDomain(1),RamDomain(66),RamDomain(84),RamDomain(165));
}();
/* END STRATUM 48 */
/* BEGIN STRATUM 49 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.138(138,"v0,v1","Rule","inv_0,v0,v2","author,v1,v2","author(v0,v1) :- 
   Rule(302),
   inv_0(v0,v2),
   author(v1,v2).").
in file  [0:0-0:0])_");
rel_54_author_info_138->insert(RamDomain(138),RamDomain(0),RamDomain(1),RamDomain(64),RamDomain(82),RamDomain(166));
}();
/* END STRATUM 49 */
/* BEGIN STRATUM 50 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.139(139,"v0,v1","Rule","inv_0,v0,v2","author,v2,v1","author(v0,v1) :- 
   Rule(303),
   inv_0(v0,v2),
   author(v2,v1).").
in file  [0:0-0:0])_");
rel_55_author_info_139->insert(RamDomain(139),RamDomain(0),RamDomain(1),RamDomain(64),RamDomain(84),RamDomain(167));
}();
/* END STRATUM 50 */
/* BEGIN STRATUM 51 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.14(14,"v0,v1","Rule","precededBy,v2,v0","precededBy,v1,v2","author(v0,v1) :- 
   Rule(144),
   precededBy(v2,v0),
   precededBy(v1,v2).").
in file  [0:0-0:0])_");
rel_56_author_info_14->insert(RamDomain(14),RamDomain(0),RamDomain(1),RamDomain(24),RamDomain(23),RamDomain(26));
}();
/* END STRATUM 51 */
/* BEGIN STRATUM 52 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.140(140,"v0,v1","Rule","inv_0,v2,v1","author,v2,v0","author(v0,v1) :- 
   Rule(304),
   inv_0(v2,v1),
   author(v2,v0).").
in file  [0:0-0:0])_");
rel_57_author_info_140->insert(RamDomain(140),RamDomain(0),RamDomain(1),RamDomain(70),RamDomain(80),RamDomain(168));
}();
/* END STRATUM 52 */
/* BEGIN STRATUM 53 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.141(141,"v0,v1","Rule","inv_0,v1,v2","author,v0,v2","author(v0,v1) :- 
   Rule(305),
   inv_0(v1,v2),
   author(v0,v2).").
in file  [0:0-0:0])_");
rel_58_author_info_141->insert(RamDomain(141),RamDomain(0),RamDomain(1),RamDomain(68),RamDomain(78),RamDomain(169));
}();
/* END STRATUM 53 */
/* BEGIN STRATUM 54 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.142(142,"v0,v1","Rule","author,v1,v0","author(v0,v1) :- 
   Rule(308),
   author(v1,v0).").
in file  [0:0-0:0])_");
rel_59_author_info_142->insert(RamDomain(142),RamDomain(0),RamDomain(1),RamDomain(14),RamDomain(170));
}();
/* END STRATUM 54 */
/* BEGIN STRATUM 55 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.143(143,"v0,v1","Rule","author,v2,v1","author,v0,v2","author(v0,v1) :- 
   Rule(310),
   author(v2,v1),
   author(v0,v2).").
in file  [0:0-0:0])_");
rel_60_author_info_143->insert(RamDomain(143),RamDomain(0),RamDomain(1),RamDomain(84),RamDomain(78),RamDomain(171));
}();
/* END STRATUM 55 */
/* BEGIN STRATUM 56 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.144(144,"v0,v1","Rule","author,v1,v2","author,v2,v0","author(v0,v1) :- 
   Rule(311),
   author(v1,v2),
   author(v2,v0).").
in file  [0:0-0:0])_");
rel_61_author_info_144->insert(RamDomain(144),RamDomain(0),RamDomain(1),RamDomain(82),RamDomain(80),RamDomain(172));
}();
/* END STRATUM 56 */
/* BEGIN STRATUM 57 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.145(145,"v0,v1","Rule","author,v2,v0","author,v1,v2","author(v0,v1) :- 
   Rule(312),
   author(v2,v0),
   author(v1,v2).").
in file  [0:0-0:0])_");
rel_62_author_info_145->insert(RamDomain(145),RamDomain(0),RamDomain(1),RamDomain(80),RamDomain(82),RamDomain(173));
}();
/* END STRATUM 57 */
/* BEGIN STRATUM 58 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.146(146,"v0,v1","Rule","author,v2,v0","author,v2,v1","author(v0,v1) :- 
   Rule(313),
   author(v2,v0),
   author(v2,v1).").
in file  [0:0-0:0])_");
rel_63_author_info_146->insert(RamDomain(146),RamDomain(0),RamDomain(1),RamDomain(80),RamDomain(84),RamDomain(174));
}();
/* END STRATUM 58 */
/* BEGIN STRATUM 59 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.147(147,"v0,v1","Rule","author,v0,v2","author,v1,v2","author(v0,v1) :- 
   Rule(314),
   author(v0,v2),
   author(v1,v2).").
in file  [0:0-0:0])_");
rel_64_author_info_147->insert(RamDomain(147),RamDomain(0),RamDomain(1),RamDomain(78),RamDomain(82),RamDomain(175));
}();
/* END STRATUM 59 */
/* BEGIN STRATUM 60 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.148(148,"v0,v1","Rule","author,v0,v2","author,v2,v1","author(v0,v1) :- 
   Rule(315),
   author(v0,v2),
   author(v2,v1).").
in file  [0:0-0:0])_");
rel_65_author_info_148->insert(RamDomain(148),RamDomain(0),RamDomain(1),RamDomain(78),RamDomain(84),RamDomain(176));
}();
/* END STRATUM 60 */
/* BEGIN STRATUM 61 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.149(149,"v0,v1","Rule","author,v2,v1","author,v2,v0","author(v0,v1) :- 
   Rule(316),
   author(v2,v1),
   author(v2,v0).").
in file  [0:0-0:0])_");
rel_66_author_info_149->insert(RamDomain(149),RamDomain(0),RamDomain(1),RamDomain(84),RamDomain(80),RamDomain(177));
}();
/* END STRATUM 61 */
/* BEGIN STRATUM 62 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.15(15,"v0,v1","Rule","precededBy,v2,v0","precededBy,v2,v1","author(v0,v1) :- 
   Rule(145),
   precededBy(v2,v0),
   precededBy(v2,v1).").
in file  [0:0-0:0])_");
rel_67_author_info_15->insert(RamDomain(15),RamDomain(0),RamDomain(1),RamDomain(24),RamDomain(20),RamDomain(27));
}();
/* END STRATUM 62 */
/* BEGIN STRATUM 63 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.150(150,"v0,v1","Rule","author,v1,v2","author,v0,v2","author(v0,v1) :- 
   Rule(317),
   author(v1,v2),
   author(v0,v2).").
in file  [0:0-0:0])_");
rel_68_author_info_150->insert(RamDomain(150),RamDomain(0),RamDomain(1),RamDomain(82),RamDomain(78),RamDomain(178));
}();
/* END STRATUM 63 */
/* BEGIN STRATUM 64 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.16(16,"v0,v1","Rule","precededBy,v0,v2","precededBy,v1,v2","author(v0,v1) :- 
   Rule(146),
   precededBy(v0,v2),
   precededBy(v1,v2).").
in file  [0:0-0:0])_");
rel_69_author_info_16->insert(RamDomain(16),RamDomain(0),RamDomain(1),RamDomain(21),RamDomain(23),RamDomain(28));
}();
/* END STRATUM 64 */
/* BEGIN STRATUM 65 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.17(17,"v0,v1","Rule","precededBy,v0,v2","precededBy,v2,v1","author(v0,v1) :- 
   Rule(147),
   precededBy(v0,v2),
   precededBy(v2,v1).").
in file  [0:0-0:0])_");
rel_70_author_info_17->insert(RamDomain(17),RamDomain(0),RamDomain(1),RamDomain(21),RamDomain(20),RamDomain(29));
}();
/* END STRATUM 65 */
/* BEGIN STRATUM 66 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.18(18,"v0,v1","Rule","precededBy,v2,v1","precededBy,v2,v0","author(v0,v1) :- 
   Rule(148),
   precededBy(v2,v1),
   precededBy(v2,v0).").
in file  [0:0-0:0])_");
rel_71_author_info_18->insert(RamDomain(18),RamDomain(0),RamDomain(1),RamDomain(20),RamDomain(24),RamDomain(30));
}();
/* END STRATUM 66 */
/* BEGIN STRATUM 67 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.19(19,"v0,v1","Rule","precededBy,v1,v2","precededBy,v0,v2","author(v0,v1) :- 
   Rule(149),
   precededBy(v1,v2),
   precededBy(v0,v2).").
in file  [0:0-0:0])_");
rel_72_author_info_19->insert(RamDomain(19),RamDomain(0),RamDomain(1),RamDomain(23),RamDomain(21),RamDomain(31));
}();
/* END STRATUM 67 */
/* BEGIN STRATUM 68 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.2(2,"v0,v1","Rule","precededBy,v1,v0","author(v0,v1) :- 
   Rule(129),
   precededBy(v1,v0).").
in file  [0:0-0:0])_");
rel_73_author_info_2->insert(RamDomain(2),RamDomain(0),RamDomain(1),RamDomain(4),RamDomain(5));
}();
/* END STRATUM 68 */
/* BEGIN STRATUM 69 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.20(20,"v0,v1","Rule","precededBy,v0,v1","genre,v0,v1","author(v0,v1) :- 
   Rule(150),
   precededBy(v0,v1),
   genre(v0,v1).").
in file  [0:0-0:0])_");
rel_74_author_info_20->insert(RamDomain(20),RamDomain(0),RamDomain(1),RamDomain(2),RamDomain(6),RamDomain(32));
}();
/* END STRATUM 69 */
/* BEGIN STRATUM 70 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.21(21,"v0,v1","Rule","precededBy,v0,v1","genre,v1,v0","author(v0,v1) :- 
   Rule(151),
   precededBy(v0,v1),
   genre(v1,v0).").
in file  [0:0-0:0])_");
rel_75_author_info_21->insert(RamDomain(21),RamDomain(0),RamDomain(1),RamDomain(2),RamDomain(8),RamDomain(33));
}();
/* END STRATUM 70 */
/* BEGIN STRATUM 71 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.22(22,"v0,v1","Rule","precededBy,v1,v0","genre,v1,v0","author(v0,v1) :- 
   Rule(152),
   precededBy(v1,v0),
   genre(v1,v0).").
in file  [0:0-0:0])_");
rel_76_author_info_22->insert(RamDomain(22),RamDomain(0),RamDomain(1),RamDomain(4),RamDomain(8),RamDomain(34));
}();
/* END STRATUM 71 */
/* BEGIN STRATUM 72 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.23(23,"v0,v1","Rule","precededBy,v1,v0","genre,v0,v1","author(v0,v1) :- 
   Rule(153),
   precededBy(v1,v0),
   genre(v0,v1).").
in file  [0:0-0:0])_");
rel_77_author_info_23->insert(RamDomain(23),RamDomain(0),RamDomain(1),RamDomain(4),RamDomain(6),RamDomain(35));
}();
/* END STRATUM 72 */
/* BEGIN STRATUM 73 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.24(24,"v0,v1","Rule","precededBy,v2,v1","genre,v0,v2","author(v0,v1) :- 
   Rule(154),
   precededBy(v2,v1),
   genre(v0,v2).").
in file  [0:0-0:0])_");
rel_78_author_info_24->insert(RamDomain(24),RamDomain(0),RamDomain(1),RamDomain(20),RamDomain(36),RamDomain(37));
}();
/* END STRATUM 73 */
/* BEGIN STRATUM 74 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.25(25,"v0,v1","Rule","precededBy,v1,v2","genre,v2,v0","author(v0,v1) :- 
   Rule(155),
   precededBy(v1,v2),
   genre(v2,v0).").
in file  [0:0-0:0])_");
rel_79_author_info_25->insert(RamDomain(25),RamDomain(0),RamDomain(1),RamDomain(23),RamDomain(38),RamDomain(39));
}();
/* END STRATUM 74 */
/* BEGIN STRATUM 75 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.26(26,"v0,v1","Rule","precededBy,v2,v0","genre,v1,v2","author(v0,v1) :- 
   Rule(156),
   precededBy(v2,v0),
   genre(v1,v2).").
in file  [0:0-0:0])_");
rel_80_author_info_26->insert(RamDomain(26),RamDomain(0),RamDomain(1),RamDomain(24),RamDomain(40),RamDomain(41));
}();
/* END STRATUM 75 */
/* BEGIN STRATUM 76 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.27(27,"v0,v1","Rule","precededBy,v2,v0","genre,v2,v1","author(v0,v1) :- 
   Rule(157),
   precededBy(v2,v0),
   genre(v2,v1).").
in file  [0:0-0:0])_");
rel_81_author_info_27->insert(RamDomain(27),RamDomain(0),RamDomain(1),RamDomain(24),RamDomain(42),RamDomain(43));
}();
/* END STRATUM 76 */
/* BEGIN STRATUM 77 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.28(28,"v0,v1","Rule","precededBy,v0,v2","genre,v1,v2","author(v0,v1) :- 
   Rule(158),
   precededBy(v0,v2),
   genre(v1,v2).").
in file  [0:0-0:0])_");
rel_82_author_info_28->insert(RamDomain(28),RamDomain(0),RamDomain(1),RamDomain(21),RamDomain(40),RamDomain(44));
}();
/* END STRATUM 77 */
/* BEGIN STRATUM 78 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.29(29,"v0,v1","Rule","precededBy,v0,v2","genre,v2,v1","author(v0,v1) :- 
   Rule(159),
   precededBy(v0,v2),
   genre(v2,v1).").
in file  [0:0-0:0])_");
rel_83_author_info_29->insert(RamDomain(29),RamDomain(0),RamDomain(1),RamDomain(21),RamDomain(42),RamDomain(45));
}();
/* END STRATUM 78 */
/* BEGIN STRATUM 79 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.3(3,"v0,v1","Rule","genre,v0,v1","author(v0,v1) :- 
   Rule(130),
   genre(v0,v1).").
in file  [0:0-0:0])_");
rel_84_author_info_3->insert(RamDomain(3),RamDomain(0),RamDomain(1),RamDomain(6),RamDomain(7));
}();
/* END STRATUM 79 */
/* BEGIN STRATUM 80 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.30(30,"v0,v1","Rule","precededBy,v2,v1","genre,v2,v0","author(v0,v1) :- 
   Rule(160),
   precededBy(v2,v1),
   genre(v2,v0).").
in file  [0:0-0:0])_");
rel_85_author_info_30->insert(RamDomain(30),RamDomain(0),RamDomain(1),RamDomain(20),RamDomain(38),RamDomain(46));
}();
/* END STRATUM 80 */
/* BEGIN STRATUM 81 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.31(31,"v0,v1","Rule","precededBy,v1,v2","genre,v0,v2","author(v0,v1) :- 
   Rule(161),
   precededBy(v1,v2),
   genre(v0,v2).").
in file  [0:0-0:0])_");
rel_86_author_info_31->insert(RamDomain(31),RamDomain(0),RamDomain(1),RamDomain(23),RamDomain(36),RamDomain(47));
}();
/* END STRATUM 81 */
/* BEGIN STRATUM 82 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.32(32,"v0,v1","Rule","precededBy,v2,v1","Iauthor,v0,v2","author(v0,v1) :- 
   Rule(166),
   precededBy(v2,v1),
   Iauthor(v0,v2).").
in file  [0:0-0:0])_");
rel_87_author_info_32->insert(RamDomain(32),RamDomain(0),RamDomain(1),RamDomain(20),RamDomain(48),RamDomain(49));
}();
/* END STRATUM 82 */
/* BEGIN STRATUM 83 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.33(33,"v0,v1","Rule","precededBy,v1,v2","Iauthor,v2,v0","author(v0,v1) :- 
   Rule(167),
   precededBy(v1,v2),
   Iauthor(v2,v0).").
in file  [0:0-0:0])_");
rel_88_author_info_33->insert(RamDomain(33),RamDomain(0),RamDomain(1),RamDomain(23),RamDomain(50),RamDomain(51));
}();
/* END STRATUM 83 */
/* BEGIN STRATUM 84 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.34(34,"v0,v1","Rule","precededBy,v2,v0","Iauthor,v1,v2","author(v0,v1) :- 
   Rule(168),
   precededBy(v2,v0),
   Iauthor(v1,v2).").
in file  [0:0-0:0])_");
rel_89_author_info_34->insert(RamDomain(34),RamDomain(0),RamDomain(1),RamDomain(24),RamDomain(52),RamDomain(53));
}();
/* END STRATUM 84 */
/* BEGIN STRATUM 85 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.35(35,"v0,v1","Rule","precededBy,v2,v0","Iauthor,v2,v1","author(v0,v1) :- 
   Rule(169),
   precededBy(v2,v0),
   Iauthor(v2,v1).").
in file  [0:0-0:0])_");
rel_90_author_info_35->insert(RamDomain(35),RamDomain(0),RamDomain(1),RamDomain(24),RamDomain(54),RamDomain(55));
}();
/* END STRATUM 85 */
/* BEGIN STRATUM 86 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.36(36,"v0,v1","Rule","precededBy,v0,v2","Iauthor,v1,v2","author(v0,v1) :- 
   Rule(170),
   precededBy(v0,v2),
   Iauthor(v1,v2).").
in file  [0:0-0:0])_");
rel_91_author_info_36->insert(RamDomain(36),RamDomain(0),RamDomain(1),RamDomain(21),RamDomain(52),RamDomain(56));
}();
/* END STRATUM 86 */
/* BEGIN STRATUM 87 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.37(37,"v0,v1","Rule","precededBy,v0,v2","Iauthor,v2,v1","author(v0,v1) :- 
   Rule(171),
   precededBy(v0,v2),
   Iauthor(v2,v1).").
in file  [0:0-0:0])_");
rel_92_author_info_37->insert(RamDomain(37),RamDomain(0),RamDomain(1),RamDomain(21),RamDomain(54),RamDomain(57));
}();
/* END STRATUM 87 */
/* BEGIN STRATUM 88 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.38(38,"v0,v1","Rule","precededBy,v2,v1","Iauthor,v2,v0","author(v0,v1) :- 
   Rule(172),
   precededBy(v2,v1),
   Iauthor(v2,v0).").
in file  [0:0-0:0])_");
rel_93_author_info_38->insert(RamDomain(38),RamDomain(0),RamDomain(1),RamDomain(20),RamDomain(50),RamDomain(58));
}();
/* END STRATUM 88 */
/* BEGIN STRATUM 89 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.39(39,"v0,v1","Rule","precededBy,v1,v2","Iauthor,v0,v2","author(v0,v1) :- 
   Rule(173),
   precededBy(v1,v2),
   Iauthor(v0,v2).").
in file  [0:0-0:0])_");
rel_94_author_info_39->insert(RamDomain(39),RamDomain(0),RamDomain(1),RamDomain(23),RamDomain(48),RamDomain(59));
}();
/* END STRATUM 89 */
/* BEGIN STRATUM 90 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.4(4,"v0,v1","Rule","genre,v1,v0","author(v0,v1) :- 
   Rule(131),
   genre(v1,v0).").
in file  [0:0-0:0])_");
rel_95_author_info_4->insert(RamDomain(4),RamDomain(0),RamDomain(1),RamDomain(8),RamDomain(9));
}();
/* END STRATUM 90 */
/* BEGIN STRATUM 91 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.40(40,"v0,v1","Rule","precededBy,v0,v1","inv_0,v0,v1","author(v0,v1) :- 
   Rule(174),
   precededBy(v0,v1),
   inv_0(v0,v1).").
in file  [0:0-0:0])_");
rel_96_author_info_40->insert(RamDomain(40),RamDomain(0),RamDomain(1),RamDomain(2),RamDomain(10),RamDomain(60));
}();
/* END STRATUM 91 */
/* BEGIN STRATUM 92 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.41(41,"v0,v1","Rule","precededBy,v0,v1","inv_0,v1,v0","author(v0,v1) :- 
   Rule(175),
   precededBy(v0,v1),
   inv_0(v1,v0).").
in file  [0:0-0:0])_");
rel_97_author_info_41->insert(RamDomain(41),RamDomain(0),RamDomain(1),RamDomain(2),RamDomain(12),RamDomain(61));
}();
/* END STRATUM 92 */
/* BEGIN STRATUM 93 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.42(42,"v0,v1","Rule","precededBy,v1,v0","inv_0,v1,v0","author(v0,v1) :- 
   Rule(176),
   precededBy(v1,v0),
   inv_0(v1,v0).").
in file  [0:0-0:0])_");
rel_98_author_info_42->insert(RamDomain(42),RamDomain(0),RamDomain(1),RamDomain(4),RamDomain(12),RamDomain(62));
}();
/* END STRATUM 93 */
/* BEGIN STRATUM 94 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.43(43,"v0,v1","Rule","precededBy,v1,v0","inv_0,v0,v1","author(v0,v1) :- 
   Rule(177),
   precededBy(v1,v0),
   inv_0(v0,v1).").
in file  [0:0-0:0])_");
rel_99_author_info_43->insert(RamDomain(43),RamDomain(0),RamDomain(1),RamDomain(4),RamDomain(10),RamDomain(63));
}();
/* END STRATUM 94 */
/* BEGIN STRATUM 95 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.44(44,"v0,v1","Rule","precededBy,v2,v1","inv_0,v0,v2","author(v0,v1) :- 
   Rule(178),
   precededBy(v2,v1),
   inv_0(v0,v2).").
in file  [0:0-0:0])_");
rel_100_author_info_44->insert(RamDomain(44),RamDomain(0),RamDomain(1),RamDomain(20),RamDomain(64),RamDomain(65));
}();
/* END STRATUM 95 */
/* BEGIN STRATUM 96 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.45(45,"v0,v1","Rule","precededBy,v1,v2","inv_0,v2,v0","author(v0,v1) :- 
   Rule(179),
   precededBy(v1,v2),
   inv_0(v2,v0).").
in file  [0:0-0:0])_");
rel_101_author_info_45->insert(RamDomain(45),RamDomain(0),RamDomain(1),RamDomain(23),RamDomain(66),RamDomain(67));
}();
/* END STRATUM 96 */
/* BEGIN STRATUM 97 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.46(46,"v0,v1","Rule","precededBy,v2,v0","inv_0,v1,v2","author(v0,v1) :- 
   Rule(180),
   precededBy(v2,v0),
   inv_0(v1,v2).").
in file  [0:0-0:0])_");
rel_102_author_info_46->insert(RamDomain(46),RamDomain(0),RamDomain(1),RamDomain(24),RamDomain(68),RamDomain(69));
}();
/* END STRATUM 97 */
/* BEGIN STRATUM 98 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.47(47,"v0,v1","Rule","precededBy,v2,v0","inv_0,v2,v1","author(v0,v1) :- 
   Rule(181),
   precededBy(v2,v0),
   inv_0(v2,v1).").
in file  [0:0-0:0])_");
rel_103_author_info_47->insert(RamDomain(47),RamDomain(0),RamDomain(1),RamDomain(24),RamDomain(70),RamDomain(71));
}();
/* END STRATUM 98 */
/* BEGIN STRATUM 99 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.48(48,"v0,v1","Rule","precededBy,v0,v2","inv_0,v1,v2","author(v0,v1) :- 
   Rule(182),
   precededBy(v0,v2),
   inv_0(v1,v2).").
in file  [0:0-0:0])_");
rel_104_author_info_48->insert(RamDomain(48),RamDomain(0),RamDomain(1),RamDomain(21),RamDomain(68),RamDomain(72));
}();
/* END STRATUM 99 */
/* BEGIN STRATUM 100 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.49(49,"v0,v1","Rule","precededBy,v0,v2","inv_0,v2,v1","author(v0,v1) :- 
   Rule(183),
   precededBy(v0,v2),
   inv_0(v2,v1).").
in file  [0:0-0:0])_");
rel_105_author_info_49->insert(RamDomain(49),RamDomain(0),RamDomain(1),RamDomain(21),RamDomain(70),RamDomain(73));
}();
/* END STRATUM 100 */
/* BEGIN STRATUM 101 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.5(5,"v0,v1","Rule","inv_0,v0,v1","author(v0,v1) :- 
   Rule(134),
   inv_0(v0,v1).").
in file  [0:0-0:0])_");
rel_106_author_info_5->insert(RamDomain(5),RamDomain(0),RamDomain(1),RamDomain(10),RamDomain(11));
}();
/* END STRATUM 101 */
/* BEGIN STRATUM 102 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.50(50,"v0,v1","Rule","precededBy,v2,v1","inv_0,v2,v0","author(v0,v1) :- 
   Rule(184),
   precededBy(v2,v1),
   inv_0(v2,v0).").
in file  [0:0-0:0])_");
rel_107_author_info_50->insert(RamDomain(50),RamDomain(0),RamDomain(1),RamDomain(20),RamDomain(66),RamDomain(74));
}();
/* END STRATUM 102 */
/* BEGIN STRATUM 103 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.51(51,"v0,v1","Rule","precededBy,v1,v2","inv_0,v0,v2","author(v0,v1) :- 
   Rule(185),
   precededBy(v1,v2),
   inv_0(v0,v2).").
in file  [0:0-0:0])_");
rel_108_author_info_51->insert(RamDomain(51),RamDomain(0),RamDomain(1),RamDomain(23),RamDomain(64),RamDomain(75));
}();
/* END STRATUM 103 */
/* BEGIN STRATUM 104 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.52(52,"v0,v1","Rule","precededBy,v0,v1","author,v1,v0","author(v0,v1) :- 
   Rule(187),
   precededBy(v0,v1),
   author(v1,v0).").
in file  [0:0-0:0])_");
rel_109_author_info_52->insert(RamDomain(52),RamDomain(0),RamDomain(1),RamDomain(2),RamDomain(14),RamDomain(76));
}();
/* END STRATUM 104 */
/* BEGIN STRATUM 105 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.53(53,"v0,v1","Rule","precededBy,v1,v0","author,v1,v0","author(v0,v1) :- 
   Rule(188),
   precededBy(v1,v0),
   author(v1,v0).").
in file  [0:0-0:0])_");
rel_110_author_info_53->insert(RamDomain(53),RamDomain(0),RamDomain(1),RamDomain(4),RamDomain(14),RamDomain(77));
}();
/* END STRATUM 105 */
/* BEGIN STRATUM 106 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.54(54,"v0,v1","Rule","precededBy,v2,v1","author,v0,v2","author(v0,v1) :- 
   Rule(190),
   precededBy(v2,v1),
   author(v0,v2).").
in file  [0:0-0:0])_");
rel_111_author_info_54->insert(RamDomain(54),RamDomain(0),RamDomain(1),RamDomain(20),RamDomain(78),RamDomain(79));
}();
/* END STRATUM 106 */
/* BEGIN STRATUM 107 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.55(55,"v0,v1","Rule","precededBy,v1,v2","author,v2,v0","author(v0,v1) :- 
   Rule(191),
   precededBy(v1,v2),
   author(v2,v0).").
in file  [0:0-0:0])_");
rel_112_author_info_55->insert(RamDomain(55),RamDomain(0),RamDomain(1),RamDomain(23),RamDomain(80),RamDomain(81));
}();
/* END STRATUM 107 */
/* BEGIN STRATUM 108 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.56(56,"v0,v1","Rule","precededBy,v2,v0","author,v1,v2","author(v0,v1) :- 
   Rule(192),
   precededBy(v2,v0),
   author(v1,v2).").
in file  [0:0-0:0])_");
rel_113_author_info_56->insert(RamDomain(56),RamDomain(0),RamDomain(1),RamDomain(24),RamDomain(82),RamDomain(83));
}();
/* END STRATUM 108 */
/* BEGIN STRATUM 109 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.57(57,"v0,v1","Rule","precededBy,v2,v0","author,v2,v1","author(v0,v1) :- 
   Rule(193),
   precededBy(v2,v0),
   author(v2,v1).").
in file  [0:0-0:0])_");
rel_114_author_info_57->insert(RamDomain(57),RamDomain(0),RamDomain(1),RamDomain(24),RamDomain(84),RamDomain(85));
}();
/* END STRATUM 109 */
/* BEGIN STRATUM 110 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.58(58,"v0,v1","Rule","precededBy,v0,v2","author,v1,v2","author(v0,v1) :- 
   Rule(194),
   precededBy(v0,v2),
   author(v1,v2).").
in file  [0:0-0:0])_");
rel_115_author_info_58->insert(RamDomain(58),RamDomain(0),RamDomain(1),RamDomain(21),RamDomain(82),RamDomain(86));
}();
/* END STRATUM 110 */
/* BEGIN STRATUM 111 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.59(59,"v0,v1","Rule","precededBy,v0,v2","author,v2,v1","author(v0,v1) :- 
   Rule(195),
   precededBy(v0,v2),
   author(v2,v1).").
in file  [0:0-0:0])_");
rel_116_author_info_59->insert(RamDomain(59),RamDomain(0),RamDomain(1),RamDomain(21),RamDomain(84),RamDomain(87));
}();
/* END STRATUM 111 */
/* BEGIN STRATUM 112 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.6(6,"v0,v1","Rule","inv_0,v1,v0","author(v0,v1) :- 
   Rule(135),
   inv_0(v1,v0).").
in file  [0:0-0:0])_");
rel_117_author_info_6->insert(RamDomain(6),RamDomain(0),RamDomain(1),RamDomain(12),RamDomain(13));
}();
/* END STRATUM 112 */
/* BEGIN STRATUM 113 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.60(60,"v0,v1","Rule","precededBy,v2,v1","author,v2,v0","author(v0,v1) :- 
   Rule(196),
   precededBy(v2,v1),
   author(v2,v0).").
in file  [0:0-0:0])_");
rel_118_author_info_60->insert(RamDomain(60),RamDomain(0),RamDomain(1),RamDomain(20),RamDomain(80),RamDomain(88));
}();
/* END STRATUM 113 */
/* BEGIN STRATUM 114 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.61(61,"v0,v1","Rule","precededBy,v1,v2","author,v0,v2","author(v0,v1) :- 
   Rule(197),
   precededBy(v1,v2),
   author(v0,v2).").
in file  [0:0-0:0])_");
rel_119_author_info_61->insert(RamDomain(61),RamDomain(0),RamDomain(1),RamDomain(23),RamDomain(78),RamDomain(89));
}();
/* END STRATUM 114 */
/* BEGIN STRATUM 115 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.62(62,"v0,v1","Rule","genre,v0,v1","author(v0,v1) :- 
   Rule(198),
   genre(v0,v1).").
in file  [0:0-0:0])_");
rel_120_author_info_62->insert(RamDomain(62),RamDomain(0),RamDomain(1),RamDomain(6),RamDomain(90));
}();
/* END STRATUM 115 */
/* BEGIN STRATUM 116 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.63(63,"v0,v1","Rule","genre,v0,v1","genre,v1,v0","author(v0,v1) :- 
   Rule(199),
   genre(v0,v1),
   genre(v1,v0).").
in file  [0:0-0:0])_");
rel_121_author_info_63->insert(RamDomain(63),RamDomain(0),RamDomain(1),RamDomain(6),RamDomain(8),RamDomain(91));
}();
/* END STRATUM 116 */
/* BEGIN STRATUM 117 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.64(64,"v0,v1","Rule","genre,v1,v0","author(v0,v1) :- 
   Rule(200),
   genre(v1,v0).").
in file  [0:0-0:0])_");
rel_122_author_info_64->insert(RamDomain(64),RamDomain(0),RamDomain(1),RamDomain(8),RamDomain(92));
}();
/* END STRATUM 117 */
/* BEGIN STRATUM 118 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.65(65,"v0,v1","Rule","genre,v1,v0","genre,v0,v1","author(v0,v1) :- 
   Rule(201),
   genre(v1,v0),
   genre(v0,v1).").
in file  [0:0-0:0])_");
rel_123_author_info_65->insert(RamDomain(65),RamDomain(0),RamDomain(1),RamDomain(8),RamDomain(6),RamDomain(93));
}();
/* END STRATUM 118 */
/* BEGIN STRATUM 119 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.66(66,"v0,v1","Rule","genre,v2,v1","genre,v0,v2","author(v0,v1) :- 
   Rule(202),
   genre(v2,v1),
   genre(v0,v2).").
in file  [0:0-0:0])_");
rel_124_author_info_66->insert(RamDomain(66),RamDomain(0),RamDomain(1),RamDomain(42),RamDomain(36),RamDomain(94));
}();
/* END STRATUM 119 */
/* BEGIN STRATUM 120 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.67(67,"v0,v1","Rule","genre,v1,v2","genre,v2,v0","author(v0,v1) :- 
   Rule(203),
   genre(v1,v2),
   genre(v2,v0).").
in file  [0:0-0:0])_");
rel_125_author_info_67->insert(RamDomain(67),RamDomain(0),RamDomain(1),RamDomain(40),RamDomain(38),RamDomain(95));
}();
/* END STRATUM 120 */
/* BEGIN STRATUM 121 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.68(68,"v0,v1","Rule","genre,v2,v0","genre,v1,v2","author(v0,v1) :- 
   Rule(204),
   genre(v2,v0),
   genre(v1,v2).").
in file  [0:0-0:0])_");
rel_126_author_info_68->insert(RamDomain(68),RamDomain(0),RamDomain(1),RamDomain(38),RamDomain(40),RamDomain(96));
}();
/* END STRATUM 121 */
/* BEGIN STRATUM 122 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.69(69,"v0,v1","Rule","genre,v2,v0","genre,v2,v1","author(v0,v1) :- 
   Rule(205),
   genre(v2,v0),
   genre(v2,v1).").
in file  [0:0-0:0])_");
rel_127_author_info_69->insert(RamDomain(69),RamDomain(0),RamDomain(1),RamDomain(38),RamDomain(42),RamDomain(97));
}();
/* END STRATUM 122 */
/* BEGIN STRATUM 123 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.7(7,"v0,v1","Rule","author,v1,v0","author(v0,v1) :- 
   Rule(137),
   author(v1,v0).").
in file  [0:0-0:0])_");
rel_128_author_info_7->insert(RamDomain(7),RamDomain(0),RamDomain(1),RamDomain(14),RamDomain(15));
}();
/* END STRATUM 123 */
/* BEGIN STRATUM 124 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.70(70,"v0,v1","Rule","genre,v0,v2","genre,v1,v2","author(v0,v1) :- 
   Rule(206),
   genre(v0,v2),
   genre(v1,v2).").
in file  [0:0-0:0])_");
rel_129_author_info_70->insert(RamDomain(70),RamDomain(0),RamDomain(1),RamDomain(36),RamDomain(40),RamDomain(98));
}();
/* END STRATUM 124 */
/* BEGIN STRATUM 125 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.71(71,"v0,v1","Rule","genre,v0,v2","genre,v2,v1","author(v0,v1) :- 
   Rule(207),
   genre(v0,v2),
   genre(v2,v1).").
in file  [0:0-0:0])_");
rel_130_author_info_71->insert(RamDomain(71),RamDomain(0),RamDomain(1),RamDomain(36),RamDomain(42),RamDomain(99));
}();
/* END STRATUM 125 */
/* BEGIN STRATUM 126 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.72(72,"v0,v1","Rule","genre,v2,v1","genre,v2,v0","author(v0,v1) :- 
   Rule(208),
   genre(v2,v1),
   genre(v2,v0).").
in file  [0:0-0:0])_");
rel_131_author_info_72->insert(RamDomain(72),RamDomain(0),RamDomain(1),RamDomain(42),RamDomain(38),RamDomain(100));
}();
/* END STRATUM 126 */
/* BEGIN STRATUM 127 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.73(73,"v0,v1","Rule","genre,v1,v2","genre,v0,v2","author(v0,v1) :- 
   Rule(209),
   genre(v1,v2),
   genre(v0,v2).").
in file  [0:0-0:0])_");
rel_132_author_info_73->insert(RamDomain(73),RamDomain(0),RamDomain(1),RamDomain(40),RamDomain(36),RamDomain(101));
}();
/* END STRATUM 127 */
/* BEGIN STRATUM 128 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.74(74,"v0,v1","Rule","genre,v2,v1","Iauthor,v0,v2","author(v0,v1) :- 
   Rule(214),
   genre(v2,v1),
   Iauthor(v0,v2).").
in file  [0:0-0:0])_");
rel_133_author_info_74->insert(RamDomain(74),RamDomain(0),RamDomain(1),RamDomain(42),RamDomain(48),RamDomain(102));
}();
/* END STRATUM 128 */
/* BEGIN STRATUM 129 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.75(75,"v0,v1","Rule","genre,v1,v2","Iauthor,v2,v0","author(v0,v1) :- 
   Rule(215),
   genre(v1,v2),
   Iauthor(v2,v0).").
in file  [0:0-0:0])_");
rel_134_author_info_75->insert(RamDomain(75),RamDomain(0),RamDomain(1),RamDomain(40),RamDomain(50),RamDomain(103));
}();
/* END STRATUM 129 */
/* BEGIN STRATUM 130 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.76(76,"v0,v1","Rule","genre,v2,v0","Iauthor,v1,v2","author(v0,v1) :- 
   Rule(216),
   genre(v2,v0),
   Iauthor(v1,v2).").
in file  [0:0-0:0])_");
rel_135_author_info_76->insert(RamDomain(76),RamDomain(0),RamDomain(1),RamDomain(38),RamDomain(52),RamDomain(104));
}();
/* END STRATUM 130 */
/* BEGIN STRATUM 131 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.77(77,"v0,v1","Rule","genre,v2,v0","Iauthor,v2,v1","author(v0,v1) :- 
   Rule(217),
   genre(v2,v0),
   Iauthor(v2,v1).").
in file  [0:0-0:0])_");
rel_136_author_info_77->insert(RamDomain(77),RamDomain(0),RamDomain(1),RamDomain(38),RamDomain(54),RamDomain(105));
}();
/* END STRATUM 131 */
/* BEGIN STRATUM 132 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.78(78,"v0,v1","Rule","genre,v0,v2","Iauthor,v1,v2","author(v0,v1) :- 
   Rule(218),
   genre(v0,v2),
   Iauthor(v1,v2).").
in file  [0:0-0:0])_");
rel_137_author_info_78->insert(RamDomain(78),RamDomain(0),RamDomain(1),RamDomain(36),RamDomain(52),RamDomain(106));
}();
/* END STRATUM 132 */
/* BEGIN STRATUM 133 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.79(79,"v0,v1","Rule","genre,v0,v2","Iauthor,v2,v1","author(v0,v1) :- 
   Rule(219),
   genre(v0,v2),
   Iauthor(v2,v1).").
in file  [0:0-0:0])_");
rel_138_author_info_79->insert(RamDomain(79),RamDomain(0),RamDomain(1),RamDomain(36),RamDomain(54),RamDomain(107));
}();
/* END STRATUM 133 */
/* BEGIN STRATUM 134 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.8(8,"v0,v1","Rule","precededBy,v0,v1","author(v0,v1) :- 
   Rule(138),
   precededBy(v0,v1).").
in file  [0:0-0:0])_");
rel_139_author_info_8->insert(RamDomain(8),RamDomain(0),RamDomain(1),RamDomain(2),RamDomain(16));
}();
/* END STRATUM 134 */
/* BEGIN STRATUM 135 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.80(80,"v0,v1","Rule","genre,v2,v1","Iauthor,v2,v0","author(v0,v1) :- 
   Rule(220),
   genre(v2,v1),
   Iauthor(v2,v0).").
in file  [0:0-0:0])_");
rel_140_author_info_80->insert(RamDomain(80),RamDomain(0),RamDomain(1),RamDomain(42),RamDomain(50),RamDomain(108));
}();
/* END STRATUM 135 */
/* BEGIN STRATUM 136 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.81(81,"v0,v1","Rule","genre,v1,v2","Iauthor,v0,v2","author(v0,v1) :- 
   Rule(221),
   genre(v1,v2),
   Iauthor(v0,v2).").
in file  [0:0-0:0])_");
rel_141_author_info_81->insert(RamDomain(81),RamDomain(0),RamDomain(1),RamDomain(40),RamDomain(48),RamDomain(109));
}();
/* END STRATUM 136 */
/* BEGIN STRATUM 137 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.82(82,"v0,v1","Rule","genre,v0,v1","inv_0,v0,v1","author(v0,v1) :- 
   Rule(222),
   genre(v0,v1),
   inv_0(v0,v1).").
in file  [0:0-0:0])_");
rel_142_author_info_82->insert(RamDomain(82),RamDomain(0),RamDomain(1),RamDomain(6),RamDomain(10),RamDomain(110));
}();
/* END STRATUM 137 */
/* BEGIN STRATUM 138 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.83(83,"v0,v1","Rule","genre,v0,v1","inv_0,v1,v0","author(v0,v1) :- 
   Rule(223),
   genre(v0,v1),
   inv_0(v1,v0).").
in file  [0:0-0:0])_");
rel_143_author_info_83->insert(RamDomain(83),RamDomain(0),RamDomain(1),RamDomain(6),RamDomain(12),RamDomain(111));
}();
/* END STRATUM 138 */
/* BEGIN STRATUM 139 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.84(84,"v0,v1","Rule","genre,v1,v0","inv_0,v1,v0","author(v0,v1) :- 
   Rule(224),
   genre(v1,v0),
   inv_0(v1,v0).").
in file  [0:0-0:0])_");
rel_144_author_info_84->insert(RamDomain(84),RamDomain(0),RamDomain(1),RamDomain(8),RamDomain(12),RamDomain(112));
}();
/* END STRATUM 139 */
/* BEGIN STRATUM 140 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.85(85,"v0,v1","Rule","genre,v1,v0","inv_0,v0,v1","author(v0,v1) :- 
   Rule(225),
   genre(v1,v0),
   inv_0(v0,v1).").
in file  [0:0-0:0])_");
rel_145_author_info_85->insert(RamDomain(85),RamDomain(0),RamDomain(1),RamDomain(8),RamDomain(10),RamDomain(113));
}();
/* END STRATUM 140 */
/* BEGIN STRATUM 141 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.86(86,"v0,v1","Rule","genre,v2,v1","inv_0,v0,v2","author(v0,v1) :- 
   Rule(226),
   genre(v2,v1),
   inv_0(v0,v2).").
in file  [0:0-0:0])_");
rel_146_author_info_86->insert(RamDomain(86),RamDomain(0),RamDomain(1),RamDomain(42),RamDomain(64),RamDomain(114));
}();
/* END STRATUM 141 */
/* BEGIN STRATUM 142 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.87(87,"v0,v1","Rule","genre,v1,v2","inv_0,v2,v0","author(v0,v1) :- 
   Rule(227),
   genre(v1,v2),
   inv_0(v2,v0).").
in file  [0:0-0:0])_");
rel_147_author_info_87->insert(RamDomain(87),RamDomain(0),RamDomain(1),RamDomain(40),RamDomain(66),RamDomain(115));
}();
/* END STRATUM 142 */
/* BEGIN STRATUM 143 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.88(88,"v0,v1","Rule","genre,v2,v0","inv_0,v1,v2","author(v0,v1) :- 
   Rule(228),
   genre(v2,v0),
   inv_0(v1,v2).").
in file  [0:0-0:0])_");
rel_148_author_info_88->insert(RamDomain(88),RamDomain(0),RamDomain(1),RamDomain(38),RamDomain(68),RamDomain(116));
}();
/* END STRATUM 143 */
/* BEGIN STRATUM 144 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.89(89,"v0,v1","Rule","genre,v2,v0","inv_0,v2,v1","author(v0,v1) :- 
   Rule(229),
   genre(v2,v0),
   inv_0(v2,v1).").
in file  [0:0-0:0])_");
rel_149_author_info_89->insert(RamDomain(89),RamDomain(0),RamDomain(1),RamDomain(38),RamDomain(70),RamDomain(117));
}();
/* END STRATUM 144 */
/* BEGIN STRATUM 145 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.9(9,"v0,v1","Rule","precededBy,v0,v1","precededBy,v1,v0","author(v0,v1) :- 
   Rule(139),
   precededBy(v0,v1),
   precededBy(v1,v0).").
in file  [0:0-0:0])_");
rel_150_author_info_9->insert(RamDomain(9),RamDomain(0),RamDomain(1),RamDomain(2),RamDomain(4),RamDomain(17));
}();
/* END STRATUM 145 */
/* BEGIN STRATUM 146 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.90(90,"v0,v1","Rule","genre,v0,v2","inv_0,v1,v2","author(v0,v1) :- 
   Rule(230),
   genre(v0,v2),
   inv_0(v1,v2).").
in file  [0:0-0:0])_");
rel_151_author_info_90->insert(RamDomain(90),RamDomain(0),RamDomain(1),RamDomain(36),RamDomain(68),RamDomain(118));
}();
/* END STRATUM 146 */
/* BEGIN STRATUM 147 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.91(91,"v0,v1","Rule","genre,v0,v2","inv_0,v2,v1","author(v0,v1) :- 
   Rule(231),
   genre(v0,v2),
   inv_0(v2,v1).").
in file  [0:0-0:0])_");
rel_152_author_info_91->insert(RamDomain(91),RamDomain(0),RamDomain(1),RamDomain(36),RamDomain(70),RamDomain(119));
}();
/* END STRATUM 147 */
/* BEGIN STRATUM 148 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.92(92,"v0,v1","Rule","genre,v2,v1","inv_0,v2,v0","author(v0,v1) :- 
   Rule(232),
   genre(v2,v1),
   inv_0(v2,v0).").
in file  [0:0-0:0])_");
rel_153_author_info_92->insert(RamDomain(92),RamDomain(0),RamDomain(1),RamDomain(42),RamDomain(66),RamDomain(120));
}();
/* END STRATUM 148 */
/* BEGIN STRATUM 149 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.93(93,"v0,v1","Rule","genre,v1,v2","inv_0,v0,v2","author(v0,v1) :- 
   Rule(233),
   genre(v1,v2),
   inv_0(v0,v2).").
in file  [0:0-0:0])_");
rel_154_author_info_93->insert(RamDomain(93),RamDomain(0),RamDomain(1),RamDomain(40),RamDomain(64),RamDomain(121));
}();
/* END STRATUM 149 */
/* BEGIN STRATUM 150 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.94(94,"v0,v1","Rule","genre,v0,v1","author,v1,v0","author(v0,v1) :- 
   Rule(235),
   genre(v0,v1),
   author(v1,v0).").
in file  [0:0-0:0])_");
rel_155_author_info_94->insert(RamDomain(94),RamDomain(0),RamDomain(1),RamDomain(6),RamDomain(14),RamDomain(122));
}();
/* END STRATUM 150 */
/* BEGIN STRATUM 151 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.95(95,"v0,v1","Rule","genre,v1,v0","author,v1,v0","author(v0,v1) :- 
   Rule(236),
   genre(v1,v0),
   author(v1,v0).").
in file  [0:0-0:0])_");
rel_156_author_info_95->insert(RamDomain(95),RamDomain(0),RamDomain(1),RamDomain(8),RamDomain(14),RamDomain(123));
}();
/* END STRATUM 151 */
/* BEGIN STRATUM 152 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.96(96,"v0,v1","Rule","genre,v2,v1","author,v0,v2","author(v0,v1) :- 
   Rule(238),
   genre(v2,v1),
   author(v0,v2).").
in file  [0:0-0:0])_");
rel_157_author_info_96->insert(RamDomain(96),RamDomain(0),RamDomain(1),RamDomain(42),RamDomain(78),RamDomain(124));
}();
/* END STRATUM 152 */
/* BEGIN STRATUM 153 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.97(97,"v0,v1","Rule","genre,v1,v2","author,v2,v0","author(v0,v1) :- 
   Rule(239),
   genre(v1,v2),
   author(v2,v0).").
in file  [0:0-0:0])_");
rel_158_author_info_97->insert(RamDomain(97),RamDomain(0),RamDomain(1),RamDomain(40),RamDomain(80),RamDomain(125));
}();
/* END STRATUM 153 */
/* BEGIN STRATUM 154 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.98(98,"v0,v1","Rule","genre,v2,v0","author,v1,v2","author(v0,v1) :- 
   Rule(240),
   genre(v2,v0),
   author(v1,v2).").
in file  [0:0-0:0])_");
rel_159_author_info_98->insert(RamDomain(98),RamDomain(0),RamDomain(1),RamDomain(38),RamDomain(82),RamDomain(126));
}();
/* END STRATUM 154 */
/* BEGIN STRATUM 155 */
[&]() {
SignalHandler::instance()->setMsg(R"_(author.@info.99(99,"v0,v1","Rule","genre,v2,v0","author,v2,v1","author(v0,v1) :- 
   Rule(241),
   genre(v2,v0),
   author(v2,v1).").
in file  [0:0-0:0])_");
rel_160_author_info_99->insert(RamDomain(99),RamDomain(0),RamDomain(1),RamDomain(38),RamDomain(84),RamDomain(127));
}();
/* END STRATUM 155 */
/* BEGIN STRATUM 156 */
[&]() {
SignalHandler::instance()->setMsg(R"_(inv_0.@info.1(1,"v0,v1","Rule","precededBy,v0,v1","inv_0(v0,v1) :- 
   Rule(0),
   precededBy(v0,v1).").
in file  [0:0-0:0])_");
rel_161_inv_0_info_1->insert(RamDomain(1),RamDomain(0),RamDomain(1),RamDomain(2),RamDomain(179));
}();
/* END STRATUM 156 */
/* BEGIN STRATUM 157 */
[&]() {
SignalHandler::instance()->setMsg(R"_(inv_0.@info.10(10,"v0,v1","Rule","precededBy,v2,v1","precededBy,v0,v2","inv_0(v0,v1) :- 
   Rule(12),
   precededBy(v2,v1),
   precededBy(v0,v2).").
in file  [0:0-0:0])_");
rel_162_inv_0_info_10->insert(RamDomain(10),RamDomain(0),RamDomain(1),RamDomain(20),RamDomain(21),RamDomain(188));
}();
/* END STRATUM 157 */
/* BEGIN STRATUM 158 */
[&]() {
SignalHandler::instance()->setMsg(R"_(inv_0.@info.11(11,"v0,v1","Rule","precededBy,v1,v2","precededBy,v2,v0","inv_0(v0,v1) :- 
   Rule(13),
   precededBy(v1,v2),
   precededBy(v2,v0).").
in file  [0:0-0:0])_");
rel_163_inv_0_info_11->insert(RamDomain(11),RamDomain(0),RamDomain(1),RamDomain(23),RamDomain(24),RamDomain(189));
}();
/* END STRATUM 158 */
/* BEGIN STRATUM 159 */
[&]() {
SignalHandler::instance()->setMsg(R"_(inv_0.@info.12(12,"v0,v1","Rule","precededBy,v2,v0","precededBy,v1,v2","inv_0(v0,v1) :- 
   Rule(14),
   precededBy(v2,v0),
   precededBy(v1,v2).").
in file  [0:0-0:0])_");
rel_164_inv_0_info_12->insert(RamDomain(12),RamDomain(0),RamDomain(1),RamDomain(24),RamDomain(23),RamDomain(190));
}();
/* END STRATUM 159 */
/* BEGIN STRATUM 160 */
[&]() {
SignalHandler::instance()->setMsg(R"_(inv_0.@info.13(13,"v0,v1","Rule","precededBy,v2,v0","precededBy,v2,v1","inv_0(v0,v1) :- 
   Rule(15),
   precededBy(v2,v0),
   precededBy(v2,v1).").
in file  [0:0-0:0])_");
rel_165_inv_0_info_13->insert(RamDomain(13),RamDomain(0),RamDomain(1),RamDomain(24),RamDomain(20),RamDomain(191));
}();
/* END STRATUM 160 */
/* BEGIN STRATUM 161 */
[&]() {
SignalHandler::instance()->setMsg(R"_(inv_0.@info.14(14,"v0,v1","Rule","precededBy,v0,v2","precededBy,v1,v2","inv_0(v0,v1) :- 
   Rule(16),
   precededBy(v0,v2),
   precededBy(v1,v2).").
in file  [0:0-0:0])_");
rel_166_inv_0_info_14->insert(RamDomain(14),RamDomain(0),RamDomain(1),RamDomain(21),RamDomain(23),RamDomain(192));
}();
/* END STRATUM 161 */
/* BEGIN STRATUM 162 */
[&]() {
SignalHandler::instance()->setMsg(R"_(inv_0.@info.15(15,"v0,v1","Rule","precededBy,v0,v2","precededBy,v2,v1","inv_0(v0,v1) :- 
   Rule(17),
   precededBy(v0,v2),
   precededBy(v2,v1).").
in file  [0:0-0:0])_");
rel_167_inv_0_info_15->insert(RamDomain(15),RamDomain(0),RamDomain(1),RamDomain(21),RamDomain(20),RamDomain(193));
}();
/* END STRATUM 162 */
/* BEGIN STRATUM 163 */
[&]() {
SignalHandler::instance()->setMsg(R"_(inv_0.@info.16(16,"v0,v1","Rule","precededBy,v2,v1","precededBy,v2,v0","inv_0(v0,v1) :- 
   Rule(18),
   precededBy(v2,v1),
   precededBy(v2,v0).").
in file  [0:0-0:0])_");
rel_168_inv_0_info_16->insert(RamDomain(16),RamDomain(0),RamDomain(1),RamDomain(20),RamDomain(24),RamDomain(194));
}();
/* END STRATUM 163 */
/* BEGIN STRATUM 164 */
[&]() {
SignalHandler::instance()->setMsg(R"_(inv_0.@info.17(17,"v0,v1","Rule","precededBy,v1,v2","precededBy,v0,v2","inv_0(v0,v1) :- 
   Rule(19),
   precededBy(v1,v2),
   precededBy(v0,v2).").
in file  [0:0-0:0])_");
rel_169_inv_0_info_17->insert(RamDomain(17),RamDomain(0),RamDomain(1),RamDomain(23),RamDomain(21),RamDomain(195));
}();
/* END STRATUM 164 */
/* BEGIN STRATUM 165 */
[&]() {
SignalHandler::instance()->setMsg(R"_(inv_0.@info.18(18,"v0,v1","Rule","precededBy,v0,v1","genre,v0,v1","inv_0(v0,v1) :- 
   Rule(20),
   precededBy(v0,v1),
   genre(v0,v1).").
in file  [0:0-0:0])_");
rel_170_inv_0_info_18->insert(RamDomain(18),RamDomain(0),RamDomain(1),RamDomain(2),RamDomain(6),RamDomain(196));
}();
/* END STRATUM 165 */
/* BEGIN STRATUM 166 */
[&]() {
SignalHandler::instance()->setMsg(R"_(inv_0.@info.19(19,"v0,v1","Rule","precededBy,v0,v1","genre,v1,v0","inv_0(v0,v1) :- 
   Rule(21),
   precededBy(v0,v1),
   genre(v1,v0).").
in file  [0:0-0:0])_");
rel_171_inv_0_info_19->insert(RamDomain(19),RamDomain(0),RamDomain(1),RamDomain(2),RamDomain(8),RamDomain(197));
}();
/* END STRATUM 166 */
/* BEGIN STRATUM 167 */
[&]() {
SignalHandler::instance()->setMsg(R"_(inv_0.@info.2(2,"v0,v1","Rule","precededBy,v1,v0","inv_0(v0,v1) :- 
   Rule(1),
   precededBy(v1,v0).").
in file  [0:0-0:0])_");
rel_172_inv_0_info_2->insert(RamDomain(2),RamDomain(0),RamDomain(1),RamDomain(4),RamDomain(180));
}();
/* END STRATUM 167 */
/* BEGIN STRATUM 168 */
[&]() {
SignalHandler::instance()->setMsg(R"_(inv_0.@info.20(20,"v0,v1","Rule","precededBy,v1,v0","genre,v1,v0","inv_0(v0,v1) :- 
   Rule(22),
   precededBy(v1,v0),
   genre(v1,v0).").
in file  [0:0-0:0])_");
rel_173_inv_0_info_20->insert(RamDomain(20),RamDomain(0),RamDomain(1),RamDomain(4),RamDomain(8),RamDomain(198));
}();
/* END STRATUM 168 */
/* BEGIN STRATUM 169 */
[&]() {
SignalHandler::instance()->setMsg(R"_(inv_0.@info.21(21,"v0,v1","Rule","precededBy,v1,v0","genre,v0,v1","inv_0(v0,v1) :- 
   Rule(23),
   precededBy(v1,v0),
   genre(v0,v1).").
in file  [0:0-0:0])_");
rel_174_inv_0_info_21->insert(RamDomain(21),RamDomain(0),RamDomain(1),RamDomain(4),RamDomain(6),RamDomain(199));
}();
/* END STRATUM 169 */
/* BEGIN STRATUM 170 */
[&]() {
SignalHandler::instance()->setMsg(R"_(inv_0.@info.22(22,"v0,v1","Rule","precededBy,v2,v1","genre,v0,v2","inv_0(v0,v1) :- 
   Rule(24),
   precededBy(v2,v1),
   genre(v0,v2).").
in file  [0:0-0:0])_");
rel_175_inv_0_info_22->insert(RamDomain(22),RamDomain(0),RamDomain(1),RamDomain(20),RamDomain(36),RamDomain(200));
}();
/* END STRATUM 170 */
/* BEGIN STRATUM 171 */
[&]() {
SignalHandler::instance()->setMsg(R"_(inv_0.@info.23(23,"v0,v1","Rule","precededBy,v1,v2","genre,v2,v0","inv_0(v0,v1) :- 
   Rule(25),
   precededBy(v1,v2),
   genre(v2,v0).").
in file  [0:0-0:0])_");
rel_176_inv_0_info_23->insert(RamDomain(23),RamDomain(0),RamDomain(1),RamDomain(23),RamDomain(38),RamDomain(201));
}();
/* END STRATUM 171 */
/* BEGIN STRATUM 172 */
[&]() {
SignalHandler::instance()->setMsg(R"_(inv_0.@info.24(24,"v0,v1","Rule","precededBy,v2,v0","genre,v1,v2","inv_0(v0,v1) :- 
   Rule(26),
   precededBy(v2,v0),
   genre(v1,v2).").
in file  [0:0-0:0])_");
rel_177_inv_0_info_24->insert(RamDomain(24),RamDomain(0),RamDomain(1),RamDomain(24),RamDomain(40),RamDomain(202));
}();
/* END STRATUM 172 */
/* BEGIN STRATUM 173 */
[&]() {
SignalHandler::instance()->setMsg(R"_(inv_0.@info.25(25,"v0,v1","Rule","precededBy,v2,v0","genre,v2,v1","inv_0(v0,v1) :- 
   Rule(27),
   precededBy(v2,v0),
   genre(v2,v1).").
in file  [0:0-0:0])_");
rel_178_inv_0_info_25->insert(RamDomain(25),RamDomain(0),RamDomain(1),RamDomain(24),RamDomain(42),RamDomain(203));
}();
/* END STRATUM 173 */
/* BEGIN STRATUM 174 */
[&]() {
SignalHandler::instance()->setMsg(R"_(inv_0.@info.26(26,"v0,v1","Rule","precededBy,v0,v2","genre,v1,v2","inv_0(v0,v1) :- 
   Rule(28),
   precededBy(v0,v2),
   genre(v1,v2).").
in file  [0:0-0:0])_");
rel_179_inv_0_info_26->insert(RamDomain(26),RamDomain(0),RamDomain(1),RamDomain(21),RamDomain(40),RamDomain(204));
}();
/* END STRATUM 174 */
/* BEGIN STRATUM 175 */
[&]() {
SignalHandler::instance()->setMsg(R"_(inv_0.@info.27(27,"v0,v1","Rule","precededBy,v0,v2","genre,v2,v1","inv_0(v0,v1) :- 
   Rule(29),
   precededBy(v0,v2),
   genre(v2,v1).").
in file  [0:0-0:0])_");
rel_180_inv_0_info_27->insert(RamDomain(27),RamDomain(0),RamDomain(1),RamDomain(21),RamDomain(42),RamDomain(205));
}();
/* END STRATUM 175 */
/* BEGIN STRATUM 176 */
[&]() {
SignalHandler::instance()->setMsg(R"_(inv_0.@info.28(28,"v0,v1","Rule","precededBy,v2,v1","genre,v2,v0","inv_0(v0,v1) :- 
   Rule(30),
   precededBy(v2,v1),
   genre(v2,v0).").
in file  [0:0-0:0])_");
rel_181_inv_0_info_28->insert(RamDomain(28),RamDomain(0),RamDomain(1),RamDomain(20),RamDomain(38),RamDomain(206));
}();
/* END STRATUM 176 */
/* BEGIN STRATUM 177 */
[&]() {
SignalHandler::instance()->setMsg(R"_(inv_0.@info.29(29,"v0,v1","Rule","precededBy,v1,v2","genre,v0,v2","inv_0(v0,v1) :- 
   Rule(31),
   precededBy(v1,v2),
   genre(v0,v2).").
in file  [0:0-0:0])_");
rel_182_inv_0_info_29->insert(RamDomain(29),RamDomain(0),RamDomain(1),RamDomain(23),RamDomain(36),RamDomain(207));
}();
/* END STRATUM 177 */
/* BEGIN STRATUM 178 */
[&]() {
SignalHandler::instance()->setMsg(R"_(inv_0.@info.3(3,"v0,v1","Rule","genre,v0,v1","inv_0(v0,v1) :- 
   Rule(2),
   genre(v0,v1).").
in file  [0:0-0:0])_");
rel_183_inv_0_info_3->insert(RamDomain(3),RamDomain(0),RamDomain(1),RamDomain(6),RamDomain(181));
}();
/* END STRATUM 178 */
/* BEGIN STRATUM 179 */
[&]() {
SignalHandler::instance()->setMsg(R"_(inv_0.@info.30(30,"v0,v1","Rule","precededBy,v0,v1","inv_0,v1,v0","inv_0(v0,v1) :- 
   Rule(45),
   precededBy(v0,v1),
   inv_0(v1,v0).").
in file  [0:0-0:0])_");
rel_184_inv_0_info_30->insert(RamDomain(30),RamDomain(0),RamDomain(1),RamDomain(2),RamDomain(12),RamDomain(208));
}();
/* END STRATUM 179 */
/* BEGIN STRATUM 180 */
[&]() {
SignalHandler::instance()->setMsg(R"_(inv_0.@info.31(31,"v0,v1","Rule","precededBy,v1,v0","inv_0,v1,v0","inv_0(v0,v1) :- 
   Rule(46),
   precededBy(v1,v0),
   inv_0(v1,v0).").
in file  [0:0-0:0])_");
rel_185_inv_0_info_31->insert(RamDomain(31),RamDomain(0),RamDomain(1),RamDomain(4),RamDomain(12),RamDomain(209));
}();
/* END STRATUM 180 */
/* BEGIN STRATUM 181 */
[&]() {
SignalHandler::instance()->setMsg(R"_(inv_0.@info.32(32,"v0,v1","Rule","precededBy,v2,v1","inv_0,v0,v2","inv_0(v0,v1) :- 
   Rule(48),
   precededBy(v2,v1),
   inv_0(v0,v2).").
in file  [0:0-0:0])_");
rel_186_inv_0_info_32->insert(RamDomain(32),RamDomain(0),RamDomain(1),RamDomain(20),RamDomain(64),RamDomain(210));
}();
/* END STRATUM 181 */
/* BEGIN STRATUM 182 */
[&]() {
SignalHandler::instance()->setMsg(R"_(inv_0.@info.33(33,"v0,v1","Rule","precededBy,v1,v2","inv_0,v2,v0","inv_0(v0,v1) :- 
   Rule(49),
   precededBy(v1,v2),
   inv_0(v2,v0).").
in file  [0:0-0:0])_");
rel_187_inv_0_info_33->insert(RamDomain(33),RamDomain(0),RamDomain(1),RamDomain(23),RamDomain(66),RamDomain(211));
}();
/* END STRATUM 182 */
/* BEGIN STRATUM 183 */
[&]() {
SignalHandler::instance()->setMsg(R"_(inv_0.@info.34(34,"v0,v1","Rule","precededBy,v2,v0","inv_0,v1,v2","inv_0(v0,v1) :- 
   Rule(50),
   precededBy(v2,v0),
   inv_0(v1,v2).").
in file  [0:0-0:0])_");
rel_188_inv_0_info_34->insert(RamDomain(34),RamDomain(0),RamDomain(1),RamDomain(24),RamDomain(68),RamDomain(212));
}();
/* END STRATUM 183 */
/* BEGIN STRATUM 184 */
[&]() {
SignalHandler::instance()->setMsg(R"_(inv_0.@info.35(35,"v0,v1","Rule","precededBy,v2,v0","inv_0,v2,v1","inv_0(v0,v1) :- 
   Rule(51),
   precededBy(v2,v0),
   inv_0(v2,v1).").
in file  [0:0-0:0])_");
rel_189_inv_0_info_35->insert(RamDomain(35),RamDomain(0),RamDomain(1),RamDomain(24),RamDomain(70),RamDomain(213));
}();
/* END STRATUM 184 */
/* BEGIN STRATUM 185 */
[&]() {
SignalHandler::instance()->setMsg(R"_(inv_0.@info.36(36,"v0,v1","Rule","precededBy,v0,v2","inv_0,v1,v2","inv_0(v0,v1) :- 
   Rule(52),
   precededBy(v0,v2),
   inv_0(v1,v2).").
in file  [0:0-0:0])_");
rel_190_inv_0_info_36->insert(RamDomain(36),RamDomain(0),RamDomain(1),RamDomain(21),RamDomain(68),RamDomain(214));
}();
/* END STRATUM 185 */
/* BEGIN STRATUM 186 */
[&]() {
SignalHandler::instance()->setMsg(R"_(inv_0.@info.37(37,"v0,v1","Rule","precededBy,v0,v2","inv_0,v2,v1","inv_0(v0,v1) :- 
   Rule(53),
   precededBy(v0,v2),
   inv_0(v2,v1).").
in file  [0:0-0:0])_");
rel_191_inv_0_info_37->insert(RamDomain(37),RamDomain(0),RamDomain(1),RamDomain(21),RamDomain(70),RamDomain(215));
}();
/* END STRATUM 186 */
/* BEGIN STRATUM 187 */
[&]() {
SignalHandler::instance()->setMsg(R"_(inv_0.@info.38(38,"v0,v1","Rule","precededBy,v2,v1","inv_0,v2,v0","inv_0(v0,v1) :- 
   Rule(54),
   precededBy(v2,v1),
   inv_0(v2,v0).").
in file  [0:0-0:0])_");
rel_192_inv_0_info_38->insert(RamDomain(38),RamDomain(0),RamDomain(1),RamDomain(20),RamDomain(66),RamDomain(216));
}();
/* END STRATUM 187 */
/* BEGIN STRATUM 188 */
[&]() {
SignalHandler::instance()->setMsg(R"_(inv_0.@info.39(39,"v0,v1","Rule","precededBy,v1,v2","inv_0,v0,v2","inv_0(v0,v1) :- 
   Rule(55),
   precededBy(v1,v2),
   inv_0(v0,v2).").
in file  [0:0-0:0])_");
rel_193_inv_0_info_39->insert(RamDomain(39),RamDomain(0),RamDomain(1),RamDomain(23),RamDomain(64),RamDomain(217));
}();
/* END STRATUM 188 */
/* BEGIN STRATUM 189 */
[&]() {
SignalHandler::instance()->setMsg(R"_(inv_0.@info.4(4,"v0,v1","Rule","genre,v1,v0","inv_0(v0,v1) :- 
   Rule(3),
   genre(v1,v0).").
in file  [0:0-0:0])_");
rel_194_inv_0_info_4->insert(RamDomain(4),RamDomain(0),RamDomain(1),RamDomain(8),RamDomain(182));
}();
/* END STRATUM 189 */
/* BEGIN STRATUM 190 */
[&]() {
SignalHandler::instance()->setMsg(R"_(inv_0.@info.40(40,"v0,v1","Rule","genre,v0,v1","inv_0(v0,v1) :- 
   Rule(56),
   genre(v0,v1).").
in file  [0:0-0:0])_");
rel_195_inv_0_info_40->insert(RamDomain(40),RamDomain(0),RamDomain(1),RamDomain(6),RamDomain(218));
}();
/* END STRATUM 190 */
/* BEGIN STRATUM 191 */
[&]() {
SignalHandler::instance()->setMsg(R"_(inv_0.@info.41(41,"v0,v1","Rule","genre,v0,v1","genre,v1,v0","inv_0(v0,v1) :- 
   Rule(57),
   genre(v0,v1),
   genre(v1,v0).").
in file  [0:0-0:0])_");
rel_196_inv_0_info_41->insert(RamDomain(41),RamDomain(0),RamDomain(1),RamDomain(6),RamDomain(8),RamDomain(219));
}();
/* END STRATUM 191 */
/* BEGIN STRATUM 192 */
[&]() {
SignalHandler::instance()->setMsg(R"_(inv_0.@info.42(42,"v0,v1","Rule","genre,v1,v0","inv_0(v0,v1) :- 
   Rule(58),
   genre(v1,v0).").
in file  [0:0-0:0])_");
rel_197_inv_0_info_42->insert(RamDomain(42),RamDomain(0),RamDomain(1),RamDomain(8),RamDomain(220));
}();
/* END STRATUM 192 */
/* BEGIN STRATUM 193 */
[&]() {
SignalHandler::instance()->setMsg(R"_(inv_0.@info.43(43,"v0,v1","Rule","genre,v1,v0","genre,v0,v1","inv_0(v0,v1) :- 
   Rule(59),
   genre(v1,v0),
   genre(v0,v1).").
in file  [0:0-0:0])_");
rel_198_inv_0_info_43->insert(RamDomain(43),RamDomain(0),RamDomain(1),RamDomain(8),RamDomain(6),RamDomain(221));
}();
/* END STRATUM 193 */
/* BEGIN STRATUM 194 */
[&]() {
SignalHandler::instance()->setMsg(R"_(inv_0.@info.44(44,"v0,v1","Rule","genre,v2,v1","genre,v0,v2","inv_0(v0,v1) :- 
   Rule(60),
   genre(v2,v1),
   genre(v0,v2).").
in file  [0:0-0:0])_");
rel_199_inv_0_info_44->insert(RamDomain(44),RamDomain(0),RamDomain(1),RamDomain(42),RamDomain(36),RamDomain(222));
}();
/* END STRATUM 194 */
/* BEGIN STRATUM 195 */
[&]() {
SignalHandler::instance()->setMsg(R"_(inv_0.@info.45(45,"v0,v1","Rule","genre,v1,v2","genre,v2,v0","inv_0(v0,v1) :- 
   Rule(61),
   genre(v1,v2),
   genre(v2,v0).").
in file  [0:0-0:0])_");
rel_200_inv_0_info_45->insert(RamDomain(45),RamDomain(0),RamDomain(1),RamDomain(40),RamDomain(38),RamDomain(223));
}();
/* END STRATUM 195 */
/* BEGIN STRATUM 196 */
[&]() {
SignalHandler::instance()->setMsg(R"_(inv_0.@info.46(46,"v0,v1","Rule","genre,v2,v0","genre,v1,v2","inv_0(v0,v1) :- 
   Rule(62),
   genre(v2,v0),
   genre(v1,v2).").
in file  [0:0-0:0])_");
rel_201_inv_0_info_46->insert(RamDomain(46),RamDomain(0),RamDomain(1),RamDomain(38),RamDomain(40),RamDomain(224));
}();
/* END STRATUM 196 */
/* BEGIN STRATUM 197 */
[&]() {
SignalHandler::instance()->setMsg(R"_(inv_0.@info.47(47,"v0,v1","Rule","genre,v2,v0","genre,v2,v1","inv_0(v0,v1) :- 
   Rule(63),
   genre(v2,v0),
   genre(v2,v1).").
in file  [0:0-0:0])_");
rel_202_inv_0_info_47->insert(RamDomain(47),RamDomain(0),RamDomain(1),RamDomain(38),RamDomain(42),RamDomain(225));
}();
/* END STRATUM 197 */
/* BEGIN STRATUM 198 */
[&]() {
SignalHandler::instance()->setMsg(R"_(inv_0.@info.48(48,"v0,v1","Rule","genre,v0,v2","genre,v1,v2","inv_0(v0,v1) :- 
   Rule(64),
   genre(v0,v2),
   genre(v1,v2).").
in file  [0:0-0:0])_");
rel_203_inv_0_info_48->insert(RamDomain(48),RamDomain(0),RamDomain(1),RamDomain(36),RamDomain(40),RamDomain(226));
}();
/* END STRATUM 198 */
/* BEGIN STRATUM 199 */
[&]() {
SignalHandler::instance()->setMsg(R"_(inv_0.@info.49(49,"v0,v1","Rule","genre,v0,v2","genre,v2,v1","inv_0(v0,v1) :- 
   Rule(65),
   genre(v0,v2),
   genre(v2,v1).").
in file  [0:0-0:0])_");
rel_204_inv_0_info_49->insert(RamDomain(49),RamDomain(0),RamDomain(1),RamDomain(36),RamDomain(42),RamDomain(227));
}();
/* END STRATUM 199 */
/* BEGIN STRATUM 200 */
[&]() {
SignalHandler::instance()->setMsg(R"_(inv_0.@info.5(5,"v0,v1","Rule","inv_0,v1,v0","inv_0(v0,v1) :- 
   Rule(7),
   inv_0(v1,v0).").
in file  [0:0-0:0])_");
rel_205_inv_0_info_5->insert(RamDomain(5),RamDomain(0),RamDomain(1),RamDomain(12),RamDomain(183));
}();
/* END STRATUM 200 */
/* BEGIN STRATUM 201 */
[&]() {
SignalHandler::instance()->setMsg(R"_(inv_0.@info.50(50,"v0,v1","Rule","genre,v2,v1","genre,v2,v0","inv_0(v0,v1) :- 
   Rule(66),
   genre(v2,v1),
   genre(v2,v0).").
in file  [0:0-0:0])_");
rel_206_inv_0_info_50->insert(RamDomain(50),RamDomain(0),RamDomain(1),RamDomain(42),RamDomain(38),RamDomain(228));
}();
/* END STRATUM 201 */
/* BEGIN STRATUM 202 */
[&]() {
SignalHandler::instance()->setMsg(R"_(inv_0.@info.51(51,"v0,v1","Rule","genre,v1,v2","genre,v0,v2","inv_0(v0,v1) :- 
   Rule(67),
   genre(v1,v2),
   genre(v0,v2).").
in file  [0:0-0:0])_");
rel_207_inv_0_info_51->insert(RamDomain(51),RamDomain(0),RamDomain(1),RamDomain(40),RamDomain(36),RamDomain(229));
}();
/* END STRATUM 202 */
/* BEGIN STRATUM 203 */
[&]() {
SignalHandler::instance()->setMsg(R"_(inv_0.@info.52(52,"v0,v1","Rule","genre,v0,v1","inv_0,v1,v0","inv_0(v0,v1) :- 
   Rule(81),
   genre(v0,v1),
   inv_0(v1,v0).").
in file  [0:0-0:0])_");
rel_208_inv_0_info_52->insert(RamDomain(52),RamDomain(0),RamDomain(1),RamDomain(6),RamDomain(12),RamDomain(230));
}();
/* END STRATUM 203 */
/* BEGIN STRATUM 204 */
[&]() {
SignalHandler::instance()->setMsg(R"_(inv_0.@info.53(53,"v0,v1","Rule","genre,v1,v0","inv_0,v1,v0","inv_0(v0,v1) :- 
   Rule(82),
   genre(v1,v0),
   inv_0(v1,v0).").
in file  [0:0-0:0])_");
rel_209_inv_0_info_53->insert(RamDomain(53),RamDomain(0),RamDomain(1),RamDomain(8),RamDomain(12),RamDomain(231));
}();
/* END STRATUM 204 */
/* BEGIN STRATUM 205 */
[&]() {
SignalHandler::instance()->setMsg(R"_(inv_0.@info.54(54,"v0,v1","Rule","genre,v2,v1","inv_0,v0,v2","inv_0(v0,v1) :- 
   Rule(84),
   genre(v2,v1),
   inv_0(v0,v2).").
in file  [0:0-0:0])_");
rel_210_inv_0_info_54->insert(RamDomain(54),RamDomain(0),RamDomain(1),RamDomain(42),RamDomain(64),RamDomain(232));
}();
/* END STRATUM 205 */
/* BEGIN STRATUM 206 */
[&]() {
SignalHandler::instance()->setMsg(R"_(inv_0.@info.55(55,"v0,v1","Rule","genre,v1,v2","inv_0,v2,v0","inv_0(v0,v1) :- 
   Rule(85),
   genre(v1,v2),
   inv_0(v2,v0).").
in file  [0:0-0:0])_");
rel_211_inv_0_info_55->insert(RamDomain(55),RamDomain(0),RamDomain(1),RamDomain(40),RamDomain(66),RamDomain(233));
}();
/* END STRATUM 206 */
/* BEGIN STRATUM 207 */
[&]() {
SignalHandler::instance()->setMsg(R"_(inv_0.@info.56(56,"v0,v1","Rule","genre,v2,v0","inv_0,v1,v2","inv_0(v0,v1) :- 
   Rule(86),
   genre(v2,v0),
   inv_0(v1,v2).").
in file  [0:0-0:0])_");
rel_212_inv_0_info_56->insert(RamDomain(56),RamDomain(0),RamDomain(1),RamDomain(38),RamDomain(68),RamDomain(234));
}();
/* END STRATUM 207 */
/* BEGIN STRATUM 208 */
[&]() {
SignalHandler::instance()->setMsg(R"_(inv_0.@info.57(57,"v0,v1","Rule","genre,v2,v0","inv_0,v2,v1","inv_0(v0,v1) :- 
   Rule(87),
   genre(v2,v0),
   inv_0(v2,v1).").
in file  [0:0-0:0])_");
rel_213_inv_0_info_57->insert(RamDomain(57),RamDomain(0),RamDomain(1),RamDomain(38),RamDomain(70),RamDomain(235));
}();
/* END STRATUM 208 */
/* BEGIN STRATUM 209 */
[&]() {
SignalHandler::instance()->setMsg(R"_(inv_0.@info.58(58,"v0,v1","Rule","genre,v0,v2","inv_0,v1,v2","inv_0(v0,v1) :- 
   Rule(88),
   genre(v0,v2),
   inv_0(v1,v2).").
in file  [0:0-0:0])_");
rel_214_inv_0_info_58->insert(RamDomain(58),RamDomain(0),RamDomain(1),RamDomain(36),RamDomain(68),RamDomain(236));
}();
/* END STRATUM 209 */
/* BEGIN STRATUM 210 */
[&]() {
SignalHandler::instance()->setMsg(R"_(inv_0.@info.59(59,"v0,v1","Rule","genre,v0,v2","inv_0,v2,v1","inv_0(v0,v1) :- 
   Rule(89),
   genre(v0,v2),
   inv_0(v2,v1).").
in file  [0:0-0:0])_");
rel_215_inv_0_info_59->insert(RamDomain(59),RamDomain(0),RamDomain(1),RamDomain(36),RamDomain(70),RamDomain(237));
}();
/* END STRATUM 210 */
/* BEGIN STRATUM 211 */
[&]() {
SignalHandler::instance()->setMsg(R"_(inv_0.@info.6(6,"v0,v1","Rule","precededBy,v0,v1","inv_0(v0,v1) :- 
   Rule(8),
   precededBy(v0,v1).").
in file  [0:0-0:0])_");
rel_216_inv_0_info_6->insert(RamDomain(6),RamDomain(0),RamDomain(1),RamDomain(2),RamDomain(184));
}();
/* END STRATUM 211 */
/* BEGIN STRATUM 212 */
[&]() {
SignalHandler::instance()->setMsg(R"_(inv_0.@info.60(60,"v0,v1","Rule","genre,v2,v1","inv_0,v2,v0","inv_0(v0,v1) :- 
   Rule(90),
   genre(v2,v1),
   inv_0(v2,v0).").
in file  [0:0-0:0])_");
rel_217_inv_0_info_60->insert(RamDomain(60),RamDomain(0),RamDomain(1),RamDomain(42),RamDomain(66),RamDomain(238));
}();
/* END STRATUM 212 */
/* BEGIN STRATUM 213 */
[&]() {
SignalHandler::instance()->setMsg(R"_(inv_0.@info.61(61,"v0,v1","Rule","genre,v1,v2","inv_0,v0,v2","inv_0(v0,v1) :- 
   Rule(91),
   genre(v1,v2),
   inv_0(v0,v2).").
in file  [0:0-0:0])_");
rel_218_inv_0_info_61->insert(RamDomain(61),RamDomain(0),RamDomain(1),RamDomain(40),RamDomain(64),RamDomain(239));
}();
/* END STRATUM 213 */
/* BEGIN STRATUM 214 */
[&]() {
SignalHandler::instance()->setMsg(R"_(inv_0.@info.62(62,"v0,v1","Rule","inv_0,v1,v0","inv_0(v0,v1) :- 
   Rule(118),
   inv_0(v1,v0).").
in file  [0:0-0:0])_");
rel_219_inv_0_info_62->insert(RamDomain(62),RamDomain(0),RamDomain(1),RamDomain(12),RamDomain(240));
}();
/* END STRATUM 214 */
/* BEGIN STRATUM 215 */
[&]() {
SignalHandler::instance()->setMsg(R"_(inv_0.@info.63(63,"v0,v1","Rule","inv_0,v2,v1","inv_0,v0,v2","inv_0(v0,v1) :- 
   Rule(120),
   inv_0(v2,v1),
   inv_0(v0,v2).").
in file  [0:0-0:0])_");
rel_220_inv_0_info_63->insert(RamDomain(63),RamDomain(0),RamDomain(1),RamDomain(70),RamDomain(64),RamDomain(241));
}();
/* END STRATUM 215 */
/* BEGIN STRATUM 216 */
[&]() {
SignalHandler::instance()->setMsg(R"_(inv_0.@info.64(64,"v0,v1","Rule","inv_0,v1,v2","inv_0,v2,v0","inv_0(v0,v1) :- 
   Rule(121),
   inv_0(v1,v2),
   inv_0(v2,v0).").
in file  [0:0-0:0])_");
rel_221_inv_0_info_64->insert(RamDomain(64),RamDomain(0),RamDomain(1),RamDomain(68),RamDomain(66),RamDomain(242));
}();
/* END STRATUM 216 */
/* BEGIN STRATUM 217 */
[&]() {
SignalHandler::instance()->setMsg(R"_(inv_0.@info.65(65,"v0,v1","Rule","inv_0,v2,v0","inv_0,v1,v2","inv_0(v0,v1) :- 
   Rule(122),
   inv_0(v2,v0),
   inv_0(v1,v2).").
in file  [0:0-0:0])_");
rel_222_inv_0_info_65->insert(RamDomain(65),RamDomain(0),RamDomain(1),RamDomain(66),RamDomain(68),RamDomain(243));
}();
/* END STRATUM 217 */
/* BEGIN STRATUM 218 */
[&]() {
SignalHandler::instance()->setMsg(R"_(inv_0.@info.66(66,"v0,v1","Rule","inv_0,v2,v0","inv_0,v2,v1","inv_0(v0,v1) :- 
   Rule(123),
   inv_0(v2,v0),
   inv_0(v2,v1).").
in file  [0:0-0:0])_");
rel_223_inv_0_info_66->insert(RamDomain(66),RamDomain(0),RamDomain(1),RamDomain(66),RamDomain(70),RamDomain(244));
}();
/* END STRATUM 218 */
/* BEGIN STRATUM 219 */
[&]() {
SignalHandler::instance()->setMsg(R"_(inv_0.@info.67(67,"v0,v1","Rule","inv_0,v0,v2","inv_0,v1,v2","inv_0(v0,v1) :- 
   Rule(124),
   inv_0(v0,v2),
   inv_0(v1,v2).").
in file  [0:0-0:0])_");
rel_224_inv_0_info_67->insert(RamDomain(67),RamDomain(0),RamDomain(1),RamDomain(64),RamDomain(68),RamDomain(245));
}();
/* END STRATUM 219 */
/* BEGIN STRATUM 220 */
[&]() {
SignalHandler::instance()->setMsg(R"_(inv_0.@info.68(68,"v0,v1","Rule","inv_0,v0,v2","inv_0,v2,v1","inv_0(v0,v1) :- 
   Rule(125),
   inv_0(v0,v2),
   inv_0(v2,v1).").
in file  [0:0-0:0])_");
rel_225_inv_0_info_68->insert(RamDomain(68),RamDomain(0),RamDomain(1),RamDomain(64),RamDomain(70),RamDomain(246));
}();
/* END STRATUM 220 */
/* BEGIN STRATUM 221 */
[&]() {
SignalHandler::instance()->setMsg(R"_(inv_0.@info.69(69,"v0,v1","Rule","inv_0,v2,v1","inv_0,v2,v0","inv_0(v0,v1) :- 
   Rule(126),
   inv_0(v2,v1),
   inv_0(v2,v0).").
in file  [0:0-0:0])_");
rel_226_inv_0_info_69->insert(RamDomain(69),RamDomain(0),RamDomain(1),RamDomain(70),RamDomain(66),RamDomain(247));
}();
/* END STRATUM 221 */
/* BEGIN STRATUM 222 */
[&]() {
SignalHandler::instance()->setMsg(R"_(inv_0.@info.7(7,"v0,v1","Rule","precededBy,v0,v1","precededBy,v1,v0","inv_0(v0,v1) :- 
   Rule(9),
   precededBy(v0,v1),
   precededBy(v1,v0).").
in file  [0:0-0:0])_");
rel_227_inv_0_info_7->insert(RamDomain(7),RamDomain(0),RamDomain(1),RamDomain(2),RamDomain(4),RamDomain(185));
}();
/* END STRATUM 222 */
/* BEGIN STRATUM 223 */
[&]() {
SignalHandler::instance()->setMsg(R"_(inv_0.@info.70(70,"v0,v1","Rule","inv_0,v1,v2","inv_0,v0,v2","inv_0(v0,v1) :- 
   Rule(127),
   inv_0(v1,v2),
   inv_0(v0,v2).").
in file  [0:0-0:0])_");
rel_228_inv_0_info_70->insert(RamDomain(70),RamDomain(0),RamDomain(1),RamDomain(68),RamDomain(64),RamDomain(248));
}();
/* END STRATUM 223 */
/* BEGIN STRATUM 224 */
[&]() {
SignalHandler::instance()->setMsg(R"_(inv_0.@info.8(8,"v0,v1","Rule","precededBy,v1,v0","inv_0(v0,v1) :- 
   Rule(10),
   precededBy(v1,v0).").
in file  [0:0-0:0])_");
rel_229_inv_0_info_8->insert(RamDomain(8),RamDomain(0),RamDomain(1),RamDomain(4),RamDomain(186));
}();
/* END STRATUM 224 */
/* BEGIN STRATUM 225 */
[&]() {
SignalHandler::instance()->setMsg(R"_(inv_0.@info.9(9,"v0,v1","Rule","precededBy,v1,v0","precededBy,v0,v1","inv_0(v0,v1) :- 
   Rule(11),
   precededBy(v1,v0),
   precededBy(v0,v1).").
in file  [0:0-0:0])_");
rel_230_inv_0_info_9->insert(RamDomain(9),RamDomain(0),RamDomain(1),RamDomain(4),RamDomain(2),RamDomain(187));
}();
/* END STRATUM 225 */

// -- relation hint statistics --
if(isHintsProfilingEnabled()) {
std::cout << " -- Operation Hint Statistics --\n";
std::cout << "Relation rel_1_Iauthor:\n";
rel_1_Iauthor->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_2_Rule:\n";
rel_2_Rule->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_3_genre:\n";
rel_3_genre->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_4_precededBy:\n";
rel_4_precededBy->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_5_inv_0:\n";
rel_5_inv_0->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_6_delta_inv_0:\n";
rel_6_delta_inv_0->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_7_new_inv_0:\n";
rel_7_new_inv_0->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_8_author:\n";
rel_8_author->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_9_delta_author:\n";
rel_9_delta_author->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_10_new_author:\n";
rel_10_new_author->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_11_author_info_1:\n";
rel_11_author_info_1->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_12_author_info_10:\n";
rel_12_author_info_10->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_13_author_info_100:\n";
rel_13_author_info_100->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_14_author_info_101:\n";
rel_14_author_info_101->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_15_author_info_102:\n";
rel_15_author_info_102->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_16_author_info_103:\n";
rel_16_author_info_103->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_17_author_info_104:\n";
rel_17_author_info_104->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_18_author_info_105:\n";
rel_18_author_info_105->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_19_author_info_106:\n";
rel_19_author_info_106->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_20_author_info_107:\n";
rel_20_author_info_107->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_21_author_info_108:\n";
rel_21_author_info_108->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_22_author_info_109:\n";
rel_22_author_info_109->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_23_author_info_11:\n";
rel_23_author_info_11->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_24_author_info_110:\n";
rel_24_author_info_110->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_25_author_info_111:\n";
rel_25_author_info_111->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_26_author_info_112:\n";
rel_26_author_info_112->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_27_author_info_113:\n";
rel_27_author_info_113->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_28_author_info_114:\n";
rel_28_author_info_114->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_29_author_info_115:\n";
rel_29_author_info_115->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_30_author_info_116:\n";
rel_30_author_info_116->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_31_author_info_117:\n";
rel_31_author_info_117->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_32_author_info_118:\n";
rel_32_author_info_118->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_33_author_info_119:\n";
rel_33_author_info_119->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_34_author_info_12:\n";
rel_34_author_info_12->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_35_author_info_120:\n";
rel_35_author_info_120->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_36_author_info_121:\n";
rel_36_author_info_121->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_37_author_info_122:\n";
rel_37_author_info_122->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_38_author_info_123:\n";
rel_38_author_info_123->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_39_author_info_124:\n";
rel_39_author_info_124->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_40_author_info_125:\n";
rel_40_author_info_125->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_41_author_info_126:\n";
rel_41_author_info_126->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_42_author_info_127:\n";
rel_42_author_info_127->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_43_author_info_128:\n";
rel_43_author_info_128->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_44_author_info_129:\n";
rel_44_author_info_129->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_45_author_info_13:\n";
rel_45_author_info_13->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_46_author_info_130:\n";
rel_46_author_info_130->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_47_author_info_131:\n";
rel_47_author_info_131->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_48_author_info_132:\n";
rel_48_author_info_132->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_49_author_info_133:\n";
rel_49_author_info_133->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_50_author_info_134:\n";
rel_50_author_info_134->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_51_author_info_135:\n";
rel_51_author_info_135->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_52_author_info_136:\n";
rel_52_author_info_136->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_53_author_info_137:\n";
rel_53_author_info_137->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_54_author_info_138:\n";
rel_54_author_info_138->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_55_author_info_139:\n";
rel_55_author_info_139->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_56_author_info_14:\n";
rel_56_author_info_14->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_57_author_info_140:\n";
rel_57_author_info_140->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_58_author_info_141:\n";
rel_58_author_info_141->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_59_author_info_142:\n";
rel_59_author_info_142->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_60_author_info_143:\n";
rel_60_author_info_143->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_61_author_info_144:\n";
rel_61_author_info_144->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_62_author_info_145:\n";
rel_62_author_info_145->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_63_author_info_146:\n";
rel_63_author_info_146->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_64_author_info_147:\n";
rel_64_author_info_147->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_65_author_info_148:\n";
rel_65_author_info_148->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_66_author_info_149:\n";
rel_66_author_info_149->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_67_author_info_15:\n";
rel_67_author_info_15->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_68_author_info_150:\n";
rel_68_author_info_150->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_69_author_info_16:\n";
rel_69_author_info_16->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_70_author_info_17:\n";
rel_70_author_info_17->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_71_author_info_18:\n";
rel_71_author_info_18->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_72_author_info_19:\n";
rel_72_author_info_19->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_73_author_info_2:\n";
rel_73_author_info_2->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_74_author_info_20:\n";
rel_74_author_info_20->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_75_author_info_21:\n";
rel_75_author_info_21->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_76_author_info_22:\n";
rel_76_author_info_22->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_77_author_info_23:\n";
rel_77_author_info_23->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_78_author_info_24:\n";
rel_78_author_info_24->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_79_author_info_25:\n";
rel_79_author_info_25->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_80_author_info_26:\n";
rel_80_author_info_26->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_81_author_info_27:\n";
rel_81_author_info_27->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_82_author_info_28:\n";
rel_82_author_info_28->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_83_author_info_29:\n";
rel_83_author_info_29->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_84_author_info_3:\n";
rel_84_author_info_3->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_85_author_info_30:\n";
rel_85_author_info_30->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_86_author_info_31:\n";
rel_86_author_info_31->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_87_author_info_32:\n";
rel_87_author_info_32->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_88_author_info_33:\n";
rel_88_author_info_33->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_89_author_info_34:\n";
rel_89_author_info_34->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_90_author_info_35:\n";
rel_90_author_info_35->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_91_author_info_36:\n";
rel_91_author_info_36->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_92_author_info_37:\n";
rel_92_author_info_37->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_93_author_info_38:\n";
rel_93_author_info_38->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_94_author_info_39:\n";
rel_94_author_info_39->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_95_author_info_4:\n";
rel_95_author_info_4->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_96_author_info_40:\n";
rel_96_author_info_40->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_97_author_info_41:\n";
rel_97_author_info_41->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_98_author_info_42:\n";
rel_98_author_info_42->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_99_author_info_43:\n";
rel_99_author_info_43->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_100_author_info_44:\n";
rel_100_author_info_44->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_101_author_info_45:\n";
rel_101_author_info_45->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_102_author_info_46:\n";
rel_102_author_info_46->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_103_author_info_47:\n";
rel_103_author_info_47->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_104_author_info_48:\n";
rel_104_author_info_48->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_105_author_info_49:\n";
rel_105_author_info_49->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_106_author_info_5:\n";
rel_106_author_info_5->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_107_author_info_50:\n";
rel_107_author_info_50->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_108_author_info_51:\n";
rel_108_author_info_51->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_109_author_info_52:\n";
rel_109_author_info_52->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_110_author_info_53:\n";
rel_110_author_info_53->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_111_author_info_54:\n";
rel_111_author_info_54->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_112_author_info_55:\n";
rel_112_author_info_55->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_113_author_info_56:\n";
rel_113_author_info_56->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_114_author_info_57:\n";
rel_114_author_info_57->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_115_author_info_58:\n";
rel_115_author_info_58->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_116_author_info_59:\n";
rel_116_author_info_59->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_117_author_info_6:\n";
rel_117_author_info_6->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_118_author_info_60:\n";
rel_118_author_info_60->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_119_author_info_61:\n";
rel_119_author_info_61->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_120_author_info_62:\n";
rel_120_author_info_62->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_121_author_info_63:\n";
rel_121_author_info_63->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_122_author_info_64:\n";
rel_122_author_info_64->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_123_author_info_65:\n";
rel_123_author_info_65->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_124_author_info_66:\n";
rel_124_author_info_66->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_125_author_info_67:\n";
rel_125_author_info_67->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_126_author_info_68:\n";
rel_126_author_info_68->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_127_author_info_69:\n";
rel_127_author_info_69->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_128_author_info_7:\n";
rel_128_author_info_7->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_129_author_info_70:\n";
rel_129_author_info_70->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_130_author_info_71:\n";
rel_130_author_info_71->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_131_author_info_72:\n";
rel_131_author_info_72->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_132_author_info_73:\n";
rel_132_author_info_73->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_133_author_info_74:\n";
rel_133_author_info_74->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_134_author_info_75:\n";
rel_134_author_info_75->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_135_author_info_76:\n";
rel_135_author_info_76->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_136_author_info_77:\n";
rel_136_author_info_77->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_137_author_info_78:\n";
rel_137_author_info_78->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_138_author_info_79:\n";
rel_138_author_info_79->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_139_author_info_8:\n";
rel_139_author_info_8->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_140_author_info_80:\n";
rel_140_author_info_80->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_141_author_info_81:\n";
rel_141_author_info_81->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_142_author_info_82:\n";
rel_142_author_info_82->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_143_author_info_83:\n";
rel_143_author_info_83->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_144_author_info_84:\n";
rel_144_author_info_84->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_145_author_info_85:\n";
rel_145_author_info_85->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_146_author_info_86:\n";
rel_146_author_info_86->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_147_author_info_87:\n";
rel_147_author_info_87->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_148_author_info_88:\n";
rel_148_author_info_88->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_149_author_info_89:\n";
rel_149_author_info_89->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_150_author_info_9:\n";
rel_150_author_info_9->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_151_author_info_90:\n";
rel_151_author_info_90->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_152_author_info_91:\n";
rel_152_author_info_91->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_153_author_info_92:\n";
rel_153_author_info_92->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_154_author_info_93:\n";
rel_154_author_info_93->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_155_author_info_94:\n";
rel_155_author_info_94->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_156_author_info_95:\n";
rel_156_author_info_95->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_157_author_info_96:\n";
rel_157_author_info_96->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_158_author_info_97:\n";
rel_158_author_info_97->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_159_author_info_98:\n";
rel_159_author_info_98->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_160_author_info_99:\n";
rel_160_author_info_99->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_161_inv_0_info_1:\n";
rel_161_inv_0_info_1->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_162_inv_0_info_10:\n";
rel_162_inv_0_info_10->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_163_inv_0_info_11:\n";
rel_163_inv_0_info_11->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_164_inv_0_info_12:\n";
rel_164_inv_0_info_12->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_165_inv_0_info_13:\n";
rel_165_inv_0_info_13->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_166_inv_0_info_14:\n";
rel_166_inv_0_info_14->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_167_inv_0_info_15:\n";
rel_167_inv_0_info_15->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_168_inv_0_info_16:\n";
rel_168_inv_0_info_16->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_169_inv_0_info_17:\n";
rel_169_inv_0_info_17->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_170_inv_0_info_18:\n";
rel_170_inv_0_info_18->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_171_inv_0_info_19:\n";
rel_171_inv_0_info_19->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_172_inv_0_info_2:\n";
rel_172_inv_0_info_2->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_173_inv_0_info_20:\n";
rel_173_inv_0_info_20->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_174_inv_0_info_21:\n";
rel_174_inv_0_info_21->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_175_inv_0_info_22:\n";
rel_175_inv_0_info_22->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_176_inv_0_info_23:\n";
rel_176_inv_0_info_23->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_177_inv_0_info_24:\n";
rel_177_inv_0_info_24->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_178_inv_0_info_25:\n";
rel_178_inv_0_info_25->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_179_inv_0_info_26:\n";
rel_179_inv_0_info_26->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_180_inv_0_info_27:\n";
rel_180_inv_0_info_27->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_181_inv_0_info_28:\n";
rel_181_inv_0_info_28->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_182_inv_0_info_29:\n";
rel_182_inv_0_info_29->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_183_inv_0_info_3:\n";
rel_183_inv_0_info_3->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_184_inv_0_info_30:\n";
rel_184_inv_0_info_30->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_185_inv_0_info_31:\n";
rel_185_inv_0_info_31->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_186_inv_0_info_32:\n";
rel_186_inv_0_info_32->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_187_inv_0_info_33:\n";
rel_187_inv_0_info_33->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_188_inv_0_info_34:\n";
rel_188_inv_0_info_34->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_189_inv_0_info_35:\n";
rel_189_inv_0_info_35->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_190_inv_0_info_36:\n";
rel_190_inv_0_info_36->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_191_inv_0_info_37:\n";
rel_191_inv_0_info_37->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_192_inv_0_info_38:\n";
rel_192_inv_0_info_38->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_193_inv_0_info_39:\n";
rel_193_inv_0_info_39->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_194_inv_0_info_4:\n";
rel_194_inv_0_info_4->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_195_inv_0_info_40:\n";
rel_195_inv_0_info_40->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_196_inv_0_info_41:\n";
rel_196_inv_0_info_41->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_197_inv_0_info_42:\n";
rel_197_inv_0_info_42->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_198_inv_0_info_43:\n";
rel_198_inv_0_info_43->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_199_inv_0_info_44:\n";
rel_199_inv_0_info_44->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_200_inv_0_info_45:\n";
rel_200_inv_0_info_45->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_201_inv_0_info_46:\n";
rel_201_inv_0_info_46->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_202_inv_0_info_47:\n";
rel_202_inv_0_info_47->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_203_inv_0_info_48:\n";
rel_203_inv_0_info_48->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_204_inv_0_info_49:\n";
rel_204_inv_0_info_49->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_205_inv_0_info_5:\n";
rel_205_inv_0_info_5->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_206_inv_0_info_50:\n";
rel_206_inv_0_info_50->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_207_inv_0_info_51:\n";
rel_207_inv_0_info_51->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_208_inv_0_info_52:\n";
rel_208_inv_0_info_52->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_209_inv_0_info_53:\n";
rel_209_inv_0_info_53->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_210_inv_0_info_54:\n";
rel_210_inv_0_info_54->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_211_inv_0_info_55:\n";
rel_211_inv_0_info_55->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_212_inv_0_info_56:\n";
rel_212_inv_0_info_56->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_213_inv_0_info_57:\n";
rel_213_inv_0_info_57->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_214_inv_0_info_58:\n";
rel_214_inv_0_info_58->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_215_inv_0_info_59:\n";
rel_215_inv_0_info_59->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_216_inv_0_info_6:\n";
rel_216_inv_0_info_6->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_217_inv_0_info_60:\n";
rel_217_inv_0_info_60->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_218_inv_0_info_61:\n";
rel_218_inv_0_info_61->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_219_inv_0_info_62:\n";
rel_219_inv_0_info_62->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_220_inv_0_info_63:\n";
rel_220_inv_0_info_63->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_221_inv_0_info_64:\n";
rel_221_inv_0_info_64->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_222_inv_0_info_65:\n";
rel_222_inv_0_info_65->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_223_inv_0_info_66:\n";
rel_223_inv_0_info_66->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_224_inv_0_info_67:\n";
rel_224_inv_0_info_67->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_225_inv_0_info_68:\n";
rel_225_inv_0_info_68->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_226_inv_0_info_69:\n";
rel_226_inv_0_info_69->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_227_inv_0_info_7:\n";
rel_227_inv_0_info_7->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_228_inv_0_info_70:\n";
rel_228_inv_0_info_70->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_229_inv_0_info_8:\n";
rel_229_inv_0_info_8->printHintStatistics(std::cout,"  ");
std::cout << "\n";
std::cout << "Relation rel_230_inv_0_info_9:\n";
rel_230_inv_0_info_9->printHintStatistics(std::cout,"  ");
std::cout << "\n";
}
SignalHandler::instance()->reset();
}
public:
void run(size_t stratumIndex = (size_t) -1) override { runFunction(".", ".", stratumIndex, false); }
public:
void runAll(std::string inputDirectory = ".", std::string outputDirectory = ".", size_t stratumIndex = (size_t) -1) override { runFunction(inputDirectory, outputDirectory, stratumIndex, true);
}
public:
void printAll(std::string outputDirectory = ".") override {
try {std::map<std::string, std::string> directiveMap({{"IO","file"},{"attributeNames","v0\tv1"},{"filename","./inv_0.csv"},{"name","inv_0"}});
if (!outputDirectory.empty() && directiveMap["IO"] == "file" && directiveMap["filename"].front() != '/') {directiveMap["filename"] = outputDirectory + "/" + directiveMap["filename"];}
IODirectives ioDirectives(directiveMap);
IOSystem::getInstance().getWriter(std::vector<bool>({1,1,0,0}), symTable, ioDirectives, true)->writeAll(*rel_5_inv_0);
} catch (std::exception& e) {std::cerr << e.what();exit(1);}
try {std::map<std::string, std::string> directiveMap({{"IO","file"},{"attributeNames","v0\tv1"},{"filename","./author.csv"},{"name","author"}});
if (!outputDirectory.empty() && directiveMap["IO"] == "file" && directiveMap["filename"].front() != '/') {directiveMap["filename"] = outputDirectory + "/" + directiveMap["filename"];}
IODirectives ioDirectives(directiveMap);
IOSystem::getInstance().getWriter(std::vector<bool>({1,1,0,0}), symTable, ioDirectives, true)->writeAll(*rel_8_author);
} catch (std::exception& e) {std::cerr << e.what();exit(1);}
}
public:
void loadAll(std::string inputDirectory = ".") override {
try {std::map<std::string, std::string> directiveMap({{"IO","file"},{"filename","./Iauthor.facts"},{"name","Iauthor"}});
if (!inputDirectory.empty() && directiveMap["IO"] == "file" && directiveMap["filename"].front() != '/') {directiveMap["filename"] = inputDirectory + "/" + directiveMap["filename"];}
IODirectives ioDirectives(directiveMap);
IOSystem::getInstance().getReader(std::vector<bool>({1,1,0,0}), symTable, ioDirectives, true)->readAll(*rel_1_Iauthor);
} catch (std::exception& e) {std::cerr << "Error loading data: " << e.what() << '\n';}
try {std::map<std::string, std::string> directiveMap({{"IO","file"},{"filename","./Rule.facts"},{"name","Rule"}});
if (!inputDirectory.empty() && directiveMap["IO"] == "file" && directiveMap["filename"].front() != '/') {directiveMap["filename"] = inputDirectory + "/" + directiveMap["filename"];}
IODirectives ioDirectives(directiveMap);
IOSystem::getInstance().getReader(std::vector<bool>({0,0,0}), symTable, ioDirectives, true)->readAll(*rel_2_Rule);
} catch (std::exception& e) {std::cerr << "Error loading data: " << e.what() << '\n';}
try {std::map<std::string, std::string> directiveMap({{"IO","file"},{"filename","./genre.facts"},{"name","genre"}});
if (!inputDirectory.empty() && directiveMap["IO"] == "file" && directiveMap["filename"].front() != '/') {directiveMap["filename"] = inputDirectory + "/" + directiveMap["filename"];}
IODirectives ioDirectives(directiveMap);
IOSystem::getInstance().getReader(std::vector<bool>({1,1,0,0}), symTable, ioDirectives, true)->readAll(*rel_3_genre);
} catch (std::exception& e) {std::cerr << "Error loading data: " << e.what() << '\n';}
try {std::map<std::string, std::string> directiveMap({{"IO","file"},{"filename","./precededBy.facts"},{"name","precededBy"}});
if (!inputDirectory.empty() && directiveMap["IO"] == "file" && directiveMap["filename"].front() != '/') {directiveMap["filename"] = inputDirectory + "/" + directiveMap["filename"];}
IODirectives ioDirectives(directiveMap);
IOSystem::getInstance().getReader(std::vector<bool>({1,1,0,0}), symTable, ioDirectives, true)->readAll(*rel_4_precededBy);
} catch (std::exception& e) {std::cerr << "Error loading data: " << e.what() << '\n';}
}
public:
void dumpInputs(std::ostream& out = std::cout) override {
try {IODirectives ioDirectives;
ioDirectives.setIOType("stdout");
ioDirectives.setRelationName("rel_1_Iauthor");
IOSystem::getInstance().getWriter(std::vector<bool>({1,1,0,0}), symTable, ioDirectives, true)->writeAll(*rel_1_Iauthor);
} catch (std::exception& e) {std::cerr << e.what();exit(1);}
try {IODirectives ioDirectives;
ioDirectives.setIOType("stdout");
ioDirectives.setRelationName("rel_2_Rule");
IOSystem::getInstance().getWriter(std::vector<bool>({0,0,0}), symTable, ioDirectives, true)->writeAll(*rel_2_Rule);
} catch (std::exception& e) {std::cerr << e.what();exit(1);}
try {IODirectives ioDirectives;
ioDirectives.setIOType("stdout");
ioDirectives.setRelationName("rel_3_genre");
IOSystem::getInstance().getWriter(std::vector<bool>({1,1,0,0}), symTable, ioDirectives, true)->writeAll(*rel_3_genre);
} catch (std::exception& e) {std::cerr << e.what();exit(1);}
try {IODirectives ioDirectives;
ioDirectives.setIOType("stdout");
ioDirectives.setRelationName("rel_4_precededBy");
IOSystem::getInstance().getWriter(std::vector<bool>({1,1,0,0}), symTable, ioDirectives, true)->writeAll(*rel_4_precededBy);
} catch (std::exception& e) {std::cerr << e.what();exit(1);}
}
public:
void dumpOutputs(std::ostream& out = std::cout) override {
try {IODirectives ioDirectives;
ioDirectives.setIOType("stdout");
ioDirectives.setRelationName("rel_5_inv_0");
IOSystem::getInstance().getWriter(std::vector<bool>({1,1,0,0}), symTable, ioDirectives, true)->writeAll(*rel_5_inv_0);
} catch (std::exception& e) {std::cerr << e.what();exit(1);}
try {IODirectives ioDirectives;
ioDirectives.setIOType("stdout");
ioDirectives.setRelationName("rel_8_author");
IOSystem::getInstance().getWriter(std::vector<bool>({1,1,0,0}), symTable, ioDirectives, true)->writeAll(*rel_8_author);
} catch (std::exception& e) {std::cerr << e.what();exit(1);}
}
public:
SymbolTable& getSymbolTable() override {
return symTable;
}
void executeSubroutine(std::string name, const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) override {
if (name == "author_100_negation_subproof") {
subproof_0(args, ret, err);
}
if (name == "author_100_subproof") {
subproof_1(args, ret, err);
}
if (name == "author_101_negation_subproof") {
subproof_2(args, ret, err);
}
if (name == "author_101_subproof") {
subproof_3(args, ret, err);
}
if (name == "author_102_negation_subproof") {
subproof_4(args, ret, err);
}
if (name == "author_102_subproof") {
subproof_5(args, ret, err);
}
if (name == "author_103_negation_subproof") {
subproof_6(args, ret, err);
}
if (name == "author_103_subproof") {
subproof_7(args, ret, err);
}
if (name == "author_104_negation_subproof") {
subproof_8(args, ret, err);
}
if (name == "author_104_subproof") {
subproof_9(args, ret, err);
}
if (name == "author_105_negation_subproof") {
subproof_10(args, ret, err);
}
if (name == "author_105_subproof") {
subproof_11(args, ret, err);
}
if (name == "author_106_negation_subproof") {
subproof_12(args, ret, err);
}
if (name == "author_106_subproof") {
subproof_13(args, ret, err);
}
if (name == "author_107_negation_subproof") {
subproof_14(args, ret, err);
}
if (name == "author_107_subproof") {
subproof_15(args, ret, err);
}
if (name == "author_108_negation_subproof") {
subproof_16(args, ret, err);
}
if (name == "author_108_subproof") {
subproof_17(args, ret, err);
}
if (name == "author_109_negation_subproof") {
subproof_18(args, ret, err);
}
if (name == "author_109_subproof") {
subproof_19(args, ret, err);
}
if (name == "author_10_negation_subproof") {
subproof_20(args, ret, err);
}
if (name == "author_10_subproof") {
subproof_21(args, ret, err);
}
if (name == "author_110_negation_subproof") {
subproof_22(args, ret, err);
}
if (name == "author_110_subproof") {
subproof_23(args, ret, err);
}
if (name == "author_111_negation_subproof") {
subproof_24(args, ret, err);
}
if (name == "author_111_subproof") {
subproof_25(args, ret, err);
}
if (name == "author_112_negation_subproof") {
subproof_26(args, ret, err);
}
if (name == "author_112_subproof") {
subproof_27(args, ret, err);
}
if (name == "author_113_negation_subproof") {
subproof_28(args, ret, err);
}
if (name == "author_113_subproof") {
subproof_29(args, ret, err);
}
if (name == "author_114_negation_subproof") {
subproof_30(args, ret, err);
}
if (name == "author_114_subproof") {
subproof_31(args, ret, err);
}
if (name == "author_115_negation_subproof") {
subproof_32(args, ret, err);
}
if (name == "author_115_subproof") {
subproof_33(args, ret, err);
}
if (name == "author_116_negation_subproof") {
subproof_34(args, ret, err);
}
if (name == "author_116_subproof") {
subproof_35(args, ret, err);
}
if (name == "author_117_negation_subproof") {
subproof_36(args, ret, err);
}
if (name == "author_117_subproof") {
subproof_37(args, ret, err);
}
if (name == "author_118_negation_subproof") {
subproof_38(args, ret, err);
}
if (name == "author_118_subproof") {
subproof_39(args, ret, err);
}
if (name == "author_119_negation_subproof") {
subproof_40(args, ret, err);
}
if (name == "author_119_subproof") {
subproof_41(args, ret, err);
}
if (name == "author_11_negation_subproof") {
subproof_42(args, ret, err);
}
if (name == "author_11_subproof") {
subproof_43(args, ret, err);
}
if (name == "author_120_negation_subproof") {
subproof_44(args, ret, err);
}
if (name == "author_120_subproof") {
subproof_45(args, ret, err);
}
if (name == "author_121_negation_subproof") {
subproof_46(args, ret, err);
}
if (name == "author_121_subproof") {
subproof_47(args, ret, err);
}
if (name == "author_122_negation_subproof") {
subproof_48(args, ret, err);
}
if (name == "author_122_subproof") {
subproof_49(args, ret, err);
}
if (name == "author_123_negation_subproof") {
subproof_50(args, ret, err);
}
if (name == "author_123_subproof") {
subproof_51(args, ret, err);
}
if (name == "author_124_negation_subproof") {
subproof_52(args, ret, err);
}
if (name == "author_124_subproof") {
subproof_53(args, ret, err);
}
if (name == "author_125_negation_subproof") {
subproof_54(args, ret, err);
}
if (name == "author_125_subproof") {
subproof_55(args, ret, err);
}
if (name == "author_126_negation_subproof") {
subproof_56(args, ret, err);
}
if (name == "author_126_subproof") {
subproof_57(args, ret, err);
}
if (name == "author_127_negation_subproof") {
subproof_58(args, ret, err);
}
if (name == "author_127_subproof") {
subproof_59(args, ret, err);
}
if (name == "author_128_negation_subproof") {
subproof_60(args, ret, err);
}
if (name == "author_128_subproof") {
subproof_61(args, ret, err);
}
if (name == "author_129_negation_subproof") {
subproof_62(args, ret, err);
}
if (name == "author_129_subproof") {
subproof_63(args, ret, err);
}
if (name == "author_12_negation_subproof") {
subproof_64(args, ret, err);
}
if (name == "author_12_subproof") {
subproof_65(args, ret, err);
}
if (name == "author_130_negation_subproof") {
subproof_66(args, ret, err);
}
if (name == "author_130_subproof") {
subproof_67(args, ret, err);
}
if (name == "author_131_negation_subproof") {
subproof_68(args, ret, err);
}
if (name == "author_131_subproof") {
subproof_69(args, ret, err);
}
if (name == "author_132_negation_subproof") {
subproof_70(args, ret, err);
}
if (name == "author_132_subproof") {
subproof_71(args, ret, err);
}
if (name == "author_133_negation_subproof") {
subproof_72(args, ret, err);
}
if (name == "author_133_subproof") {
subproof_73(args, ret, err);
}
if (name == "author_134_negation_subproof") {
subproof_74(args, ret, err);
}
if (name == "author_134_subproof") {
subproof_75(args, ret, err);
}
if (name == "author_135_negation_subproof") {
subproof_76(args, ret, err);
}
if (name == "author_135_subproof") {
subproof_77(args, ret, err);
}
if (name == "author_136_negation_subproof") {
subproof_78(args, ret, err);
}
if (name == "author_136_subproof") {
subproof_79(args, ret, err);
}
if (name == "author_137_negation_subproof") {
subproof_80(args, ret, err);
}
if (name == "author_137_subproof") {
subproof_81(args, ret, err);
}
if (name == "author_138_negation_subproof") {
subproof_82(args, ret, err);
}
if (name == "author_138_subproof") {
subproof_83(args, ret, err);
}
if (name == "author_139_negation_subproof") {
subproof_84(args, ret, err);
}
if (name == "author_139_subproof") {
subproof_85(args, ret, err);
}
if (name == "author_13_negation_subproof") {
subproof_86(args, ret, err);
}
if (name == "author_13_subproof") {
subproof_87(args, ret, err);
}
if (name == "author_140_negation_subproof") {
subproof_88(args, ret, err);
}
if (name == "author_140_subproof") {
subproof_89(args, ret, err);
}
if (name == "author_141_negation_subproof") {
subproof_90(args, ret, err);
}
if (name == "author_141_subproof") {
subproof_91(args, ret, err);
}
if (name == "author_142_negation_subproof") {
subproof_92(args, ret, err);
}
if (name == "author_142_subproof") {
subproof_93(args, ret, err);
}
if (name == "author_143_negation_subproof") {
subproof_94(args, ret, err);
}
if (name == "author_143_subproof") {
subproof_95(args, ret, err);
}
if (name == "author_144_negation_subproof") {
subproof_96(args, ret, err);
}
if (name == "author_144_subproof") {
subproof_97(args, ret, err);
}
if (name == "author_145_negation_subproof") {
subproof_98(args, ret, err);
}
if (name == "author_145_subproof") {
subproof_99(args, ret, err);
}
if (name == "author_146_negation_subproof") {
subproof_100(args, ret, err);
}
if (name == "author_146_subproof") {
subproof_101(args, ret, err);
}
if (name == "author_147_negation_subproof") {
subproof_102(args, ret, err);
}
if (name == "author_147_subproof") {
subproof_103(args, ret, err);
}
if (name == "author_148_negation_subproof") {
subproof_104(args, ret, err);
}
if (name == "author_148_subproof") {
subproof_105(args, ret, err);
}
if (name == "author_149_negation_subproof") {
subproof_106(args, ret, err);
}
if (name == "author_149_subproof") {
subproof_107(args, ret, err);
}
if (name == "author_14_negation_subproof") {
subproof_108(args, ret, err);
}
if (name == "author_14_subproof") {
subproof_109(args, ret, err);
}
if (name == "author_150_negation_subproof") {
subproof_110(args, ret, err);
}
if (name == "author_150_subproof") {
subproof_111(args, ret, err);
}
if (name == "author_15_negation_subproof") {
subproof_112(args, ret, err);
}
if (name == "author_15_subproof") {
subproof_113(args, ret, err);
}
if (name == "author_16_negation_subproof") {
subproof_114(args, ret, err);
}
if (name == "author_16_subproof") {
subproof_115(args, ret, err);
}
if (name == "author_17_negation_subproof") {
subproof_116(args, ret, err);
}
if (name == "author_17_subproof") {
subproof_117(args, ret, err);
}
if (name == "author_18_negation_subproof") {
subproof_118(args, ret, err);
}
if (name == "author_18_subproof") {
subproof_119(args, ret, err);
}
if (name == "author_19_negation_subproof") {
subproof_120(args, ret, err);
}
if (name == "author_19_subproof") {
subproof_121(args, ret, err);
}
if (name == "author_1_negation_subproof") {
subproof_122(args, ret, err);
}
if (name == "author_1_subproof") {
subproof_123(args, ret, err);
}
if (name == "author_20_negation_subproof") {
subproof_124(args, ret, err);
}
if (name == "author_20_subproof") {
subproof_125(args, ret, err);
}
if (name == "author_21_negation_subproof") {
subproof_126(args, ret, err);
}
if (name == "author_21_subproof") {
subproof_127(args, ret, err);
}
if (name == "author_22_negation_subproof") {
subproof_128(args, ret, err);
}
if (name == "author_22_subproof") {
subproof_129(args, ret, err);
}
if (name == "author_23_negation_subproof") {
subproof_130(args, ret, err);
}
if (name == "author_23_subproof") {
subproof_131(args, ret, err);
}
if (name == "author_24_negation_subproof") {
subproof_132(args, ret, err);
}
if (name == "author_24_subproof") {
subproof_133(args, ret, err);
}
if (name == "author_25_negation_subproof") {
subproof_134(args, ret, err);
}
if (name == "author_25_subproof") {
subproof_135(args, ret, err);
}
if (name == "author_26_negation_subproof") {
subproof_136(args, ret, err);
}
if (name == "author_26_subproof") {
subproof_137(args, ret, err);
}
if (name == "author_27_negation_subproof") {
subproof_138(args, ret, err);
}
if (name == "author_27_subproof") {
subproof_139(args, ret, err);
}
if (name == "author_28_negation_subproof") {
subproof_140(args, ret, err);
}
if (name == "author_28_subproof") {
subproof_141(args, ret, err);
}
if (name == "author_29_negation_subproof") {
subproof_142(args, ret, err);
}
if (name == "author_29_subproof") {
subproof_143(args, ret, err);
}
if (name == "author_2_negation_subproof") {
subproof_144(args, ret, err);
}
if (name == "author_2_subproof") {
subproof_145(args, ret, err);
}
if (name == "author_30_negation_subproof") {
subproof_146(args, ret, err);
}
if (name == "author_30_subproof") {
subproof_147(args, ret, err);
}
if (name == "author_31_negation_subproof") {
subproof_148(args, ret, err);
}
if (name == "author_31_subproof") {
subproof_149(args, ret, err);
}
if (name == "author_32_negation_subproof") {
subproof_150(args, ret, err);
}
if (name == "author_32_subproof") {
subproof_151(args, ret, err);
}
if (name == "author_33_negation_subproof") {
subproof_152(args, ret, err);
}
if (name == "author_33_subproof") {
subproof_153(args, ret, err);
}
if (name == "author_34_negation_subproof") {
subproof_154(args, ret, err);
}
if (name == "author_34_subproof") {
subproof_155(args, ret, err);
}
if (name == "author_35_negation_subproof") {
subproof_156(args, ret, err);
}
if (name == "author_35_subproof") {
subproof_157(args, ret, err);
}
if (name == "author_36_negation_subproof") {
subproof_158(args, ret, err);
}
if (name == "author_36_subproof") {
subproof_159(args, ret, err);
}
if (name == "author_37_negation_subproof") {
subproof_160(args, ret, err);
}
if (name == "author_37_subproof") {
subproof_161(args, ret, err);
}
if (name == "author_38_negation_subproof") {
subproof_162(args, ret, err);
}
if (name == "author_38_subproof") {
subproof_163(args, ret, err);
}
if (name == "author_39_negation_subproof") {
subproof_164(args, ret, err);
}
if (name == "author_39_subproof") {
subproof_165(args, ret, err);
}
if (name == "author_3_negation_subproof") {
subproof_166(args, ret, err);
}
if (name == "author_3_subproof") {
subproof_167(args, ret, err);
}
if (name == "author_40_negation_subproof") {
subproof_168(args, ret, err);
}
if (name == "author_40_subproof") {
subproof_169(args, ret, err);
}
if (name == "author_41_negation_subproof") {
subproof_170(args, ret, err);
}
if (name == "author_41_subproof") {
subproof_171(args, ret, err);
}
if (name == "author_42_negation_subproof") {
subproof_172(args, ret, err);
}
if (name == "author_42_subproof") {
subproof_173(args, ret, err);
}
if (name == "author_43_negation_subproof") {
subproof_174(args, ret, err);
}
if (name == "author_43_subproof") {
subproof_175(args, ret, err);
}
if (name == "author_44_negation_subproof") {
subproof_176(args, ret, err);
}
if (name == "author_44_subproof") {
subproof_177(args, ret, err);
}
if (name == "author_45_negation_subproof") {
subproof_178(args, ret, err);
}
if (name == "author_45_subproof") {
subproof_179(args, ret, err);
}
if (name == "author_46_negation_subproof") {
subproof_180(args, ret, err);
}
if (name == "author_46_subproof") {
subproof_181(args, ret, err);
}
if (name == "author_47_negation_subproof") {
subproof_182(args, ret, err);
}
if (name == "author_47_subproof") {
subproof_183(args, ret, err);
}
if (name == "author_48_negation_subproof") {
subproof_184(args, ret, err);
}
if (name == "author_48_subproof") {
subproof_185(args, ret, err);
}
if (name == "author_49_negation_subproof") {
subproof_186(args, ret, err);
}
if (name == "author_49_subproof") {
subproof_187(args, ret, err);
}
if (name == "author_4_negation_subproof") {
subproof_188(args, ret, err);
}
if (name == "author_4_subproof") {
subproof_189(args, ret, err);
}
if (name == "author_50_negation_subproof") {
subproof_190(args, ret, err);
}
if (name == "author_50_subproof") {
subproof_191(args, ret, err);
}
if (name == "author_51_negation_subproof") {
subproof_192(args, ret, err);
}
if (name == "author_51_subproof") {
subproof_193(args, ret, err);
}
if (name == "author_52_negation_subproof") {
subproof_194(args, ret, err);
}
if (name == "author_52_subproof") {
subproof_195(args, ret, err);
}
if (name == "author_53_negation_subproof") {
subproof_196(args, ret, err);
}
if (name == "author_53_subproof") {
subproof_197(args, ret, err);
}
if (name == "author_54_negation_subproof") {
subproof_198(args, ret, err);
}
if (name == "author_54_subproof") {
subproof_199(args, ret, err);
}
if (name == "author_55_negation_subproof") {
subproof_200(args, ret, err);
}
if (name == "author_55_subproof") {
subproof_201(args, ret, err);
}
if (name == "author_56_negation_subproof") {
subproof_202(args, ret, err);
}
if (name == "author_56_subproof") {
subproof_203(args, ret, err);
}
if (name == "author_57_negation_subproof") {
subproof_204(args, ret, err);
}
if (name == "author_57_subproof") {
subproof_205(args, ret, err);
}
if (name == "author_58_negation_subproof") {
subproof_206(args, ret, err);
}
if (name == "author_58_subproof") {
subproof_207(args, ret, err);
}
if (name == "author_59_negation_subproof") {
subproof_208(args, ret, err);
}
if (name == "author_59_subproof") {
subproof_209(args, ret, err);
}
if (name == "author_5_negation_subproof") {
subproof_210(args, ret, err);
}
if (name == "author_5_subproof") {
subproof_211(args, ret, err);
}
if (name == "author_60_negation_subproof") {
subproof_212(args, ret, err);
}
if (name == "author_60_subproof") {
subproof_213(args, ret, err);
}
if (name == "author_61_negation_subproof") {
subproof_214(args, ret, err);
}
if (name == "author_61_subproof") {
subproof_215(args, ret, err);
}
if (name == "author_62_negation_subproof") {
subproof_216(args, ret, err);
}
if (name == "author_62_subproof") {
subproof_217(args, ret, err);
}
if (name == "author_63_negation_subproof") {
subproof_218(args, ret, err);
}
if (name == "author_63_subproof") {
subproof_219(args, ret, err);
}
if (name == "author_64_negation_subproof") {
subproof_220(args, ret, err);
}
if (name == "author_64_subproof") {
subproof_221(args, ret, err);
}
if (name == "author_65_negation_subproof") {
subproof_222(args, ret, err);
}
if (name == "author_65_subproof") {
subproof_223(args, ret, err);
}
if (name == "author_66_negation_subproof") {
subproof_224(args, ret, err);
}
if (name == "author_66_subproof") {
subproof_225(args, ret, err);
}
if (name == "author_67_negation_subproof") {
subproof_226(args, ret, err);
}
if (name == "author_67_subproof") {
subproof_227(args, ret, err);
}
if (name == "author_68_negation_subproof") {
subproof_228(args, ret, err);
}
if (name == "author_68_subproof") {
subproof_229(args, ret, err);
}
if (name == "author_69_negation_subproof") {
subproof_230(args, ret, err);
}
if (name == "author_69_subproof") {
subproof_231(args, ret, err);
}
if (name == "author_6_negation_subproof") {
subproof_232(args, ret, err);
}
if (name == "author_6_subproof") {
subproof_233(args, ret, err);
}
if (name == "author_70_negation_subproof") {
subproof_234(args, ret, err);
}
if (name == "author_70_subproof") {
subproof_235(args, ret, err);
}
if (name == "author_71_negation_subproof") {
subproof_236(args, ret, err);
}
if (name == "author_71_subproof") {
subproof_237(args, ret, err);
}
if (name == "author_72_negation_subproof") {
subproof_238(args, ret, err);
}
if (name == "author_72_subproof") {
subproof_239(args, ret, err);
}
if (name == "author_73_negation_subproof") {
subproof_240(args, ret, err);
}
if (name == "author_73_subproof") {
subproof_241(args, ret, err);
}
if (name == "author_74_negation_subproof") {
subproof_242(args, ret, err);
}
if (name == "author_74_subproof") {
subproof_243(args, ret, err);
}
if (name == "author_75_negation_subproof") {
subproof_244(args, ret, err);
}
if (name == "author_75_subproof") {
subproof_245(args, ret, err);
}
if (name == "author_76_negation_subproof") {
subproof_246(args, ret, err);
}
if (name == "author_76_subproof") {
subproof_247(args, ret, err);
}
if (name == "author_77_negation_subproof") {
subproof_248(args, ret, err);
}
if (name == "author_77_subproof") {
subproof_249(args, ret, err);
}
if (name == "author_78_negation_subproof") {
subproof_250(args, ret, err);
}
if (name == "author_78_subproof") {
subproof_251(args, ret, err);
}
if (name == "author_79_negation_subproof") {
subproof_252(args, ret, err);
}
if (name == "author_79_subproof") {
subproof_253(args, ret, err);
}
if (name == "author_7_negation_subproof") {
subproof_254(args, ret, err);
}
if (name == "author_7_subproof") {
subproof_255(args, ret, err);
}
if (name == "author_80_negation_subproof") {
subproof_256(args, ret, err);
}
if (name == "author_80_subproof") {
subproof_257(args, ret, err);
}
if (name == "author_81_negation_subproof") {
subproof_258(args, ret, err);
}
if (name == "author_81_subproof") {
subproof_259(args, ret, err);
}
if (name == "author_82_negation_subproof") {
subproof_260(args, ret, err);
}
if (name == "author_82_subproof") {
subproof_261(args, ret, err);
}
if (name == "author_83_negation_subproof") {
subproof_262(args, ret, err);
}
if (name == "author_83_subproof") {
subproof_263(args, ret, err);
}
if (name == "author_84_negation_subproof") {
subproof_264(args, ret, err);
}
if (name == "author_84_subproof") {
subproof_265(args, ret, err);
}
if (name == "author_85_negation_subproof") {
subproof_266(args, ret, err);
}
if (name == "author_85_subproof") {
subproof_267(args, ret, err);
}
if (name == "author_86_negation_subproof") {
subproof_268(args, ret, err);
}
if (name == "author_86_subproof") {
subproof_269(args, ret, err);
}
if (name == "author_87_negation_subproof") {
subproof_270(args, ret, err);
}
if (name == "author_87_subproof") {
subproof_271(args, ret, err);
}
if (name == "author_88_negation_subproof") {
subproof_272(args, ret, err);
}
if (name == "author_88_subproof") {
subproof_273(args, ret, err);
}
if (name == "author_89_negation_subproof") {
subproof_274(args, ret, err);
}
if (name == "author_89_subproof") {
subproof_275(args, ret, err);
}
if (name == "author_8_negation_subproof") {
subproof_276(args, ret, err);
}
if (name == "author_8_subproof") {
subproof_277(args, ret, err);
}
if (name == "author_90_negation_subproof") {
subproof_278(args, ret, err);
}
if (name == "author_90_subproof") {
subproof_279(args, ret, err);
}
if (name == "author_91_negation_subproof") {
subproof_280(args, ret, err);
}
if (name == "author_91_subproof") {
subproof_281(args, ret, err);
}
if (name == "author_92_negation_subproof") {
subproof_282(args, ret, err);
}
if (name == "author_92_subproof") {
subproof_283(args, ret, err);
}
if (name == "author_93_negation_subproof") {
subproof_284(args, ret, err);
}
if (name == "author_93_subproof") {
subproof_285(args, ret, err);
}
if (name == "author_94_negation_subproof") {
subproof_286(args, ret, err);
}
if (name == "author_94_subproof") {
subproof_287(args, ret, err);
}
if (name == "author_95_negation_subproof") {
subproof_288(args, ret, err);
}
if (name == "author_95_subproof") {
subproof_289(args, ret, err);
}
if (name == "author_96_negation_subproof") {
subproof_290(args, ret, err);
}
if (name == "author_96_subproof") {
subproof_291(args, ret, err);
}
if (name == "author_97_negation_subproof") {
subproof_292(args, ret, err);
}
if (name == "author_97_subproof") {
subproof_293(args, ret, err);
}
if (name == "author_98_negation_subproof") {
subproof_294(args, ret, err);
}
if (name == "author_98_subproof") {
subproof_295(args, ret, err);
}
if (name == "author_99_negation_subproof") {
subproof_296(args, ret, err);
}
if (name == "author_99_subproof") {
subproof_297(args, ret, err);
}
if (name == "author_9_negation_subproof") {
subproof_298(args, ret, err);
}
if (name == "author_9_subproof") {
subproof_299(args, ret, err);
}
if (name == "inv_0_10_negation_subproof") {
subproof_300(args, ret, err);
}
if (name == "inv_0_10_subproof") {
subproof_301(args, ret, err);
}
if (name == "inv_0_11_negation_subproof") {
subproof_302(args, ret, err);
}
if (name == "inv_0_11_subproof") {
subproof_303(args, ret, err);
}
if (name == "inv_0_12_negation_subproof") {
subproof_304(args, ret, err);
}
if (name == "inv_0_12_subproof") {
subproof_305(args, ret, err);
}
if (name == "inv_0_13_negation_subproof") {
subproof_306(args, ret, err);
}
if (name == "inv_0_13_subproof") {
subproof_307(args, ret, err);
}
if (name == "inv_0_14_negation_subproof") {
subproof_308(args, ret, err);
}
if (name == "inv_0_14_subproof") {
subproof_309(args, ret, err);
}
if (name == "inv_0_15_negation_subproof") {
subproof_310(args, ret, err);
}
if (name == "inv_0_15_subproof") {
subproof_311(args, ret, err);
}
if (name == "inv_0_16_negation_subproof") {
subproof_312(args, ret, err);
}
if (name == "inv_0_16_subproof") {
subproof_313(args, ret, err);
}
if (name == "inv_0_17_negation_subproof") {
subproof_314(args, ret, err);
}
if (name == "inv_0_17_subproof") {
subproof_315(args, ret, err);
}
if (name == "inv_0_18_negation_subproof") {
subproof_316(args, ret, err);
}
if (name == "inv_0_18_subproof") {
subproof_317(args, ret, err);
}
if (name == "inv_0_19_negation_subproof") {
subproof_318(args, ret, err);
}
if (name == "inv_0_19_subproof") {
subproof_319(args, ret, err);
}
if (name == "inv_0_1_negation_subproof") {
subproof_320(args, ret, err);
}
if (name == "inv_0_1_subproof") {
subproof_321(args, ret, err);
}
if (name == "inv_0_20_negation_subproof") {
subproof_322(args, ret, err);
}
if (name == "inv_0_20_subproof") {
subproof_323(args, ret, err);
}
if (name == "inv_0_21_negation_subproof") {
subproof_324(args, ret, err);
}
if (name == "inv_0_21_subproof") {
subproof_325(args, ret, err);
}
if (name == "inv_0_22_negation_subproof") {
subproof_326(args, ret, err);
}
if (name == "inv_0_22_subproof") {
subproof_327(args, ret, err);
}
if (name == "inv_0_23_negation_subproof") {
subproof_328(args, ret, err);
}
if (name == "inv_0_23_subproof") {
subproof_329(args, ret, err);
}
if (name == "inv_0_24_negation_subproof") {
subproof_330(args, ret, err);
}
if (name == "inv_0_24_subproof") {
subproof_331(args, ret, err);
}
if (name == "inv_0_25_negation_subproof") {
subproof_332(args, ret, err);
}
if (name == "inv_0_25_subproof") {
subproof_333(args, ret, err);
}
if (name == "inv_0_26_negation_subproof") {
subproof_334(args, ret, err);
}
if (name == "inv_0_26_subproof") {
subproof_335(args, ret, err);
}
if (name == "inv_0_27_negation_subproof") {
subproof_336(args, ret, err);
}
if (name == "inv_0_27_subproof") {
subproof_337(args, ret, err);
}
if (name == "inv_0_28_negation_subproof") {
subproof_338(args, ret, err);
}
if (name == "inv_0_28_subproof") {
subproof_339(args, ret, err);
}
if (name == "inv_0_29_negation_subproof") {
subproof_340(args, ret, err);
}
if (name == "inv_0_29_subproof") {
subproof_341(args, ret, err);
}
if (name == "inv_0_2_negation_subproof") {
subproof_342(args, ret, err);
}
if (name == "inv_0_2_subproof") {
subproof_343(args, ret, err);
}
if (name == "inv_0_30_negation_subproof") {
subproof_344(args, ret, err);
}
if (name == "inv_0_30_subproof") {
subproof_345(args, ret, err);
}
if (name == "inv_0_31_negation_subproof") {
subproof_346(args, ret, err);
}
if (name == "inv_0_31_subproof") {
subproof_347(args, ret, err);
}
if (name == "inv_0_32_negation_subproof") {
subproof_348(args, ret, err);
}
if (name == "inv_0_32_subproof") {
subproof_349(args, ret, err);
}
if (name == "inv_0_33_negation_subproof") {
subproof_350(args, ret, err);
}
if (name == "inv_0_33_subproof") {
subproof_351(args, ret, err);
}
if (name == "inv_0_34_negation_subproof") {
subproof_352(args, ret, err);
}
if (name == "inv_0_34_subproof") {
subproof_353(args, ret, err);
}
if (name == "inv_0_35_negation_subproof") {
subproof_354(args, ret, err);
}
if (name == "inv_0_35_subproof") {
subproof_355(args, ret, err);
}
if (name == "inv_0_36_negation_subproof") {
subproof_356(args, ret, err);
}
if (name == "inv_0_36_subproof") {
subproof_357(args, ret, err);
}
if (name == "inv_0_37_negation_subproof") {
subproof_358(args, ret, err);
}
if (name == "inv_0_37_subproof") {
subproof_359(args, ret, err);
}
if (name == "inv_0_38_negation_subproof") {
subproof_360(args, ret, err);
}
if (name == "inv_0_38_subproof") {
subproof_361(args, ret, err);
}
if (name == "inv_0_39_negation_subproof") {
subproof_362(args, ret, err);
}
if (name == "inv_0_39_subproof") {
subproof_363(args, ret, err);
}
if (name == "inv_0_3_negation_subproof") {
subproof_364(args, ret, err);
}
if (name == "inv_0_3_subproof") {
subproof_365(args, ret, err);
}
if (name == "inv_0_40_negation_subproof") {
subproof_366(args, ret, err);
}
if (name == "inv_0_40_subproof") {
subproof_367(args, ret, err);
}
if (name == "inv_0_41_negation_subproof") {
subproof_368(args, ret, err);
}
if (name == "inv_0_41_subproof") {
subproof_369(args, ret, err);
}
if (name == "inv_0_42_negation_subproof") {
subproof_370(args, ret, err);
}
if (name == "inv_0_42_subproof") {
subproof_371(args, ret, err);
}
if (name == "inv_0_43_negation_subproof") {
subproof_372(args, ret, err);
}
if (name == "inv_0_43_subproof") {
subproof_373(args, ret, err);
}
if (name == "inv_0_44_negation_subproof") {
subproof_374(args, ret, err);
}
if (name == "inv_0_44_subproof") {
subproof_375(args, ret, err);
}
if (name == "inv_0_45_negation_subproof") {
subproof_376(args, ret, err);
}
if (name == "inv_0_45_subproof") {
subproof_377(args, ret, err);
}
if (name == "inv_0_46_negation_subproof") {
subproof_378(args, ret, err);
}
if (name == "inv_0_46_subproof") {
subproof_379(args, ret, err);
}
if (name == "inv_0_47_negation_subproof") {
subproof_380(args, ret, err);
}
if (name == "inv_0_47_subproof") {
subproof_381(args, ret, err);
}
if (name == "inv_0_48_negation_subproof") {
subproof_382(args, ret, err);
}
if (name == "inv_0_48_subproof") {
subproof_383(args, ret, err);
}
if (name == "inv_0_49_negation_subproof") {
subproof_384(args, ret, err);
}
if (name == "inv_0_49_subproof") {
subproof_385(args, ret, err);
}
if (name == "inv_0_4_negation_subproof") {
subproof_386(args, ret, err);
}
if (name == "inv_0_4_subproof") {
subproof_387(args, ret, err);
}
if (name == "inv_0_50_negation_subproof") {
subproof_388(args, ret, err);
}
if (name == "inv_0_50_subproof") {
subproof_389(args, ret, err);
}
if (name == "inv_0_51_negation_subproof") {
subproof_390(args, ret, err);
}
if (name == "inv_0_51_subproof") {
subproof_391(args, ret, err);
}
if (name == "inv_0_52_negation_subproof") {
subproof_392(args, ret, err);
}
if (name == "inv_0_52_subproof") {
subproof_393(args, ret, err);
}
if (name == "inv_0_53_negation_subproof") {
subproof_394(args, ret, err);
}
if (name == "inv_0_53_subproof") {
subproof_395(args, ret, err);
}
if (name == "inv_0_54_negation_subproof") {
subproof_396(args, ret, err);
}
if (name == "inv_0_54_subproof") {
subproof_397(args, ret, err);
}
if (name == "inv_0_55_negation_subproof") {
subproof_398(args, ret, err);
}
if (name == "inv_0_55_subproof") {
subproof_399(args, ret, err);
}
if (name == "inv_0_56_negation_subproof") {
subproof_400(args, ret, err);
}
if (name == "inv_0_56_subproof") {
subproof_401(args, ret, err);
}
if (name == "inv_0_57_negation_subproof") {
subproof_402(args, ret, err);
}
if (name == "inv_0_57_subproof") {
subproof_403(args, ret, err);
}
if (name == "inv_0_58_negation_subproof") {
subproof_404(args, ret, err);
}
if (name == "inv_0_58_subproof") {
subproof_405(args, ret, err);
}
if (name == "inv_0_59_negation_subproof") {
subproof_406(args, ret, err);
}
if (name == "inv_0_59_subproof") {
subproof_407(args, ret, err);
}
if (name == "inv_0_5_negation_subproof") {
subproof_408(args, ret, err);
}
if (name == "inv_0_5_subproof") {
subproof_409(args, ret, err);
}
if (name == "inv_0_60_negation_subproof") {
subproof_410(args, ret, err);
}
if (name == "inv_0_60_subproof") {
subproof_411(args, ret, err);
}
if (name == "inv_0_61_negation_subproof") {
subproof_412(args, ret, err);
}
if (name == "inv_0_61_subproof") {
subproof_413(args, ret, err);
}
if (name == "inv_0_62_negation_subproof") {
subproof_414(args, ret, err);
}
if (name == "inv_0_62_subproof") {
subproof_415(args, ret, err);
}
if (name == "inv_0_63_negation_subproof") {
subproof_416(args, ret, err);
}
if (name == "inv_0_63_subproof") {
subproof_417(args, ret, err);
}
if (name == "inv_0_64_negation_subproof") {
subproof_418(args, ret, err);
}
if (name == "inv_0_64_subproof") {
subproof_419(args, ret, err);
}
if (name == "inv_0_65_negation_subproof") {
subproof_420(args, ret, err);
}
if (name == "inv_0_65_subproof") {
subproof_421(args, ret, err);
}
if (name == "inv_0_66_negation_subproof") {
subproof_422(args, ret, err);
}
if (name == "inv_0_66_subproof") {
subproof_423(args, ret, err);
}
if (name == "inv_0_67_negation_subproof") {
subproof_424(args, ret, err);
}
if (name == "inv_0_67_subproof") {
subproof_425(args, ret, err);
}
if (name == "inv_0_68_negation_subproof") {
subproof_426(args, ret, err);
}
if (name == "inv_0_68_subproof") {
subproof_427(args, ret, err);
}
if (name == "inv_0_69_negation_subproof") {
subproof_428(args, ret, err);
}
if (name == "inv_0_69_subproof") {
subproof_429(args, ret, err);
}
if (name == "inv_0_6_negation_subproof") {
subproof_430(args, ret, err);
}
if (name == "inv_0_6_subproof") {
subproof_431(args, ret, err);
}
if (name == "inv_0_70_negation_subproof") {
subproof_432(args, ret, err);
}
if (name == "inv_0_70_subproof") {
subproof_433(args, ret, err);
}
if (name == "inv_0_7_negation_subproof") {
subproof_434(args, ret, err);
}
if (name == "inv_0_7_subproof") {
subproof_435(args, ret, err);
}
if (name == "inv_0_8_negation_subproof") {
subproof_436(args, ret, err);
}
if (name == "inv_0_8_subproof") {
subproof_437(args, ret, err);
}
if (name == "inv_0_9_negation_subproof") {
subproof_438(args, ret, err);
}
if (name == "inv_0_9_subproof") {
subproof_439(args, ret, err);
}
}
void subproof_0(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(242),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(242));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
if(!rel_8_author->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_1(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_8_author->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(242),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],0,0,0}});
auto range = rel_3_genre->equalRange_1(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],env1[1],0,0}});
auto range = rel_8_author->equalRange_3(key,READ_OP_CONTEXT(rel_8_author_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(242));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_2(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(243),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(243));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
if(!rel_8_author->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();return;
}
void subproof_3(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_8_author->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(243),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],0,0,0}});
auto range = rel_3_genre->equalRange_1(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[1],(args)[1],0,0}});
auto range = rel_8_author->equalRange_3(key,READ_OP_CONTEXT(rel_8_author_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(243));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_4(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(244),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(244));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
if(!rel_8_author->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_5(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_8_author->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(244),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[1],0,0}});
auto range = rel_3_genre->equalRange_2(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[0],(args)[0],0,0}});
auto range = rel_8_author->equalRange_3(key,READ_OP_CONTEXT(rel_8_author_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(244));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_6(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(245),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(245));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
if(!rel_8_author->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_7(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_8_author->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(245),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],0,0,0}});
auto range = rel_3_genre->equalRange_1(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],env1[1],0,0}});
auto range = rel_8_author->equalRange_3(key,READ_OP_CONTEXT(rel_8_author_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(245));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_8(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(250),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(250));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
if(!rel_1_Iauthor->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
if(!rel_1_Iauthor->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_9(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_1_Iauthor->empty()) && !(rel_1_Iauthor->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(250),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[1],0,0}});
auto range = rel_1_Iauthor->equalRange_2(key,READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],env1[0],0,0}});
auto range = rel_1_Iauthor->equalRange_3(key,READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(250));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_10(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(251),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(251));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
if(!rel_1_Iauthor->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
if(!rel_1_Iauthor->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_11(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_1_Iauthor->empty()) && !(rel_1_Iauthor->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(251),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],0,0,0}});
auto range = rel_1_Iauthor->equalRange_1(key,READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[1],(args)[0],0,0}});
auto range = rel_1_Iauthor->equalRange_3(key,READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(251));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_12(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(252),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(252));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
if(!rel_1_Iauthor->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
if(!rel_1_Iauthor->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_13(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_1_Iauthor->empty()) && !(rel_1_Iauthor->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(252),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[0],0,0}});
auto range = rel_1_Iauthor->equalRange_2(key,READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],env1[0],0,0}});
auto range = rel_1_Iauthor->equalRange_3(key,READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(252));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_14(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(253),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(253));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
if(!rel_1_Iauthor->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
if(!rel_1_Iauthor->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();return;
}
void subproof_15(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_1_Iauthor->empty()) && !(rel_1_Iauthor->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(253),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[0],0,0}});
auto range = rel_1_Iauthor->equalRange_2(key,READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[0],(args)[1],0,0}});
auto range = rel_1_Iauthor->equalRange_3(key,READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(253));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_16(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(254),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(254));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
if(!rel_1_Iauthor->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
if(!rel_1_Iauthor->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_17(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_1_Iauthor->empty()) && !(rel_1_Iauthor->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(254),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],0,0,0}});
auto range = rel_1_Iauthor->equalRange_1(key,READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],env1[1],0,0}});
auto range = rel_1_Iauthor->equalRange_3(key,READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(254));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_18(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(255),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(255));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
if(!rel_1_Iauthor->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
if(!rel_1_Iauthor->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();return;
}
void subproof_19(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_1_Iauthor->empty()) && !(rel_1_Iauthor->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(255),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],0,0,0}});
auto range = rel_1_Iauthor->equalRange_1(key,READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[1],(args)[1],0,0}});
auto range = rel_1_Iauthor->equalRange_3(key,READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(255));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_20(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(140),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(140));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[0],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_21(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(140),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],(args)[0],0,0}});
auto range = rel_4_precededBy->equalRange_3(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(140));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_22(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(256),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(256));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
if(!rel_1_Iauthor->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
if(!rel_1_Iauthor->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_23(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_1_Iauthor->empty()) && !(rel_1_Iauthor->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(256),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[1],0,0}});
auto range = rel_1_Iauthor->equalRange_2(key,READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[0],(args)[0],0,0}});
auto range = rel_1_Iauthor->equalRange_3(key,READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(256));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_24(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(257),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(257));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
if(!rel_1_Iauthor->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
if(!rel_1_Iauthor->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_25(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_1_Iauthor->empty()) && !(rel_1_Iauthor->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(257),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],0,0,0}});
auto range = rel_1_Iauthor->equalRange_1(key,READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],env1[1],0,0}});
auto range = rel_1_Iauthor->equalRange_3(key,READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(257));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_26(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(274),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(274));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
if(!rel_1_Iauthor->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
if(!rel_8_author->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_27(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_8_author->empty()) && !(rel_1_Iauthor->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(274),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[1],0,0}});
auto range = rel_1_Iauthor->equalRange_2(key,READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],env1[0],0,0}});
auto range = rel_8_author->equalRange_3(key,READ_OP_CONTEXT(rel_8_author_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(274));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_28(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(275),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(275));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
if(!rel_1_Iauthor->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
if(!rel_8_author->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_29(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_8_author->empty()) && !(rel_1_Iauthor->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(275),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],0,0,0}});
auto range = rel_1_Iauthor->equalRange_1(key,READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[1],(args)[0],0,0}});
auto range = rel_8_author->equalRange_3(key,READ_OP_CONTEXT(rel_8_author_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(275));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_30(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(276),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(276));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
if(!rel_1_Iauthor->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
if(!rel_8_author->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_31(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_8_author->empty()) && !(rel_1_Iauthor->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(276),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[0],0,0}});
auto range = rel_1_Iauthor->equalRange_2(key,READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],env1[0],0,0}});
auto range = rel_8_author->equalRange_3(key,READ_OP_CONTEXT(rel_8_author_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(276));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_32(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(277),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(277));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
if(!rel_1_Iauthor->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
if(!rel_8_author->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();return;
}
void subproof_33(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_8_author->empty()) && !(rel_1_Iauthor->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(277),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[0],0,0}});
auto range = rel_1_Iauthor->equalRange_2(key,READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[0],(args)[1],0,0}});
auto range = rel_8_author->equalRange_3(key,READ_OP_CONTEXT(rel_8_author_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(277));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_34(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(278),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(278));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
if(!rel_1_Iauthor->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
if(!rel_8_author->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_35(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_8_author->empty()) && !(rel_1_Iauthor->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(278),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],0,0,0}});
auto range = rel_1_Iauthor->equalRange_1(key,READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],env1[1],0,0}});
auto range = rel_8_author->equalRange_3(key,READ_OP_CONTEXT(rel_8_author_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(278));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_36(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(279),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(279));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
if(!rel_1_Iauthor->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
if(!rel_8_author->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();return;
}
void subproof_37(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_8_author->empty()) && !(rel_1_Iauthor->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(279),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],0,0,0}});
auto range = rel_1_Iauthor->equalRange_1(key,READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[1],(args)[1],0,0}});
auto range = rel_8_author->equalRange_3(key,READ_OP_CONTEXT(rel_8_author_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(279));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_38(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(280),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(280));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
if(!rel_1_Iauthor->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
if(!rel_8_author->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_39(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_8_author->empty()) && !(rel_1_Iauthor->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(280),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[1],0,0}});
auto range = rel_1_Iauthor->equalRange_2(key,READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[0],(args)[0],0,0}});
auto range = rel_8_author->equalRange_3(key,READ_OP_CONTEXT(rel_8_author_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(280));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_40(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(281),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(281));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
if(!rel_1_Iauthor->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
if(!rel_8_author->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_41(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_8_author->empty()) && !(rel_1_Iauthor->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(281),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],0,0,0}});
auto range = rel_1_Iauthor->equalRange_1(key,READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],env1[1],0,0}});
auto range = rel_8_author->equalRange_3(key,READ_OP_CONTEXT(rel_8_author_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(281));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_42(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(141),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(141));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[0],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[1],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();return;
}
void subproof_43(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_4_precededBy->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(141),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],(args)[0],0,0}});
auto range = rel_4_precededBy->equalRange_3(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[1],env1[0],0,0}});
auto range = rel_4_precededBy->equalRange_3(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(141));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_44(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(282),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(282));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[1],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();return;
}
void subproof_45(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_5_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(282),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],(args)[1],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(282));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_46(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(283),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(283));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[1],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[0],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_47(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_5_inv_0->empty()) && !(rel_5_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(283),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],(args)[1],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[1],env1[0],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(283));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_48(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(284),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(284));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[0],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_49(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_5_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(284),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],(args)[0],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(284));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_50(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(285),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(285));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[0],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[1],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();return;
}
void subproof_51(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_5_inv_0->empty()) && !(rel_5_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(285),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],(args)[0],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[1],env1[0],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(285));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_52(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(286),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(286));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_53(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_5_inv_0->empty()) && !(rel_5_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(286),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[1],0,0}});
auto range = rel_5_inv_0->equalRange_2(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],env1[0],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(286));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_54(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(287),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(287));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_55(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_5_inv_0->empty()) && !(rel_5_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(287),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],0,0,0}});
auto range = rel_5_inv_0->equalRange_1(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[1],(args)[0],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(287));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_56(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(288),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(288));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_57(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_5_inv_0->empty()) && !(rel_5_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(288),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[0],0,0}});
auto range = rel_5_inv_0->equalRange_2(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],env1[0],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(288));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_58(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(289),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(289));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();return;
}
void subproof_59(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_5_inv_0->empty()) && !(rel_5_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(289),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[0],0,0}});
auto range = rel_5_inv_0->equalRange_2(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[0],(args)[1],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(289));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_60(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(290),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(290));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_61(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_5_inv_0->empty()) && !(rel_5_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(290),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],0,0,0}});
auto range = rel_5_inv_0->equalRange_1(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],env1[1],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(290));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_62(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(291),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(291));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();return;
}
void subproof_63(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_5_inv_0->empty()) && !(rel_5_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(291),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],0,0,0}});
auto range = rel_5_inv_0->equalRange_1(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[1],(args)[1],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(291));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_64(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(142),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(142));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_65(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_4_precededBy->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(142),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[1],0,0}});
auto range = rel_4_precededBy->equalRange_2(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],env1[0],0,0}});
auto range = rel_4_precededBy->equalRange_3(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(142));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_66(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(292),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(292));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_67(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_5_inv_0->empty()) && !(rel_5_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(292),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[1],0,0}});
auto range = rel_5_inv_0->equalRange_2(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[0],(args)[0],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(292));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_68(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(293),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(293));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_69(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_5_inv_0->empty()) && !(rel_5_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(293),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],0,0,0}});
auto range = rel_5_inv_0->equalRange_1(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],env1[1],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(293));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_70(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(295),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(295));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[1],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
if(!rel_8_author->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[0],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_71(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_8_author->empty()) && !(rel_5_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(295),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],(args)[1],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[1],env1[0],0,0}});
auto range = rel_8_author->equalRange_3(key,READ_OP_CONTEXT(rel_8_author_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(295));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_72(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(296),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(296));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[0],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
if(!rel_8_author->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[0],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_73(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_8_author->empty()) && !(rel_5_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(296),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],(args)[0],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[0],env1[1],0,0}});
auto range = rel_8_author->equalRange_3(key,READ_OP_CONTEXT(rel_8_author_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(296));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_74(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(298),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(298));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
if(!rel_8_author->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_75(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_8_author->empty()) && !(rel_5_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(298),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[1],0,0}});
auto range = rel_5_inv_0->equalRange_2(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],env1[0],0,0}});
auto range = rel_8_author->equalRange_3(key,READ_OP_CONTEXT(rel_8_author_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(298));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_76(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(299),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(299));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
if(!rel_8_author->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_77(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_8_author->empty()) && !(rel_5_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(299),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],0,0,0}});
auto range = rel_5_inv_0->equalRange_1(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[1],(args)[0],0,0}});
auto range = rel_8_author->equalRange_3(key,READ_OP_CONTEXT(rel_8_author_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(299));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_78(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(300),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(300));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
if(!rel_8_author->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_79(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_8_author->empty()) && !(rel_5_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(300),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[0],0,0}});
auto range = rel_5_inv_0->equalRange_2(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],env1[0],0,0}});
auto range = rel_8_author->equalRange_3(key,READ_OP_CONTEXT(rel_8_author_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(300));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_80(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(301),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(301));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
if(!rel_8_author->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();return;
}
void subproof_81(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_8_author->empty()) && !(rel_5_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(301),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[0],0,0}});
auto range = rel_5_inv_0->equalRange_2(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[0],(args)[1],0,0}});
auto range = rel_8_author->equalRange_3(key,READ_OP_CONTEXT(rel_8_author_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(301));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_82(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(302),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(302));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
if(!rel_8_author->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_83(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_8_author->empty()) && !(rel_5_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(302),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],0,0,0}});
auto range = rel_5_inv_0->equalRange_1(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],env1[1],0,0}});
auto range = rel_8_author->equalRange_3(key,READ_OP_CONTEXT(rel_8_author_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(302));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_84(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(303),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(303));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
if(!rel_8_author->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();return;
}
void subproof_85(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_8_author->empty()) && !(rel_5_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(303),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],0,0,0}});
auto range = rel_5_inv_0->equalRange_1(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[1],(args)[1],0,0}});
auto range = rel_8_author->equalRange_3(key,READ_OP_CONTEXT(rel_8_author_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(303));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_86(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(143),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(143));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_87(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_4_precededBy->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(143),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],0,0,0}});
auto range = rel_4_precededBy->equalRange_1(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[1],(args)[0],0,0}});
auto range = rel_4_precededBy->equalRange_3(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(143));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_88(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(304),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(304));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
if(!rel_8_author->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_89(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_8_author->empty()) && !(rel_5_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(304),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[1],0,0}});
auto range = rel_5_inv_0->equalRange_2(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[0],(args)[0],0,0}});
auto range = rel_8_author->equalRange_3(key,READ_OP_CONTEXT(rel_8_author_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(304));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_90(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(305),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(305));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
if(!rel_8_author->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_91(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_8_author->empty()) && !(rel_5_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(305),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],0,0,0}});
auto range = rel_5_inv_0->equalRange_1(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],env1[1],0,0}});
auto range = rel_8_author->equalRange_3(key,READ_OP_CONTEXT(rel_8_author_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(305));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_92(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(308),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(308));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
if(!rel_8_author->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[0],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_93(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_8_author->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(308),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],(args)[0],0,0}});
auto range = rel_8_author->equalRange_3(key,READ_OP_CONTEXT(rel_8_author_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(308));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_94(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(310),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(310));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
if(!rel_8_author->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
if(!rel_8_author->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_95(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_8_author->empty()) && !(rel_8_author->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(310),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[1],0,0}});
auto range = rel_8_author->equalRange_2(key,READ_OP_CONTEXT(rel_8_author_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],env1[0],0,0}});
auto range = rel_8_author->equalRange_3(key,READ_OP_CONTEXT(rel_8_author_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(310));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_96(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(311),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(311));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
if(!rel_8_author->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
if(!rel_8_author->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_97(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_8_author->empty()) && !(rel_8_author->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(311),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],0,0,0}});
auto range = rel_8_author->equalRange_1(key,READ_OP_CONTEXT(rel_8_author_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[1],(args)[0],0,0}});
auto range = rel_8_author->equalRange_3(key,READ_OP_CONTEXT(rel_8_author_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(311));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_98(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(312),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(312));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
if(!rel_8_author->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
if(!rel_8_author->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_99(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_8_author->empty()) && !(rel_8_author->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(312),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[0],0,0}});
auto range = rel_8_author->equalRange_2(key,READ_OP_CONTEXT(rel_8_author_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],env1[0],0,0}});
auto range = rel_8_author->equalRange_3(key,READ_OP_CONTEXT(rel_8_author_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(312));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_100(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(313),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(313));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
if(!rel_8_author->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
if(!rel_8_author->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();return;
}
void subproof_101(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_8_author->empty()) && !(rel_8_author->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(313),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[0],0,0}});
auto range = rel_8_author->equalRange_2(key,READ_OP_CONTEXT(rel_8_author_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[0],(args)[1],0,0}});
auto range = rel_8_author->equalRange_3(key,READ_OP_CONTEXT(rel_8_author_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(313));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_102(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(314),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(314));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
if(!rel_8_author->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
if(!rel_8_author->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_103(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_8_author->empty()) && !(rel_8_author->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(314),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],0,0,0}});
auto range = rel_8_author->equalRange_1(key,READ_OP_CONTEXT(rel_8_author_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],env1[1],0,0}});
auto range = rel_8_author->equalRange_3(key,READ_OP_CONTEXT(rel_8_author_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(314));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_104(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(315),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(315));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
if(!rel_8_author->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
if(!rel_8_author->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();return;
}
void subproof_105(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_8_author->empty()) && !(rel_8_author->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(315),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],0,0,0}});
auto range = rel_8_author->equalRange_1(key,READ_OP_CONTEXT(rel_8_author_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[1],(args)[1],0,0}});
auto range = rel_8_author->equalRange_3(key,READ_OP_CONTEXT(rel_8_author_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(315));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_106(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(316),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(316));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
if(!rel_8_author->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
if(!rel_8_author->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_107(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_8_author->empty()) && !(rel_8_author->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(316),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[1],0,0}});
auto range = rel_8_author->equalRange_2(key,READ_OP_CONTEXT(rel_8_author_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[0],(args)[0],0,0}});
auto range = rel_8_author->equalRange_3(key,READ_OP_CONTEXT(rel_8_author_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(316));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_108(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(144),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(144));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_109(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_4_precededBy->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(144),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[0],0,0}});
auto range = rel_4_precededBy->equalRange_2(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],env1[0],0,0}});
auto range = rel_4_precededBy->equalRange_3(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(144));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_110(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(317),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(317));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
if(!rel_8_author->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
if(!rel_8_author->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_111(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_8_author->empty()) && !(rel_8_author->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(317),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],0,0,0}});
auto range = rel_8_author->equalRange_1(key,READ_OP_CONTEXT(rel_8_author_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],env1[1],0,0}});
auto range = rel_8_author->equalRange_3(key,READ_OP_CONTEXT(rel_8_author_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(317));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_112(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(145),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(145));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();return;
}
void subproof_113(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_4_precededBy->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(145),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[0],0,0}});
auto range = rel_4_precededBy->equalRange_2(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[0],(args)[1],0,0}});
auto range = rel_4_precededBy->equalRange_3(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(145));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_114(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(146),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(146));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_115(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_4_precededBy->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(146),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],0,0,0}});
auto range = rel_4_precededBy->equalRange_1(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],env1[1],0,0}});
auto range = rel_4_precededBy->equalRange_3(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(146));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_116(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(147),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(147));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();return;
}
void subproof_117(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_4_precededBy->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(147),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],0,0,0}});
auto range = rel_4_precededBy->equalRange_1(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[1],(args)[1],0,0}});
auto range = rel_4_precededBy->equalRange_3(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(147));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_118(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(148),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(148));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_119(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_4_precededBy->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(148),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[1],0,0}});
auto range = rel_4_precededBy->equalRange_2(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[0],(args)[0],0,0}});
auto range = rel_4_precededBy->equalRange_3(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(148));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_120(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(149),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(149));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_121(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_4_precededBy->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(149),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],0,0,0}});
auto range = rel_4_precededBy->equalRange_1(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],env1[1],0,0}});
auto range = rel_4_precededBy->equalRange_3(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(149));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_122(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(128),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(128));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[1],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();return;
}
void subproof_123(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(128),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],(args)[1],0,0}});
auto range = rel_4_precededBy->equalRange_3(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(128));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_124(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(150),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(150));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[1],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[1],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();return;
}
void subproof_125(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_3_genre->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(150),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],(args)[1],0,0}});
auto range = rel_4_precededBy->equalRange_3(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[0],env1[1],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(150));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_126(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(151),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(151));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[1],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[0],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_127(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_3_genre->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(151),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],(args)[1],0,0}});
auto range = rel_4_precededBy->equalRange_3(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[1],env1[0],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(151));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_128(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(152),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(152));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[0],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[0],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_129(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_3_genre->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(152),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],(args)[0],0,0}});
auto range = rel_4_precededBy->equalRange_3(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[0],env1[1],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(152));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_130(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(153),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(153));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[0],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[1],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();return;
}
void subproof_131(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_3_genre->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(153),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],(args)[0],0,0}});
auto range = rel_4_precededBy->equalRange_3(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[1],env1[0],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(153));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_132(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(154),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(154));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_133(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_3_genre->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(154),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[1],0,0}});
auto range = rel_4_precededBy->equalRange_2(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],env1[0],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(154));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_134(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(155),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(155));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_135(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_3_genre->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(155),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],0,0,0}});
auto range = rel_4_precededBy->equalRange_1(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[1],(args)[0],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(155));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_136(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(156),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(156));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_137(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_3_genre->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(156),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[0],0,0}});
auto range = rel_4_precededBy->equalRange_2(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],env1[0],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(156));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_138(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(157),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(157));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();return;
}
void subproof_139(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_3_genre->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(157),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[0],0,0}});
auto range = rel_4_precededBy->equalRange_2(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[0],(args)[1],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(157));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_140(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(158),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(158));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_141(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_3_genre->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(158),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],0,0,0}});
auto range = rel_4_precededBy->equalRange_1(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],env1[1],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(158));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_142(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(159),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(159));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();return;
}
void subproof_143(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_3_genre->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(159),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],0,0,0}});
auto range = rel_4_precededBy->equalRange_1(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[1],(args)[1],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(159));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_144(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(129),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(129));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[0],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_145(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(129),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],(args)[0],0,0}});
auto range = rel_4_precededBy->equalRange_3(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(129));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_146(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(160),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(160));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_147(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_3_genre->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(160),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[1],0,0}});
auto range = rel_4_precededBy->equalRange_2(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[0],(args)[0],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(160));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_148(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(161),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(161));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_149(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_3_genre->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(161),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],0,0,0}});
auto range = rel_4_precededBy->equalRange_1(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],env1[1],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(161));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_150(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(166),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(166));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
if(!rel_1_Iauthor->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_151(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_1_Iauthor->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(166),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[1],0,0}});
auto range = rel_4_precededBy->equalRange_2(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],env1[0],0,0}});
auto range = rel_1_Iauthor->equalRange_3(key,READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(166));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_152(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(167),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(167));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
if(!rel_1_Iauthor->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_153(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_1_Iauthor->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(167),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],0,0,0}});
auto range = rel_4_precededBy->equalRange_1(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[1],(args)[0],0,0}});
auto range = rel_1_Iauthor->equalRange_3(key,READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(167));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_154(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(168),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(168));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
if(!rel_1_Iauthor->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_155(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_1_Iauthor->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(168),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[0],0,0}});
auto range = rel_4_precededBy->equalRange_2(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],env1[0],0,0}});
auto range = rel_1_Iauthor->equalRange_3(key,READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(168));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_156(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(169),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(169));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
if(!rel_1_Iauthor->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();return;
}
void subproof_157(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_1_Iauthor->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(169),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[0],0,0}});
auto range = rel_4_precededBy->equalRange_2(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[0],(args)[1],0,0}});
auto range = rel_1_Iauthor->equalRange_3(key,READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(169));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_158(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(170),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(170));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
if(!rel_1_Iauthor->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_159(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_1_Iauthor->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(170),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],0,0,0}});
auto range = rel_4_precededBy->equalRange_1(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],env1[1],0,0}});
auto range = rel_1_Iauthor->equalRange_3(key,READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(170));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_160(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(171),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(171));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
if(!rel_1_Iauthor->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();return;
}
void subproof_161(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_1_Iauthor->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(171),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],0,0,0}});
auto range = rel_4_precededBy->equalRange_1(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[1],(args)[1],0,0}});
auto range = rel_1_Iauthor->equalRange_3(key,READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(171));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_162(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(172),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(172));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
if(!rel_1_Iauthor->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_163(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_1_Iauthor->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(172),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[1],0,0}});
auto range = rel_4_precededBy->equalRange_2(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[0],(args)[0],0,0}});
auto range = rel_1_Iauthor->equalRange_3(key,READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(172));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_164(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(173),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(173));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
if(!rel_1_Iauthor->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_165(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_1_Iauthor->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(173),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],0,0,0}});
auto range = rel_4_precededBy->equalRange_1(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],env1[1],0,0}});
auto range = rel_1_Iauthor->equalRange_3(key,READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(173));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_166(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(130),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(130));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[1],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();return;
}
void subproof_167(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(130),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],(args)[1],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(130));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_168(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(174),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(174));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[1],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[1],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();return;
}
void subproof_169(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_5_inv_0->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(174),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],(args)[1],0,0}});
auto range = rel_4_precededBy->equalRange_3(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[0],env1[1],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(174));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_170(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(175),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(175));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[1],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[0],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_171(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_5_inv_0->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(175),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],(args)[1],0,0}});
auto range = rel_4_precededBy->equalRange_3(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[1],env1[0],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(175));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_172(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(176),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(176));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[0],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[0],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_173(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_5_inv_0->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(176),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],(args)[0],0,0}});
auto range = rel_4_precededBy->equalRange_3(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[0],env1[1],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(176));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_174(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(177),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(177));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[0],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[1],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();return;
}
void subproof_175(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_5_inv_0->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(177),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],(args)[0],0,0}});
auto range = rel_4_precededBy->equalRange_3(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[1],env1[0],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(177));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_176(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(178),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(178));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_177(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_5_inv_0->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(178),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[1],0,0}});
auto range = rel_4_precededBy->equalRange_2(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],env1[0],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(178));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_178(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(179),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(179));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_179(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_5_inv_0->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(179),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],0,0,0}});
auto range = rel_4_precededBy->equalRange_1(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[1],(args)[0],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(179));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_180(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(180),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(180));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_181(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_5_inv_0->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(180),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[0],0,0}});
auto range = rel_4_precededBy->equalRange_2(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],env1[0],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(180));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_182(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(181),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(181));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();return;
}
void subproof_183(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_5_inv_0->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(181),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[0],0,0}});
auto range = rel_4_precededBy->equalRange_2(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[0],(args)[1],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(181));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_184(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(182),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(182));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_185(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_5_inv_0->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(182),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],0,0,0}});
auto range = rel_4_precededBy->equalRange_1(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],env1[1],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(182));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_186(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(183),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(183));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();return;
}
void subproof_187(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_5_inv_0->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(183),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],0,0,0}});
auto range = rel_4_precededBy->equalRange_1(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[1],(args)[1],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(183));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_188(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(131),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(131));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[0],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_189(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(131),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],(args)[0],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(131));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_190(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(184),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(184));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_191(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_5_inv_0->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(184),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[1],0,0}});
auto range = rel_4_precededBy->equalRange_2(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[0],(args)[0],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(184));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_192(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(185),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(185));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_193(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_5_inv_0->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(185),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],0,0,0}});
auto range = rel_4_precededBy->equalRange_1(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],env1[1],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(185));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_194(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(187),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(187));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[1],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
if(!rel_8_author->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[0],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_195(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_8_author->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(187),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],(args)[1],0,0}});
auto range = rel_4_precededBy->equalRange_3(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[1],env1[0],0,0}});
auto range = rel_8_author->equalRange_3(key,READ_OP_CONTEXT(rel_8_author_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(187));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_196(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(188),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(188));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[0],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
if(!rel_8_author->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[0],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_197(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_8_author->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(188),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],(args)[0],0,0}});
auto range = rel_4_precededBy->equalRange_3(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[0],env1[1],0,0}});
auto range = rel_8_author->equalRange_3(key,READ_OP_CONTEXT(rel_8_author_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(188));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_198(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(190),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(190));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
if(!rel_8_author->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_199(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_8_author->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(190),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[1],0,0}});
auto range = rel_4_precededBy->equalRange_2(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],env1[0],0,0}});
auto range = rel_8_author->equalRange_3(key,READ_OP_CONTEXT(rel_8_author_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(190));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_200(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(191),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(191));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
if(!rel_8_author->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_201(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_8_author->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(191),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],0,0,0}});
auto range = rel_4_precededBy->equalRange_1(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[1],(args)[0],0,0}});
auto range = rel_8_author->equalRange_3(key,READ_OP_CONTEXT(rel_8_author_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(191));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_202(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(192),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(192));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
if(!rel_8_author->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_203(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_8_author->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(192),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[0],0,0}});
auto range = rel_4_precededBy->equalRange_2(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],env1[0],0,0}});
auto range = rel_8_author->equalRange_3(key,READ_OP_CONTEXT(rel_8_author_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(192));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_204(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(193),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(193));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
if(!rel_8_author->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();return;
}
void subproof_205(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_8_author->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(193),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[0],0,0}});
auto range = rel_4_precededBy->equalRange_2(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[0],(args)[1],0,0}});
auto range = rel_8_author->equalRange_3(key,READ_OP_CONTEXT(rel_8_author_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(193));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_206(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(194),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(194));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
if(!rel_8_author->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_207(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_8_author->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(194),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],0,0,0}});
auto range = rel_4_precededBy->equalRange_1(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],env1[1],0,0}});
auto range = rel_8_author->equalRange_3(key,READ_OP_CONTEXT(rel_8_author_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(194));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_208(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(195),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(195));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
if(!rel_8_author->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();return;
}
void subproof_209(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_8_author->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(195),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],0,0,0}});
auto range = rel_4_precededBy->equalRange_1(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[1],(args)[1],0,0}});
auto range = rel_8_author->equalRange_3(key,READ_OP_CONTEXT(rel_8_author_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(195));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_210(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(134),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(134));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[1],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();return;
}
void subproof_211(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_5_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(134),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],(args)[1],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(134));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_212(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(196),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(196));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
if(!rel_8_author->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_213(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_8_author->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(196),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[1],0,0}});
auto range = rel_4_precededBy->equalRange_2(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[0],(args)[0],0,0}});
auto range = rel_8_author->equalRange_3(key,READ_OP_CONTEXT(rel_8_author_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(196));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_214(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(197),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(197));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
if(!rel_8_author->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_215(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_8_author->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(197),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],0,0,0}});
auto range = rel_4_precededBy->equalRange_1(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],env1[1],0,0}});
auto range = rel_8_author->equalRange_3(key,READ_OP_CONTEXT(rel_8_author_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(197));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_216(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(198),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(198));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[1],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();return;
}
void subproof_217(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(198),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],(args)[1],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(198));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_218(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(199),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(199));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[1],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[0],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_219(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_3_genre->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(199),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],(args)[1],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[1],env1[0],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(199));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_220(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(200),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(200));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[0],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_221(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(200),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],(args)[0],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(200));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_222(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(201),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(201));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[0],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[1],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();return;
}
void subproof_223(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_3_genre->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(201),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],(args)[0],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[1],env1[0],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(201));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_224(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(202),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(202));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_225(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_3_genre->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(202),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[1],0,0}});
auto range = rel_3_genre->equalRange_2(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],env1[0],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(202));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_226(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(203),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(203));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_227(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_3_genre->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(203),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],0,0,0}});
auto range = rel_3_genre->equalRange_1(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[1],(args)[0],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(203));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_228(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(204),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(204));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_229(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_3_genre->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(204),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[0],0,0}});
auto range = rel_3_genre->equalRange_2(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],env1[0],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(204));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_230(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(205),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(205));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();return;
}
void subproof_231(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_3_genre->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(205),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[0],0,0}});
auto range = rel_3_genre->equalRange_2(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[0],(args)[1],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(205));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_232(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(135),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(135));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[0],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_233(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_5_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(135),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],(args)[0],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(135));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_234(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(206),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(206));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_235(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_3_genre->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(206),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],0,0,0}});
auto range = rel_3_genre->equalRange_1(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],env1[1],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(206));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_236(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(207),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(207));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();return;
}
void subproof_237(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_3_genre->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(207),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],0,0,0}});
auto range = rel_3_genre->equalRange_1(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[1],(args)[1],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(207));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_238(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(208),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(208));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_239(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_3_genre->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(208),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[1],0,0}});
auto range = rel_3_genre->equalRange_2(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[0],(args)[0],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(208));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_240(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(209),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(209));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_241(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_3_genre->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(209),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],0,0,0}});
auto range = rel_3_genre->equalRange_1(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],env1[1],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(209));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_242(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(214),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(214));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
if(!rel_1_Iauthor->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_243(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_1_Iauthor->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(214),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[1],0,0}});
auto range = rel_3_genre->equalRange_2(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],env1[0],0,0}});
auto range = rel_1_Iauthor->equalRange_3(key,READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(214));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_244(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(215),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(215));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
if(!rel_1_Iauthor->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_245(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_1_Iauthor->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(215),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],0,0,0}});
auto range = rel_3_genre->equalRange_1(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[1],(args)[0],0,0}});
auto range = rel_1_Iauthor->equalRange_3(key,READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(215));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_246(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(216),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(216));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
if(!rel_1_Iauthor->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_247(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_1_Iauthor->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(216),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[0],0,0}});
auto range = rel_3_genre->equalRange_2(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],env1[0],0,0}});
auto range = rel_1_Iauthor->equalRange_3(key,READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(216));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_248(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(217),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(217));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
if(!rel_1_Iauthor->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();return;
}
void subproof_249(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_1_Iauthor->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(217),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[0],0,0}});
auto range = rel_3_genre->equalRange_2(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[0],(args)[1],0,0}});
auto range = rel_1_Iauthor->equalRange_3(key,READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(217));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_250(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(218),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(218));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
if(!rel_1_Iauthor->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_251(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_1_Iauthor->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(218),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],0,0,0}});
auto range = rel_3_genre->equalRange_1(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],env1[1],0,0}});
auto range = rel_1_Iauthor->equalRange_3(key,READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(218));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_252(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(219),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(219));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
if(!rel_1_Iauthor->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();return;
}
void subproof_253(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_1_Iauthor->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(219),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],0,0,0}});
auto range = rel_3_genre->equalRange_1(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[1],(args)[1],0,0}});
auto range = rel_1_Iauthor->equalRange_3(key,READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(219));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_254(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(137),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(137));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
if(!rel_8_author->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[0],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_255(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_8_author->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(137),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],(args)[0],0,0}});
auto range = rel_8_author->equalRange_3(key,READ_OP_CONTEXT(rel_8_author_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(137));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_256(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(220),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(220));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
if(!rel_1_Iauthor->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_257(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_1_Iauthor->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(220),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[1],0,0}});
auto range = rel_3_genre->equalRange_2(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[0],(args)[0],0,0}});
auto range = rel_1_Iauthor->equalRange_3(key,READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(220));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_258(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(221),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(221));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
if(!rel_1_Iauthor->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_259(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_1_Iauthor->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(221),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_1_Iauthor_op_ctxt,rel_1_Iauthor->createContext());
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],0,0,0}});
auto range = rel_3_genre->equalRange_1(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],env1[1],0,0}});
auto range = rel_1_Iauthor->equalRange_3(key,READ_OP_CONTEXT(rel_1_Iauthor_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(221));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_260(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(222),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(222));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[1],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[1],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();return;
}
void subproof_261(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_5_inv_0->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(222),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],(args)[1],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[0],env1[1],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(222));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_262(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(223),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(223));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[1],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[0],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_263(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_5_inv_0->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(223),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],(args)[1],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[1],env1[0],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(223));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_264(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(224),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(224));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[0],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[0],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_265(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_5_inv_0->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(224),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],(args)[0],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[0],env1[1],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(224));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_266(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(225),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(225));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[0],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[1],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();return;
}
void subproof_267(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_5_inv_0->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(225),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],(args)[0],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[1],env1[0],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(225));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_268(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(226),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(226));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_269(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_5_inv_0->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(226),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[1],0,0}});
auto range = rel_3_genre->equalRange_2(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],env1[0],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(226));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_270(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(227),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(227));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_271(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_5_inv_0->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(227),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],0,0,0}});
auto range = rel_3_genre->equalRange_1(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[1],(args)[0],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(227));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_272(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(228),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(228));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_273(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_5_inv_0->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(228),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[0],0,0}});
auto range = rel_3_genre->equalRange_2(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],env1[0],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(228));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_274(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(229),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(229));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();return;
}
void subproof_275(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_5_inv_0->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(229),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[0],0,0}});
auto range = rel_3_genre->equalRange_2(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[0],(args)[1],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(229));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_276(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(138),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(138));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[1],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();return;
}
void subproof_277(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(138),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],(args)[1],0,0}});
auto range = rel_4_precededBy->equalRange_3(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(138));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_278(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(230),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(230));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_279(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_5_inv_0->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(230),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],0,0,0}});
auto range = rel_3_genre->equalRange_1(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],env1[1],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(230));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_280(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(231),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(231));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();return;
}
void subproof_281(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_5_inv_0->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(231),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],0,0,0}});
auto range = rel_3_genre->equalRange_1(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[1],(args)[1],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(231));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_282(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(232),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(232));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_283(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_5_inv_0->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(232),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[1],0,0}});
auto range = rel_3_genre->equalRange_2(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[0],(args)[0],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(232));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_284(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(233),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(233));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_285(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_5_inv_0->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(233),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],0,0,0}});
auto range = rel_3_genre->equalRange_1(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],env1[1],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(233));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_286(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(235),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(235));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[1],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
if(!rel_8_author->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[0],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_287(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_8_author->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(235),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],(args)[1],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[1],env1[0],0,0}});
auto range = rel_8_author->equalRange_3(key,READ_OP_CONTEXT(rel_8_author_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(235));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_288(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(236),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(236));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[0],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
if(!rel_8_author->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[0],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_289(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_8_author->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(236),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],(args)[0],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[0],env1[1],0,0}});
auto range = rel_8_author->equalRange_3(key,READ_OP_CONTEXT(rel_8_author_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(236));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_290(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(238),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(238));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
if(!rel_8_author->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_291(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_8_author->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(238),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[1],0,0}});
auto range = rel_3_genre->equalRange_2(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],env1[0],0,0}});
auto range = rel_8_author->equalRange_3(key,READ_OP_CONTEXT(rel_8_author_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(238));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_292(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(239),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(239));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
if(!rel_8_author->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_293(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_8_author->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(239),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],0,0,0}});
auto range = rel_3_genre->equalRange_1(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[1],(args)[0],0,0}});
auto range = rel_8_author->equalRange_3(key,READ_OP_CONTEXT(rel_8_author_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(239));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_294(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(240),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(240));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
if(!rel_8_author->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_295(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_8_author->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(240),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[0],0,0}});
auto range = rel_3_genre->equalRange_2(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],env1[0],0,0}});
auto range = rel_8_author->equalRange_3(key,READ_OP_CONTEXT(rel_8_author_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(240));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_296(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(241),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(241));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
if(!rel_8_author->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_8_author_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();return;
}
void subproof_297(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_8_author->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(241),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_8_author_op_ctxt,rel_8_author->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[0],0,0}});
auto range = rel_3_genre->equalRange_2(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[0],(args)[1],0,0}});
auto range = rel_8_author->equalRange_3(key,READ_OP_CONTEXT(rel_8_author_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(241));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_298(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(139),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(139));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[1],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[0],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_299(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_4_precededBy->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(139),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],(args)[1],0,0}});
auto range = rel_4_precededBy->equalRange_3(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[1],env1[0],0,0}});
auto range = rel_4_precededBy->equalRange_3(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(139));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_300(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(12),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(12));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_301(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_4_precededBy->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(12),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[1],0,0}});
auto range = rel_4_precededBy->equalRange_2(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],env1[0],0,0}});
auto range = rel_4_precededBy->equalRange_3(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(12));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_302(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(13),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(13));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_303(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_4_precededBy->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(13),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],0,0,0}});
auto range = rel_4_precededBy->equalRange_1(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[1],(args)[0],0,0}});
auto range = rel_4_precededBy->equalRange_3(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(13));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_304(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(14),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(14));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_305(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_4_precededBy->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(14),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[0],0,0}});
auto range = rel_4_precededBy->equalRange_2(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],env1[0],0,0}});
auto range = rel_4_precededBy->equalRange_3(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(14));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_306(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(15),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(15));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();return;
}
void subproof_307(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_4_precededBy->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(15),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[0],0,0}});
auto range = rel_4_precededBy->equalRange_2(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[0],(args)[1],0,0}});
auto range = rel_4_precededBy->equalRange_3(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(15));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_308(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(16),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(16));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_309(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_4_precededBy->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(16),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],0,0,0}});
auto range = rel_4_precededBy->equalRange_1(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],env1[1],0,0}});
auto range = rel_4_precededBy->equalRange_3(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(16));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_310(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(17),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(17));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();return;
}
void subproof_311(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_4_precededBy->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(17),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],0,0,0}});
auto range = rel_4_precededBy->equalRange_1(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[1],(args)[1],0,0}});
auto range = rel_4_precededBy->equalRange_3(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(17));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_312(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(18),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(18));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_313(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_4_precededBy->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(18),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[1],0,0}});
auto range = rel_4_precededBy->equalRange_2(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[0],(args)[0],0,0}});
auto range = rel_4_precededBy->equalRange_3(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(18));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_314(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(19),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(19));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_315(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_4_precededBy->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(19),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],0,0,0}});
auto range = rel_4_precededBy->equalRange_1(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],env1[1],0,0}});
auto range = rel_4_precededBy->equalRange_3(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(19));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_316(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(20),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(20));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[1],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[1],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();return;
}
void subproof_317(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_3_genre->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(20),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],(args)[1],0,0}});
auto range = rel_4_precededBy->equalRange_3(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[0],env1[1],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(20));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_318(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(21),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(21));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[1],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[0],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_319(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_3_genre->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(21),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],(args)[1],0,0}});
auto range = rel_4_precededBy->equalRange_3(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[1],env1[0],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(21));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_320(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(0),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(0));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[1],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();return;
}
void subproof_321(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(0),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],(args)[1],0,0}});
auto range = rel_4_precededBy->equalRange_3(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_322(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(22),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(22));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[0],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[0],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_323(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_3_genre->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(22),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],(args)[0],0,0}});
auto range = rel_4_precededBy->equalRange_3(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[0],env1[1],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(22));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_324(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(23),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(23));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[0],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[1],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();return;
}
void subproof_325(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_3_genre->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(23),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],(args)[0],0,0}});
auto range = rel_4_precededBy->equalRange_3(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[1],env1[0],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(23));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_326(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(24),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(24));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_327(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_3_genre->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(24),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[1],0,0}});
auto range = rel_4_precededBy->equalRange_2(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],env1[0],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(24));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_328(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(25),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(25));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_329(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_3_genre->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(25),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],0,0,0}});
auto range = rel_4_precededBy->equalRange_1(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[1],(args)[0],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(25));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_330(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(26),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(26));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_331(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_3_genre->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(26),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[0],0,0}});
auto range = rel_4_precededBy->equalRange_2(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],env1[0],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(26));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_332(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(27),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(27));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();return;
}
void subproof_333(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_3_genre->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(27),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[0],0,0}});
auto range = rel_4_precededBy->equalRange_2(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[0],(args)[1],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(27));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_334(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(28),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(28));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_335(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_3_genre->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(28),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],0,0,0}});
auto range = rel_4_precededBy->equalRange_1(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],env1[1],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(28));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_336(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(29),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(29));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();return;
}
void subproof_337(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_3_genre->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(29),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],0,0,0}});
auto range = rel_4_precededBy->equalRange_1(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[1],(args)[1],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(29));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_338(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(30),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(30));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_339(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_3_genre->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(30),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[1],0,0}});
auto range = rel_4_precededBy->equalRange_2(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[0],(args)[0],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(30));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_340(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(31),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(31));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_341(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_3_genre->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(31),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],0,0,0}});
auto range = rel_4_precededBy->equalRange_1(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],env1[1],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(31));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_342(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(1),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(1));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[0],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_343(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(1),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],(args)[0],0,0}});
auto range = rel_4_precededBy->equalRange_3(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_344(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(45),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(45));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[1],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[0],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_345(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_5_inv_0->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(45),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],(args)[1],0,0}});
auto range = rel_4_precededBy->equalRange_3(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[1],env1[0],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(45));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_346(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(46),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(46));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[0],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[0],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_347(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_5_inv_0->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(46),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],(args)[0],0,0}});
auto range = rel_4_precededBy->equalRange_3(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[0],env1[1],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(46));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_348(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(48),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(48));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_349(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_5_inv_0->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(48),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[1],0,0}});
auto range = rel_4_precededBy->equalRange_2(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],env1[0],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(48));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_350(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(49),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(49));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_351(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_5_inv_0->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(49),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],0,0,0}});
auto range = rel_4_precededBy->equalRange_1(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[1],(args)[0],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(49));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_352(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(50),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(50));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_353(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_5_inv_0->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(50),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[0],0,0}});
auto range = rel_4_precededBy->equalRange_2(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],env1[0],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(50));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_354(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(51),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(51));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();return;
}
void subproof_355(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_5_inv_0->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(51),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[0],0,0}});
auto range = rel_4_precededBy->equalRange_2(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[0],(args)[1],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(51));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_356(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(52),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(52));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_357(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_5_inv_0->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(52),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],0,0,0}});
auto range = rel_4_precededBy->equalRange_1(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],env1[1],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(52));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_358(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(53),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(53));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();return;
}
void subproof_359(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_5_inv_0->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(53),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],0,0,0}});
auto range = rel_4_precededBy->equalRange_1(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[1],(args)[1],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(53));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_360(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(54),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(54));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_361(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_5_inv_0->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(54),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[1],0,0}});
auto range = rel_4_precededBy->equalRange_2(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[0],(args)[0],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(54));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_362(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(55),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(55));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_363(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_5_inv_0->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(55),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],0,0,0}});
auto range = rel_4_precededBy->equalRange_1(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],env1[1],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(55));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_364(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(2),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(2));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[1],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();return;
}
void subproof_365(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(2),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],(args)[1],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_366(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(56),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(56));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[1],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();return;
}
void subproof_367(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(56),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],(args)[1],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(56));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_368(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(57),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(57));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[1],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[0],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_369(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_3_genre->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(57),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],(args)[1],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[1],env1[0],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(57));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_370(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(58),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(58));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[0],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_371(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(58),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],(args)[0],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(58));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_372(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(59),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(59));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[0],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[1],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();return;
}
void subproof_373(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_3_genre->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(59),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],(args)[0],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[1],env1[0],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(59));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_374(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(60),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(60));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_375(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_3_genre->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(60),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[1],0,0}});
auto range = rel_3_genre->equalRange_2(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],env1[0],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(60));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_376(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(61),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(61));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_377(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_3_genre->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(61),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],0,0,0}});
auto range = rel_3_genre->equalRange_1(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[1],(args)[0],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(61));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_378(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(62),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(62));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_379(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_3_genre->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(62),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[0],0,0}});
auto range = rel_3_genre->equalRange_2(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],env1[0],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(62));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_380(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(63),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(63));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();return;
}
void subproof_381(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_3_genre->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(63),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[0],0,0}});
auto range = rel_3_genre->equalRange_2(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[0],(args)[1],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(63));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_382(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(64),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(64));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_383(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_3_genre->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(64),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],0,0,0}});
auto range = rel_3_genre->equalRange_1(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],env1[1],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(64));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_384(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(65),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(65));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();return;
}
void subproof_385(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_3_genre->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(65),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],0,0,0}});
auto range = rel_3_genre->equalRange_1(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[1],(args)[1],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(65));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_386(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(3),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(3));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[0],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_387(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(3),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],(args)[0],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(3));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_388(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(66),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(66));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_389(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_3_genre->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(66),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[1],0,0}});
auto range = rel_3_genre->equalRange_2(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[0],(args)[0],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(66));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_390(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(67),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(67));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_391(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_3_genre->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(67),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],0,0,0}});
auto range = rel_3_genre->equalRange_1(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],env1[1],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(67));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_392(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(81),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(81));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[1],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[0],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_393(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_5_inv_0->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(81),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],(args)[1],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[1],env1[0],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(81));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_394(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(82),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(82));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[0],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[0],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_395(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_5_inv_0->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(82),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],(args)[0],0,0}});
auto range = rel_3_genre->equalRange_3(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[0],env1[1],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(82));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_396(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(84),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(84));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_397(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_5_inv_0->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(84),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[1],0,0}});
auto range = rel_3_genre->equalRange_2(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],env1[0],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(84));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_398(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(85),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(85));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_399(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_5_inv_0->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(85),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],0,0,0}});
auto range = rel_3_genre->equalRange_1(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[1],(args)[0],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(85));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_400(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(86),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(86));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_401(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_5_inv_0->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(86),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[0],0,0}});
auto range = rel_3_genre->equalRange_2(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],env1[0],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(86));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_402(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(87),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(87));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();return;
}
void subproof_403(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_5_inv_0->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(87),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[0],0,0}});
auto range = rel_3_genre->equalRange_2(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[0],(args)[1],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(87));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_404(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(88),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(88));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_405(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_5_inv_0->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(88),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],0,0,0}});
auto range = rel_3_genre->equalRange_1(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],env1[1],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(88));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_406(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(89),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(89));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();return;
}
void subproof_407(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_5_inv_0->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(89),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],0,0,0}});
auto range = rel_3_genre->equalRange_1(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[1],(args)[1],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(89));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_408(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(7),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(7));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[0],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_409(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_5_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(7),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],(args)[0],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(7));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_410(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(90),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(90));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_411(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_5_inv_0->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(90),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[1],0,0}});
auto range = rel_3_genre->equalRange_2(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[0],(args)[0],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(90));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_412(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(91),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(91));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
if(!rel_3_genre->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_3_genre_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_413(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_5_inv_0->empty()) && !(rel_3_genre->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(91),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_3_genre_op_ctxt,rel_3_genre->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],0,0,0}});
auto range = rel_3_genre->equalRange_1(key,READ_OP_CONTEXT(rel_3_genre_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],env1[1],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(91));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_414(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(118),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(118));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[0],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_415(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_5_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(118),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],(args)[0],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(118));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_416(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(120),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(120));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_417(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_5_inv_0->empty()) && !(rel_5_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(120),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[1],0,0}});
auto range = rel_5_inv_0->equalRange_2(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],env1[0],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(120));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_418(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(121),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(121));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_419(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_5_inv_0->empty()) && !(rel_5_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(121),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],0,0,0}});
auto range = rel_5_inv_0->equalRange_1(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[1],(args)[0],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(121));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_420(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(122),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(122));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_421(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_5_inv_0->empty()) && !(rel_5_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(122),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[0],0,0}});
auto range = rel_5_inv_0->equalRange_2(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],env1[0],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(122));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_422(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(123),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(123));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();return;
}
void subproof_423(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_5_inv_0->empty()) && !(rel_5_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(123),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[0],0,0}});
auto range = rel_5_inv_0->equalRange_2(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[0],(args)[1],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(123));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_424(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(124),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(124));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_425(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_5_inv_0->empty()) && !(rel_5_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(124),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],0,0,0}});
auto range = rel_5_inv_0->equalRange_1(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],env1[1],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(124));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_426(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(125),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(125));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();return;
}
void subproof_427(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_5_inv_0->empty()) && !(rel_5_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(125),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],0,0,0}});
auto range = rel_5_inv_0->equalRange_1(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[1],(args)[1],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(125));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_428(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(126),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(126));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[1],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[2],(args)[0],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_429(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_5_inv_0->empty()) && !(rel_5_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(126),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{0,(args)[1],0,0}});
auto range = rel_5_inv_0->equalRange_2(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[0],(args)[0],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(126));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_430(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(8),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(8));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[1],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();return;
}
void subproof_431(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(8),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],(args)[1],0,0}});
auto range = rel_4_precededBy->equalRange_3(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(8));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_432(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(127),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(127));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[2],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
if(!rel_5_inv_0->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[2],0,0}}),READ_OP_CONTEXT(rel_5_inv_0_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
();return;
}
void subproof_433(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_5_inv_0->empty()) && !(rel_5_inv_0->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(127),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_5_inv_0_op_ctxt,rel_5_inv_0->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],0,0,0}});
auto range = rel_5_inv_0->equalRange_1(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],env1[1],0,0}});
auto range = rel_5_inv_0->equalRange_3(key,READ_OP_CONTEXT(rel_5_inv_0_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(127));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env2[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_434(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(9),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(9));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[1],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[0],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_435(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_4_precededBy->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(9),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[0],(args)[1],0,0}});
auto range = rel_4_precededBy->equalRange_3(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[1],env1[0],0,0}});
auto range = rel_4_precededBy->equalRange_3(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(9));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_436(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(10),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(10));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[0],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();return;
}
void subproof_437(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(10),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],(args)[0],0,0}});
auto range = rel_4_precededBy->equalRange_3(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(10));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
void subproof_438(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
[&](){
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
if(!rel_2_Rule->equalRange_1(Tuple<RamDomain,3>({{RamDomain(11),0,0}}),READ_OP_CONTEXT(rel_2_Rule_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(0));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back(RamDomain(11));
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[1],(args)[0],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(1));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
}
();[&](){
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
if(!rel_4_precededBy->equalRange_3(Tuple<RamDomain,4>({{(args)[0],(args)[1],0,0}}),READ_OP_CONTEXT(rel_4_precededBy_op_ctxt)).empty()) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(2));
err.push_back(false);
}
}
();[&](){
std::lock_guard<std::mutex> guard(lock);
ret.push_back(0);
err.push_back(true);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
}
();return;
}
void subproof_439(const std::vector<RamDomain>& args, std::vector<RamDomain>& ret, std::vector<bool>& err) {
std::mutex lock;
if(!(rel_4_precededBy->empty()) && !(rel_4_precededBy->empty()) && !(rel_2_Rule->empty())) {
[&](){
const Tuple<RamDomain,3> key({{RamDomain(11),0,0}});
auto range = rel_2_Rule->equalRange_1(key);
auto part = range.partition();
PARALLEL_START;
CREATE_OP_CONTEXT(rel_2_Rule_op_ctxt,rel_2_Rule->createContext());
CREATE_OP_CONTEXT(rel_4_precededBy_op_ctxt,rel_4_precededBy->createContext());
pfor(auto it = part.begin(); it<part.end(); ++it) { 
try{
for(const auto& env0 : *it) {
if( ((env0[2]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{(args)[1],(args)[0],0,0}});
auto range = rel_4_precededBy->equalRange_3(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env1 : range) {
if( ((env1[3]) < ((args)[2]))) {
const Tuple<RamDomain,4> key({{env1[1],env1[0],0,0}});
auto range = rel_4_precededBy->equalRange_3(key,READ_OP_CONTEXT(rel_4_precededBy_op_ctxt));
for(const auto& env2 : range) {
if( ((env2[3]) < ((args)[2]))) {
std::lock_guard<std::mutex> guard(lock);
ret.push_back(RamDomain(11));
err.push_back(false);
ret.push_back(env0[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back(env2[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back(env1[1]);
err.push_back(false);
ret.push_back((args)[0]);
err.push_back(false);
ret.push_back(env1[0]);
err.push_back(false);
ret.push_back((args)[1]);
err.push_back(false);
ret.push_back(env0[2]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env1[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
ret.push_back(env2[3]);
err.push_back(false);
ret.push_back((args)[2]);
err.push_back(false);
}
}
}
}
}
}
} catch(std::exception &e) { SignalHandler::instance()->error(e.what());}
}
PARALLEL_END;
}
();}
return;
}
};
SouffleProgram *newInstance_souffle_small(){return new Sf_souffle_small;}
SymbolTable *getST_souffle_small(SouffleProgram *p){return &reinterpret_cast<Sf_souffle_small*>(p)->symTable;}

#ifdef __EMBEDDED_SOUFFLE__
class factory_Sf_souffle_small: public souffle::ProgramFactory {
SouffleProgram *newInstance() {
return new Sf_souffle_small();
};
public:
factory_Sf_souffle_small() : ProgramFactory("souffle_small"){}
};
static factory_Sf_souffle_small __factory_Sf_souffle_small_instance;
}
#else
}
int main(int argc, char** argv)
{
try{
souffle::CmdOptions opt(R"(rules.dl)",
R"(.)",
R"(.)",
false,
R"()",
5000,
-1);
if (!opt.parse(argc,argv)) return 1;
souffle::Sf_souffle_small obj;
#if defined(_OPENMP) 
obj.setNumThreads(opt.getNumJobs());

#endif
obj.runAll(opt.getInputFileDir(), opt.getOutputFileDir(), opt.getStratumIndex());
explain(obj, false);
return 0;
} catch(std::exception &e) { souffle::SignalHandler::instance()->error(e.what());}
}

#endif
